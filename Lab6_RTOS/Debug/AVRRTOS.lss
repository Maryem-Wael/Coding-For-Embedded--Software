
AVRRTOS.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000014  00800100  00005022  000050b6  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00005022  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000067c  00800114  00800114  000050ca  2**0
                  ALLOC
  3 .stab         0000732c  00000000  00000000  000050cc  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000045d4  00000000  00000000  0000c3f8  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 46 00 	jmp	0x8c	; 0x8c <__ctors_end>
       4:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
       8:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
       c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      10:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      14:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      18:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      1c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      20:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      24:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      28:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      2c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      30:	0c 94 b8 03 	jmp	0x770	; 0x770 <__vector_12>
      34:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      38:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      3c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      40:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      44:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      48:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      4c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      50:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      54:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      58:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      5c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      60:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      64:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      68:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      6c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      70:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      74:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      78:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      7c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      80:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      84:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      88:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>

0000008c <__ctors_end>:
      8c:	11 24       	eor	r1, r1
      8e:	1f be       	out	0x3f, r1	; 63
      90:	cf ef       	ldi	r28, 0xFF	; 255
      92:	d0 e1       	ldi	r29, 0x10	; 16
      94:	de bf       	out	0x3e, r29	; 62
      96:	cd bf       	out	0x3d, r28	; 61

00000098 <__do_copy_data>:
      98:	11 e0       	ldi	r17, 0x01	; 1
      9a:	a0 e0       	ldi	r26, 0x00	; 0
      9c:	b1 e0       	ldi	r27, 0x01	; 1
      9e:	e2 e2       	ldi	r30, 0x22	; 34
      a0:	f0 e5       	ldi	r31, 0x50	; 80
      a2:	00 e0       	ldi	r16, 0x00	; 0
      a4:	0b bf       	out	0x3b, r16	; 59
      a6:	02 c0       	rjmp	.+4      	; 0xac <__do_copy_data+0x14>
      a8:	07 90       	elpm	r0, Z+
      aa:	0d 92       	st	X+, r0
      ac:	a4 31       	cpi	r26, 0x14	; 20
      ae:	b1 07       	cpc	r27, r17
      b0:	d9 f7       	brne	.-10     	; 0xa8 <__do_copy_data+0x10>

000000b2 <__do_clear_bss>:
      b2:	17 e0       	ldi	r17, 0x07	; 7
      b4:	a4 e1       	ldi	r26, 0x14	; 20
      b6:	b1 e0       	ldi	r27, 0x01	; 1
      b8:	01 c0       	rjmp	.+2      	; 0xbc <.do_clear_bss_start>

000000ba <.do_clear_bss_loop>:
      ba:	1d 92       	st	X+, r1

000000bc <.do_clear_bss_start>:
      bc:	a0 39       	cpi	r26, 0x90	; 144
      be:	b1 07       	cpc	r27, r17
      c0:	e1 f7       	brne	.-8      	; 0xba <.do_clear_bss_loop>
      c2:	0e 94 97 27 	call	0x4f2e	; 0x4f2e <main>
      c6:	0c 94 0f 28 	jmp	0x501e	; 0x501e <_exit>

000000ca <__bad_interrupt>:
      ca:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000ce <pvPortMalloc>:
      ce:	df 93       	push	r29
      d0:	cf 93       	push	r28
      d2:	00 d0       	rcall	.+0      	; 0xd4 <pvPortMalloc+0x6>
      d4:	00 d0       	rcall	.+0      	; 0xd6 <pvPortMalloc+0x8>
      d6:	cd b7       	in	r28, 0x3d	; 61
      d8:	de b7       	in	r29, 0x3e	; 62
      da:	9c 83       	std	Y+4, r25	; 0x04
      dc:	8b 83       	std	Y+3, r24	; 0x03
      de:	1a 82       	std	Y+2, r1	; 0x02
      e0:	19 82       	std	Y+1, r1	; 0x01
      e2:	0e 94 73 17 	call	0x2ee6	; 0x2ee6 <vTaskSuspendAll>
      e6:	80 91 16 01 	lds	r24, 0x0116
      ea:	90 91 17 01 	lds	r25, 0x0117
      ee:	00 97       	sbiw	r24, 0x00	; 0
      f0:	31 f4       	brne	.+12     	; 0xfe <pvPortMalloc+0x30>
      f2:	88 e1       	ldi	r24, 0x18	; 24
      f4:	91 e0       	ldi	r25, 0x01	; 1
      f6:	90 93 17 01 	sts	0x0117, r25
      fa:	80 93 16 01 	sts	0x0116, r24
      fe:	8b 81       	ldd	r24, Y+3	; 0x03
     100:	9c 81       	ldd	r25, Y+4	; 0x04
     102:	00 97       	sbiw	r24, 0x00	; 0
     104:	99 f1       	breq	.+102    	; 0x16c <pvPortMalloc+0x9e>
     106:	80 91 14 01 	lds	r24, 0x0114
     10a:	90 91 15 01 	lds	r25, 0x0115
     10e:	2b 81       	ldd	r18, Y+3	; 0x03
     110:	3c 81       	ldd	r19, Y+4	; 0x04
     112:	82 0f       	add	r24, r18
     114:	93 1f       	adc	r25, r19
     116:	25 e0       	ldi	r18, 0x05	; 5
     118:	8b 3d       	cpi	r24, 0xDB	; 219
     11a:	92 07       	cpc	r25, r18
     11c:	38 f5       	brcc	.+78     	; 0x16c <pvPortMalloc+0x9e>
     11e:	20 91 14 01 	lds	r18, 0x0114
     122:	30 91 15 01 	lds	r19, 0x0115
     126:	8b 81       	ldd	r24, Y+3	; 0x03
     128:	9c 81       	ldd	r25, Y+4	; 0x04
     12a:	28 0f       	add	r18, r24
     12c:	39 1f       	adc	r19, r25
     12e:	80 91 14 01 	lds	r24, 0x0114
     132:	90 91 15 01 	lds	r25, 0x0115
     136:	82 17       	cp	r24, r18
     138:	93 07       	cpc	r25, r19
     13a:	c0 f4       	brcc	.+48     	; 0x16c <pvPortMalloc+0x9e>
     13c:	20 91 16 01 	lds	r18, 0x0116
     140:	30 91 17 01 	lds	r19, 0x0117
     144:	80 91 14 01 	lds	r24, 0x0114
     148:	90 91 15 01 	lds	r25, 0x0115
     14c:	82 0f       	add	r24, r18
     14e:	93 1f       	adc	r25, r19
     150:	9a 83       	std	Y+2, r25	; 0x02
     152:	89 83       	std	Y+1, r24	; 0x01
     154:	20 91 14 01 	lds	r18, 0x0114
     158:	30 91 15 01 	lds	r19, 0x0115
     15c:	8b 81       	ldd	r24, Y+3	; 0x03
     15e:	9c 81       	ldd	r25, Y+4	; 0x04
     160:	82 0f       	add	r24, r18
     162:	93 1f       	adc	r25, r19
     164:	90 93 15 01 	sts	0x0115, r25
     168:	80 93 14 01 	sts	0x0114, r24
     16c:	0e 94 7f 17 	call	0x2efe	; 0x2efe <xTaskResumeAll>
     170:	89 81       	ldd	r24, Y+1	; 0x01
     172:	9a 81       	ldd	r25, Y+2	; 0x02
     174:	0f 90       	pop	r0
     176:	0f 90       	pop	r0
     178:	0f 90       	pop	r0
     17a:	0f 90       	pop	r0
     17c:	cf 91       	pop	r28
     17e:	df 91       	pop	r29
     180:	08 95       	ret

00000182 <vPortFree>:
    return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void * pv )
{
     182:	df 93       	push	r29
     184:	cf 93       	push	r28
     186:	00 d0       	rcall	.+0      	; 0x188 <vPortFree+0x6>
     188:	cd b7       	in	r28, 0x3d	; 61
     18a:	de b7       	in	r29, 0x3e	; 62
     18c:	9a 83       	std	Y+2, r25	; 0x02
     18e:	89 83       	std	Y+1, r24	; 0x01
     * https://www.FreeRTOS.org for more information. */
    ( void ) pv;

    /* Force an assert as it is invalid to call this function. */
    configASSERT( pv == NULL );
}
     190:	0f 90       	pop	r0
     192:	0f 90       	pop	r0
     194:	cf 91       	pop	r28
     196:	df 91       	pop	r29
     198:	08 95       	ret

0000019a <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
     19a:	df 93       	push	r29
     19c:	cf 93       	push	r28
     19e:	cd b7       	in	r28, 0x3d	; 61
     1a0:	de b7       	in	r29, 0x3e	; 62
    /* Only required when static memory is not cleared. */
    xNextFreeByte = ( size_t ) 0;
     1a2:	10 92 15 01 	sts	0x0115, r1
     1a6:	10 92 14 01 	sts	0x0114, r1
}
     1aa:	cf 91       	pop	r28
     1ac:	df 91       	pop	r29
     1ae:	08 95       	ret

000001b0 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
     1b0:	df 93       	push	r29
     1b2:	cf 93       	push	r28
     1b4:	cd b7       	in	r28, 0x3d	; 61
     1b6:	de b7       	in	r29, 0x3e	; 62
    return( configADJUSTED_HEAP_SIZE - xNextFreeByte );
     1b8:	20 91 14 01 	lds	r18, 0x0114
     1bc:	30 91 15 01 	lds	r19, 0x0115
     1c0:	8b ed       	ldi	r24, 0xDB	; 219
     1c2:	95 e0       	ldi	r25, 0x05	; 5
     1c4:	82 1b       	sub	r24, r18
     1c6:	93 0b       	sbc	r25, r19
}
     1c8:	cf 91       	pop	r28
     1ca:	df 91       	pop	r29
     1cc:	08 95       	ret

000001ce <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
     1ce:	df 93       	push	r29
     1d0:	cf 93       	push	r28
     1d2:	cd b7       	in	r28, 0x3d	; 61
     1d4:	de b7       	in	r29, 0x3e	; 62
     1d6:	28 97       	sbiw	r28, 0x08	; 8
     1d8:	0f b6       	in	r0, 0x3f	; 63
     1da:	f8 94       	cli
     1dc:	de bf       	out	0x3e, r29	; 62
     1de:	0f be       	out	0x3f, r0	; 63
     1e0:	cd bf       	out	0x3d, r28	; 61
     1e2:	9c 83       	std	Y+4, r25	; 0x04
     1e4:	8b 83       	std	Y+3, r24	; 0x03
     1e6:	7e 83       	std	Y+6, r23	; 0x06
     1e8:	6d 83       	std	Y+5, r22	; 0x05
     1ea:	58 87       	std	Y+8, r21	; 0x08
     1ec:	4f 83       	std	Y+7, r20	; 0x07
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
     1ee:	eb 81       	ldd	r30, Y+3	; 0x03
     1f0:	fc 81       	ldd	r31, Y+4	; 0x04
     1f2:	81 e1       	ldi	r24, 0x11	; 17
     1f4:	80 83       	st	Z, r24
	pxTopOfStack--;
     1f6:	8b 81       	ldd	r24, Y+3	; 0x03
     1f8:	9c 81       	ldd	r25, Y+4	; 0x04
     1fa:	01 97       	sbiw	r24, 0x01	; 1
     1fc:	9c 83       	std	Y+4, r25	; 0x04
     1fe:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
     200:	eb 81       	ldd	r30, Y+3	; 0x03
     202:	fc 81       	ldd	r31, Y+4	; 0x04
     204:	82 e2       	ldi	r24, 0x22	; 34
     206:	80 83       	st	Z, r24
	pxTopOfStack--;
     208:	8b 81       	ldd	r24, Y+3	; 0x03
     20a:	9c 81       	ldd	r25, Y+4	; 0x04
     20c:	01 97       	sbiw	r24, 0x01	; 1
     20e:	9c 83       	std	Y+4, r25	; 0x04
     210:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
     212:	eb 81       	ldd	r30, Y+3	; 0x03
     214:	fc 81       	ldd	r31, Y+4	; 0x04
     216:	83 e3       	ldi	r24, 0x33	; 51
     218:	80 83       	st	Z, r24
	pxTopOfStack--;
     21a:	8b 81       	ldd	r24, Y+3	; 0x03
     21c:	9c 81       	ldd	r25, Y+4	; 0x04
     21e:	01 97       	sbiw	r24, 0x01	; 1
     220:	9c 83       	std	Y+4, r25	; 0x04
     222:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
     224:	8d 81       	ldd	r24, Y+5	; 0x05
     226:	9e 81       	ldd	r25, Y+6	; 0x06
     228:	9a 83       	std	Y+2, r25	; 0x02
     22a:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     22c:	89 81       	ldd	r24, Y+1	; 0x01
     22e:	eb 81       	ldd	r30, Y+3	; 0x03
     230:	fc 81       	ldd	r31, Y+4	; 0x04
     232:	80 83       	st	Z, r24
	pxTopOfStack--;
     234:	8b 81       	ldd	r24, Y+3	; 0x03
     236:	9c 81       	ldd	r25, Y+4	; 0x04
     238:	01 97       	sbiw	r24, 0x01	; 1
     23a:	9c 83       	std	Y+4, r25	; 0x04
     23c:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
     23e:	89 81       	ldd	r24, Y+1	; 0x01
     240:	9a 81       	ldd	r25, Y+2	; 0x02
     242:	89 2f       	mov	r24, r25
     244:	99 27       	eor	r25, r25
     246:	9a 83       	std	Y+2, r25	; 0x02
     248:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     24a:	89 81       	ldd	r24, Y+1	; 0x01
     24c:	eb 81       	ldd	r30, Y+3	; 0x03
     24e:	fc 81       	ldd	r31, Y+4	; 0x04
     250:	80 83       	st	Z, r24
	pxTopOfStack--;
     252:	8b 81       	ldd	r24, Y+3	; 0x03
     254:	9c 81       	ldd	r25, Y+4	; 0x04
     256:	01 97       	sbiw	r24, 0x01	; 1
     258:	9c 83       	std	Y+4, r25	; 0x04
     25a:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
     25c:	eb 81       	ldd	r30, Y+3	; 0x03
     25e:	fc 81       	ldd	r31, Y+4	; 0x04
     260:	10 82       	st	Z, r1
	pxTopOfStack--;
     262:	8b 81       	ldd	r24, Y+3	; 0x03
     264:	9c 81       	ldd	r25, Y+4	; 0x04
     266:	01 97       	sbiw	r24, 0x01	; 1
     268:	9c 83       	std	Y+4, r25	; 0x04
     26a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
     26c:	eb 81       	ldd	r30, Y+3	; 0x03
     26e:	fc 81       	ldd	r31, Y+4	; 0x04
     270:	80 e8       	ldi	r24, 0x80	; 128
     272:	80 83       	st	Z, r24
	pxTopOfStack--;
     274:	8b 81       	ldd	r24, Y+3	; 0x03
     276:	9c 81       	ldd	r25, Y+4	; 0x04
     278:	01 97       	sbiw	r24, 0x01	; 1
     27a:	9c 83       	std	Y+4, r25	; 0x04
     27c:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
     27e:	eb 81       	ldd	r30, Y+3	; 0x03
     280:	fc 81       	ldd	r31, Y+4	; 0x04
     282:	10 82       	st	Z, r1
	pxTopOfStack--;
     284:	8b 81       	ldd	r24, Y+3	; 0x03
     286:	9c 81       	ldd	r25, Y+4	; 0x04
     288:	01 97       	sbiw	r24, 0x01	; 1
     28a:	9c 83       	std	Y+4, r25	; 0x04
     28c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
     28e:	eb 81       	ldd	r30, Y+3	; 0x03
     290:	fc 81       	ldd	r31, Y+4	; 0x04
     292:	82 e0       	ldi	r24, 0x02	; 2
     294:	80 83       	st	Z, r24
	pxTopOfStack--;
     296:	8b 81       	ldd	r24, Y+3	; 0x03
     298:	9c 81       	ldd	r25, Y+4	; 0x04
     29a:	01 97       	sbiw	r24, 0x01	; 1
     29c:	9c 83       	std	Y+4, r25	; 0x04
     29e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
     2a0:	eb 81       	ldd	r30, Y+3	; 0x03
     2a2:	fc 81       	ldd	r31, Y+4	; 0x04
     2a4:	83 e0       	ldi	r24, 0x03	; 3
     2a6:	80 83       	st	Z, r24
	pxTopOfStack--;
     2a8:	8b 81       	ldd	r24, Y+3	; 0x03
     2aa:	9c 81       	ldd	r25, Y+4	; 0x04
     2ac:	01 97       	sbiw	r24, 0x01	; 1
     2ae:	9c 83       	std	Y+4, r25	; 0x04
     2b0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
     2b2:	eb 81       	ldd	r30, Y+3	; 0x03
     2b4:	fc 81       	ldd	r31, Y+4	; 0x04
     2b6:	84 e0       	ldi	r24, 0x04	; 4
     2b8:	80 83       	st	Z, r24
	pxTopOfStack--;
     2ba:	8b 81       	ldd	r24, Y+3	; 0x03
     2bc:	9c 81       	ldd	r25, Y+4	; 0x04
     2be:	01 97       	sbiw	r24, 0x01	; 1
     2c0:	9c 83       	std	Y+4, r25	; 0x04
     2c2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
     2c4:	eb 81       	ldd	r30, Y+3	; 0x03
     2c6:	fc 81       	ldd	r31, Y+4	; 0x04
     2c8:	85 e0       	ldi	r24, 0x05	; 5
     2ca:	80 83       	st	Z, r24
	pxTopOfStack--;
     2cc:	8b 81       	ldd	r24, Y+3	; 0x03
     2ce:	9c 81       	ldd	r25, Y+4	; 0x04
     2d0:	01 97       	sbiw	r24, 0x01	; 1
     2d2:	9c 83       	std	Y+4, r25	; 0x04
     2d4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
     2d6:	eb 81       	ldd	r30, Y+3	; 0x03
     2d8:	fc 81       	ldd	r31, Y+4	; 0x04
     2da:	86 e0       	ldi	r24, 0x06	; 6
     2dc:	80 83       	st	Z, r24
	pxTopOfStack--;
     2de:	8b 81       	ldd	r24, Y+3	; 0x03
     2e0:	9c 81       	ldd	r25, Y+4	; 0x04
     2e2:	01 97       	sbiw	r24, 0x01	; 1
     2e4:	9c 83       	std	Y+4, r25	; 0x04
     2e6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
     2e8:	eb 81       	ldd	r30, Y+3	; 0x03
     2ea:	fc 81       	ldd	r31, Y+4	; 0x04
     2ec:	87 e0       	ldi	r24, 0x07	; 7
     2ee:	80 83       	st	Z, r24
	pxTopOfStack--;
     2f0:	8b 81       	ldd	r24, Y+3	; 0x03
     2f2:	9c 81       	ldd	r25, Y+4	; 0x04
     2f4:	01 97       	sbiw	r24, 0x01	; 1
     2f6:	9c 83       	std	Y+4, r25	; 0x04
     2f8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
     2fa:	eb 81       	ldd	r30, Y+3	; 0x03
     2fc:	fc 81       	ldd	r31, Y+4	; 0x04
     2fe:	88 e0       	ldi	r24, 0x08	; 8
     300:	80 83       	st	Z, r24
	pxTopOfStack--;
     302:	8b 81       	ldd	r24, Y+3	; 0x03
     304:	9c 81       	ldd	r25, Y+4	; 0x04
     306:	01 97       	sbiw	r24, 0x01	; 1
     308:	9c 83       	std	Y+4, r25	; 0x04
     30a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
     30c:	eb 81       	ldd	r30, Y+3	; 0x03
     30e:	fc 81       	ldd	r31, Y+4	; 0x04
     310:	89 e0       	ldi	r24, 0x09	; 9
     312:	80 83       	st	Z, r24
	pxTopOfStack--;
     314:	8b 81       	ldd	r24, Y+3	; 0x03
     316:	9c 81       	ldd	r25, Y+4	; 0x04
     318:	01 97       	sbiw	r24, 0x01	; 1
     31a:	9c 83       	std	Y+4, r25	; 0x04
     31c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
     31e:	eb 81       	ldd	r30, Y+3	; 0x03
     320:	fc 81       	ldd	r31, Y+4	; 0x04
     322:	80 e1       	ldi	r24, 0x10	; 16
     324:	80 83       	st	Z, r24
	pxTopOfStack--;
     326:	8b 81       	ldd	r24, Y+3	; 0x03
     328:	9c 81       	ldd	r25, Y+4	; 0x04
     32a:	01 97       	sbiw	r24, 0x01	; 1
     32c:	9c 83       	std	Y+4, r25	; 0x04
     32e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
     330:	eb 81       	ldd	r30, Y+3	; 0x03
     332:	fc 81       	ldd	r31, Y+4	; 0x04
     334:	81 e1       	ldi	r24, 0x11	; 17
     336:	80 83       	st	Z, r24
	pxTopOfStack--;
     338:	8b 81       	ldd	r24, Y+3	; 0x03
     33a:	9c 81       	ldd	r25, Y+4	; 0x04
     33c:	01 97       	sbiw	r24, 0x01	; 1
     33e:	9c 83       	std	Y+4, r25	; 0x04
     340:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
     342:	eb 81       	ldd	r30, Y+3	; 0x03
     344:	fc 81       	ldd	r31, Y+4	; 0x04
     346:	82 e1       	ldi	r24, 0x12	; 18
     348:	80 83       	st	Z, r24
	pxTopOfStack--;
     34a:	8b 81       	ldd	r24, Y+3	; 0x03
     34c:	9c 81       	ldd	r25, Y+4	; 0x04
     34e:	01 97       	sbiw	r24, 0x01	; 1
     350:	9c 83       	std	Y+4, r25	; 0x04
     352:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
     354:	eb 81       	ldd	r30, Y+3	; 0x03
     356:	fc 81       	ldd	r31, Y+4	; 0x04
     358:	83 e1       	ldi	r24, 0x13	; 19
     35a:	80 83       	st	Z, r24
	pxTopOfStack--;
     35c:	8b 81       	ldd	r24, Y+3	; 0x03
     35e:	9c 81       	ldd	r25, Y+4	; 0x04
     360:	01 97       	sbiw	r24, 0x01	; 1
     362:	9c 83       	std	Y+4, r25	; 0x04
     364:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
     366:	eb 81       	ldd	r30, Y+3	; 0x03
     368:	fc 81       	ldd	r31, Y+4	; 0x04
     36a:	84 e1       	ldi	r24, 0x14	; 20
     36c:	80 83       	st	Z, r24
	pxTopOfStack--;
     36e:	8b 81       	ldd	r24, Y+3	; 0x03
     370:	9c 81       	ldd	r25, Y+4	; 0x04
     372:	01 97       	sbiw	r24, 0x01	; 1
     374:	9c 83       	std	Y+4, r25	; 0x04
     376:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
     378:	eb 81       	ldd	r30, Y+3	; 0x03
     37a:	fc 81       	ldd	r31, Y+4	; 0x04
     37c:	85 e1       	ldi	r24, 0x15	; 21
     37e:	80 83       	st	Z, r24
	pxTopOfStack--;
     380:	8b 81       	ldd	r24, Y+3	; 0x03
     382:	9c 81       	ldd	r25, Y+4	; 0x04
     384:	01 97       	sbiw	r24, 0x01	; 1
     386:	9c 83       	std	Y+4, r25	; 0x04
     388:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
     38a:	eb 81       	ldd	r30, Y+3	; 0x03
     38c:	fc 81       	ldd	r31, Y+4	; 0x04
     38e:	86 e1       	ldi	r24, 0x16	; 22
     390:	80 83       	st	Z, r24
	pxTopOfStack--;
     392:	8b 81       	ldd	r24, Y+3	; 0x03
     394:	9c 81       	ldd	r25, Y+4	; 0x04
     396:	01 97       	sbiw	r24, 0x01	; 1
     398:	9c 83       	std	Y+4, r25	; 0x04
     39a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
     39c:	eb 81       	ldd	r30, Y+3	; 0x03
     39e:	fc 81       	ldd	r31, Y+4	; 0x04
     3a0:	87 e1       	ldi	r24, 0x17	; 23
     3a2:	80 83       	st	Z, r24
	pxTopOfStack--;
     3a4:	8b 81       	ldd	r24, Y+3	; 0x03
     3a6:	9c 81       	ldd	r25, Y+4	; 0x04
     3a8:	01 97       	sbiw	r24, 0x01	; 1
     3aa:	9c 83       	std	Y+4, r25	; 0x04
     3ac:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
     3ae:	eb 81       	ldd	r30, Y+3	; 0x03
     3b0:	fc 81       	ldd	r31, Y+4	; 0x04
     3b2:	88 e1       	ldi	r24, 0x18	; 24
     3b4:	80 83       	st	Z, r24
	pxTopOfStack--;
     3b6:	8b 81       	ldd	r24, Y+3	; 0x03
     3b8:	9c 81       	ldd	r25, Y+4	; 0x04
     3ba:	01 97       	sbiw	r24, 0x01	; 1
     3bc:	9c 83       	std	Y+4, r25	; 0x04
     3be:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
     3c0:	eb 81       	ldd	r30, Y+3	; 0x03
     3c2:	fc 81       	ldd	r31, Y+4	; 0x04
     3c4:	89 e1       	ldi	r24, 0x19	; 25
     3c6:	80 83       	st	Z, r24
	pxTopOfStack--;
     3c8:	8b 81       	ldd	r24, Y+3	; 0x03
     3ca:	9c 81       	ldd	r25, Y+4	; 0x04
     3cc:	01 97       	sbiw	r24, 0x01	; 1
     3ce:	9c 83       	std	Y+4, r25	; 0x04
     3d0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
     3d2:	eb 81       	ldd	r30, Y+3	; 0x03
     3d4:	fc 81       	ldd	r31, Y+4	; 0x04
     3d6:	80 e2       	ldi	r24, 0x20	; 32
     3d8:	80 83       	st	Z, r24
	pxTopOfStack--;
     3da:	8b 81       	ldd	r24, Y+3	; 0x03
     3dc:	9c 81       	ldd	r25, Y+4	; 0x04
     3de:	01 97       	sbiw	r24, 0x01	; 1
     3e0:	9c 83       	std	Y+4, r25	; 0x04
     3e2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
     3e4:	eb 81       	ldd	r30, Y+3	; 0x03
     3e6:	fc 81       	ldd	r31, Y+4	; 0x04
     3e8:	81 e2       	ldi	r24, 0x21	; 33
     3ea:	80 83       	st	Z, r24
	pxTopOfStack--;
     3ec:	8b 81       	ldd	r24, Y+3	; 0x03
     3ee:	9c 81       	ldd	r25, Y+4	; 0x04
     3f0:	01 97       	sbiw	r24, 0x01	; 1
     3f2:	9c 83       	std	Y+4, r25	; 0x04
     3f4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
     3f6:	eb 81       	ldd	r30, Y+3	; 0x03
     3f8:	fc 81       	ldd	r31, Y+4	; 0x04
     3fa:	82 e2       	ldi	r24, 0x22	; 34
     3fc:	80 83       	st	Z, r24
	pxTopOfStack--;
     3fe:	8b 81       	ldd	r24, Y+3	; 0x03
     400:	9c 81       	ldd	r25, Y+4	; 0x04
     402:	01 97       	sbiw	r24, 0x01	; 1
     404:	9c 83       	std	Y+4, r25	; 0x04
     406:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
     408:	eb 81       	ldd	r30, Y+3	; 0x03
     40a:	fc 81       	ldd	r31, Y+4	; 0x04
     40c:	83 e2       	ldi	r24, 0x23	; 35
     40e:	80 83       	st	Z, r24
	pxTopOfStack--;
     410:	8b 81       	ldd	r24, Y+3	; 0x03
     412:	9c 81       	ldd	r25, Y+4	; 0x04
     414:	01 97       	sbiw	r24, 0x01	; 1
     416:	9c 83       	std	Y+4, r25	; 0x04
     418:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
     41a:	8f 81       	ldd	r24, Y+7	; 0x07
     41c:	98 85       	ldd	r25, Y+8	; 0x08
     41e:	9a 83       	std	Y+2, r25	; 0x02
     420:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     422:	89 81       	ldd	r24, Y+1	; 0x01
     424:	eb 81       	ldd	r30, Y+3	; 0x03
     426:	fc 81       	ldd	r31, Y+4	; 0x04
     428:	80 83       	st	Z, r24
	pxTopOfStack--;
     42a:	8b 81       	ldd	r24, Y+3	; 0x03
     42c:	9c 81       	ldd	r25, Y+4	; 0x04
     42e:	01 97       	sbiw	r24, 0x01	; 1
     430:	9c 83       	std	Y+4, r25	; 0x04
     432:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
     434:	89 81       	ldd	r24, Y+1	; 0x01
     436:	9a 81       	ldd	r25, Y+2	; 0x02
     438:	89 2f       	mov	r24, r25
     43a:	99 27       	eor	r25, r25
     43c:	9a 83       	std	Y+2, r25	; 0x02
     43e:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     440:	89 81       	ldd	r24, Y+1	; 0x01
     442:	eb 81       	ldd	r30, Y+3	; 0x03
     444:	fc 81       	ldd	r31, Y+4	; 0x04
     446:	80 83       	st	Z, r24
	pxTopOfStack--;
     448:	8b 81       	ldd	r24, Y+3	; 0x03
     44a:	9c 81       	ldd	r25, Y+4	; 0x04
     44c:	01 97       	sbiw	r24, 0x01	; 1
     44e:	9c 83       	std	Y+4, r25	; 0x04
     450:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
     452:	eb 81       	ldd	r30, Y+3	; 0x03
     454:	fc 81       	ldd	r31, Y+4	; 0x04
     456:	86 e2       	ldi	r24, 0x26	; 38
     458:	80 83       	st	Z, r24
	pxTopOfStack--;
     45a:	8b 81       	ldd	r24, Y+3	; 0x03
     45c:	9c 81       	ldd	r25, Y+4	; 0x04
     45e:	01 97       	sbiw	r24, 0x01	; 1
     460:	9c 83       	std	Y+4, r25	; 0x04
     462:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
     464:	eb 81       	ldd	r30, Y+3	; 0x03
     466:	fc 81       	ldd	r31, Y+4	; 0x04
     468:	87 e2       	ldi	r24, 0x27	; 39
     46a:	80 83       	st	Z, r24
	pxTopOfStack--;
     46c:	8b 81       	ldd	r24, Y+3	; 0x03
     46e:	9c 81       	ldd	r25, Y+4	; 0x04
     470:	01 97       	sbiw	r24, 0x01	; 1
     472:	9c 83       	std	Y+4, r25	; 0x04
     474:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
     476:	eb 81       	ldd	r30, Y+3	; 0x03
     478:	fc 81       	ldd	r31, Y+4	; 0x04
     47a:	88 e2       	ldi	r24, 0x28	; 40
     47c:	80 83       	st	Z, r24
	pxTopOfStack--;
     47e:	8b 81       	ldd	r24, Y+3	; 0x03
     480:	9c 81       	ldd	r25, Y+4	; 0x04
     482:	01 97       	sbiw	r24, 0x01	; 1
     484:	9c 83       	std	Y+4, r25	; 0x04
     486:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
     488:	eb 81       	ldd	r30, Y+3	; 0x03
     48a:	fc 81       	ldd	r31, Y+4	; 0x04
     48c:	89 e2       	ldi	r24, 0x29	; 41
     48e:	80 83       	st	Z, r24
	pxTopOfStack--;
     490:	8b 81       	ldd	r24, Y+3	; 0x03
     492:	9c 81       	ldd	r25, Y+4	; 0x04
     494:	01 97       	sbiw	r24, 0x01	; 1
     496:	9c 83       	std	Y+4, r25	; 0x04
     498:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
     49a:	eb 81       	ldd	r30, Y+3	; 0x03
     49c:	fc 81       	ldd	r31, Y+4	; 0x04
     49e:	80 e3       	ldi	r24, 0x30	; 48
     4a0:	80 83       	st	Z, r24
	pxTopOfStack--;
     4a2:	8b 81       	ldd	r24, Y+3	; 0x03
     4a4:	9c 81       	ldd	r25, Y+4	; 0x04
     4a6:	01 97       	sbiw	r24, 0x01	; 1
     4a8:	9c 83       	std	Y+4, r25	; 0x04
     4aa:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
     4ac:	eb 81       	ldd	r30, Y+3	; 0x03
     4ae:	fc 81       	ldd	r31, Y+4	; 0x04
     4b0:	81 e3       	ldi	r24, 0x31	; 49
     4b2:	80 83       	st	Z, r24
	pxTopOfStack--;
     4b4:	8b 81       	ldd	r24, Y+3	; 0x03
     4b6:	9c 81       	ldd	r25, Y+4	; 0x04
     4b8:	01 97       	sbiw	r24, 0x01	; 1
     4ba:	9c 83       	std	Y+4, r25	; 0x04
     4bc:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
     4be:	8b 81       	ldd	r24, Y+3	; 0x03
     4c0:	9c 81       	ldd	r25, Y+4	; 0x04
}
     4c2:	28 96       	adiw	r28, 0x08	; 8
     4c4:	0f b6       	in	r0, 0x3f	; 63
     4c6:	f8 94       	cli
     4c8:	de bf       	out	0x3e, r29	; 62
     4ca:	0f be       	out	0x3f, r0	; 63
     4cc:	cd bf       	out	0x3d, r28	; 61
     4ce:	cf 91       	pop	r28
     4d0:	df 91       	pop	r29
     4d2:	08 95       	ret

000004d4 <xPortStartScheduler>:
/*-----------------------------------------------------------*/

BaseType_t xPortStartScheduler( void )
{
     4d4:	df 93       	push	r29
     4d6:	cf 93       	push	r28
     4d8:	cd b7       	in	r28, 0x3d	; 61
     4da:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
     4dc:	0e 94 5c 03 	call	0x6b8	; 0x6b8 <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
     4e0:	a0 91 2e 07 	lds	r26, 0x072E
     4e4:	b0 91 2f 07 	lds	r27, 0x072F
     4e8:	cd 91       	ld	r28, X+
     4ea:	cd bf       	out	0x3d, r28	; 61
     4ec:	dd 91       	ld	r29, X+
     4ee:	de bf       	out	0x3e, r29	; 62
     4f0:	ff 91       	pop	r31
     4f2:	ef 91       	pop	r30
     4f4:	df 91       	pop	r29
     4f6:	cf 91       	pop	r28
     4f8:	bf 91       	pop	r27
     4fa:	af 91       	pop	r26
     4fc:	9f 91       	pop	r25
     4fe:	8f 91       	pop	r24
     500:	7f 91       	pop	r23
     502:	6f 91       	pop	r22
     504:	5f 91       	pop	r21
     506:	4f 91       	pop	r20
     508:	3f 91       	pop	r19
     50a:	2f 91       	pop	r18
     50c:	1f 91       	pop	r17
     50e:	0f 91       	pop	r16
     510:	ff 90       	pop	r15
     512:	ef 90       	pop	r14
     514:	df 90       	pop	r13
     516:	cf 90       	pop	r12
     518:	bf 90       	pop	r11
     51a:	af 90       	pop	r10
     51c:	9f 90       	pop	r9
     51e:	8f 90       	pop	r8
     520:	7f 90       	pop	r7
     522:	6f 90       	pop	r6
     524:	5f 90       	pop	r5
     526:	4f 90       	pop	r4
     528:	3f 90       	pop	r3
     52a:	2f 90       	pop	r2
     52c:	1f 90       	pop	r1
     52e:	0f 90       	pop	r0
     530:	0f be       	out	0x3f, r0	; 63
     532:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
     534:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
     536:	81 e0       	ldi	r24, 0x01	; 1
}
     538:	cf 91       	pop	r28
     53a:	df 91       	pop	r29
     53c:	08 95       	ret

0000053e <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     53e:	df 93       	push	r29
     540:	cf 93       	push	r28
     542:	cd b7       	in	r28, 0x3d	; 61
     544:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
     546:	cf 91       	pop	r28
     548:	df 91       	pop	r29
     54a:	08 95       	ret

0000054c <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     54c:	0f 92       	push	r0
     54e:	0f b6       	in	r0, 0x3f	; 63
     550:	f8 94       	cli
     552:	0f 92       	push	r0
     554:	1f 92       	push	r1
     556:	11 24       	eor	r1, r1
     558:	2f 92       	push	r2
     55a:	3f 92       	push	r3
     55c:	4f 92       	push	r4
     55e:	5f 92       	push	r5
     560:	6f 92       	push	r6
     562:	7f 92       	push	r7
     564:	8f 92       	push	r8
     566:	9f 92       	push	r9
     568:	af 92       	push	r10
     56a:	bf 92       	push	r11
     56c:	cf 92       	push	r12
     56e:	df 92       	push	r13
     570:	ef 92       	push	r14
     572:	ff 92       	push	r15
     574:	0f 93       	push	r16
     576:	1f 93       	push	r17
     578:	2f 93       	push	r18
     57a:	3f 93       	push	r19
     57c:	4f 93       	push	r20
     57e:	5f 93       	push	r21
     580:	6f 93       	push	r22
     582:	7f 93       	push	r23
     584:	8f 93       	push	r24
     586:	9f 93       	push	r25
     588:	af 93       	push	r26
     58a:	bf 93       	push	r27
     58c:	cf 93       	push	r28
     58e:	df 93       	push	r29
     590:	ef 93       	push	r30
     592:	ff 93       	push	r31
     594:	a0 91 2e 07 	lds	r26, 0x072E
     598:	b0 91 2f 07 	lds	r27, 0x072F
     59c:	0d b6       	in	r0, 0x3d	; 61
     59e:	0d 92       	st	X+, r0
     5a0:	0e b6       	in	r0, 0x3e	; 62
     5a2:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     5a4:	0e 94 e3 1a 	call	0x35c6	; 0x35c6 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     5a8:	a0 91 2e 07 	lds	r26, 0x072E
     5ac:	b0 91 2f 07 	lds	r27, 0x072F
     5b0:	cd 91       	ld	r28, X+
     5b2:	cd bf       	out	0x3d, r28	; 61
     5b4:	dd 91       	ld	r29, X+
     5b6:	de bf       	out	0x3e, r29	; 62
     5b8:	ff 91       	pop	r31
     5ba:	ef 91       	pop	r30
     5bc:	df 91       	pop	r29
     5be:	cf 91       	pop	r28
     5c0:	bf 91       	pop	r27
     5c2:	af 91       	pop	r26
     5c4:	9f 91       	pop	r25
     5c6:	8f 91       	pop	r24
     5c8:	7f 91       	pop	r23
     5ca:	6f 91       	pop	r22
     5cc:	5f 91       	pop	r21
     5ce:	4f 91       	pop	r20
     5d0:	3f 91       	pop	r19
     5d2:	2f 91       	pop	r18
     5d4:	1f 91       	pop	r17
     5d6:	0f 91       	pop	r16
     5d8:	ff 90       	pop	r15
     5da:	ef 90       	pop	r14
     5dc:	df 90       	pop	r13
     5de:	cf 90       	pop	r12
     5e0:	bf 90       	pop	r11
     5e2:	af 90       	pop	r10
     5e4:	9f 90       	pop	r9
     5e6:	8f 90       	pop	r8
     5e8:	7f 90       	pop	r7
     5ea:	6f 90       	pop	r6
     5ec:	5f 90       	pop	r5
     5ee:	4f 90       	pop	r4
     5f0:	3f 90       	pop	r3
     5f2:	2f 90       	pop	r2
     5f4:	1f 90       	pop	r1
     5f6:	0f 90       	pop	r0
     5f8:	0f be       	out	0x3f, r0	; 63
     5fa:	0f 90       	pop	r0

	asm volatile ( "ret" );
     5fc:	08 95       	ret

000005fe <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     5fe:	0f 92       	push	r0
     600:	0f b6       	in	r0, 0x3f	; 63
     602:	f8 94       	cli
     604:	0f 92       	push	r0
     606:	1f 92       	push	r1
     608:	11 24       	eor	r1, r1
     60a:	2f 92       	push	r2
     60c:	3f 92       	push	r3
     60e:	4f 92       	push	r4
     610:	5f 92       	push	r5
     612:	6f 92       	push	r6
     614:	7f 92       	push	r7
     616:	8f 92       	push	r8
     618:	9f 92       	push	r9
     61a:	af 92       	push	r10
     61c:	bf 92       	push	r11
     61e:	cf 92       	push	r12
     620:	df 92       	push	r13
     622:	ef 92       	push	r14
     624:	ff 92       	push	r15
     626:	0f 93       	push	r16
     628:	1f 93       	push	r17
     62a:	2f 93       	push	r18
     62c:	3f 93       	push	r19
     62e:	4f 93       	push	r20
     630:	5f 93       	push	r21
     632:	6f 93       	push	r22
     634:	7f 93       	push	r23
     636:	8f 93       	push	r24
     638:	9f 93       	push	r25
     63a:	af 93       	push	r26
     63c:	bf 93       	push	r27
     63e:	cf 93       	push	r28
     640:	df 93       	push	r29
     642:	ef 93       	push	r30
     644:	ff 93       	push	r31
     646:	a0 91 2e 07 	lds	r26, 0x072E
     64a:	b0 91 2f 07 	lds	r27, 0x072F
     64e:	0d b6       	in	r0, 0x3d	; 61
     650:	0d 92       	st	X+, r0
     652:	0e b6       	in	r0, 0x3e	; 62
     654:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     656:	0e 94 4c 19 	call	0x3298	; 0x3298 <xTaskIncrementTick>
     65a:	88 23       	and	r24, r24
     65c:	11 f0       	breq	.+4      	; 0x662 <vPortYieldFromTick+0x64>
	{
		vTaskSwitchContext();
     65e:	0e 94 e3 1a 	call	0x35c6	; 0x35c6 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     662:	a0 91 2e 07 	lds	r26, 0x072E
     666:	b0 91 2f 07 	lds	r27, 0x072F
     66a:	cd 91       	ld	r28, X+
     66c:	cd bf       	out	0x3d, r28	; 61
     66e:	dd 91       	ld	r29, X+
     670:	de bf       	out	0x3e, r29	; 62
     672:	ff 91       	pop	r31
     674:	ef 91       	pop	r30
     676:	df 91       	pop	r29
     678:	cf 91       	pop	r28
     67a:	bf 91       	pop	r27
     67c:	af 91       	pop	r26
     67e:	9f 91       	pop	r25
     680:	8f 91       	pop	r24
     682:	7f 91       	pop	r23
     684:	6f 91       	pop	r22
     686:	5f 91       	pop	r21
     688:	4f 91       	pop	r20
     68a:	3f 91       	pop	r19
     68c:	2f 91       	pop	r18
     68e:	1f 91       	pop	r17
     690:	0f 91       	pop	r16
     692:	ff 90       	pop	r15
     694:	ef 90       	pop	r14
     696:	df 90       	pop	r13
     698:	cf 90       	pop	r12
     69a:	bf 90       	pop	r11
     69c:	af 90       	pop	r10
     69e:	9f 90       	pop	r9
     6a0:	8f 90       	pop	r8
     6a2:	7f 90       	pop	r7
     6a4:	6f 90       	pop	r6
     6a6:	5f 90       	pop	r5
     6a8:	4f 90       	pop	r4
     6aa:	3f 90       	pop	r3
     6ac:	2f 90       	pop	r2
     6ae:	1f 90       	pop	r1
     6b0:	0f 90       	pop	r0
     6b2:	0f be       	out	0x3f, r0	; 63
     6b4:	0f 90       	pop	r0

	asm volatile ( "ret" );
     6b6:	08 95       	ret

000006b8 <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
     6b8:	df 93       	push	r29
     6ba:	cf 93       	push	r28
     6bc:	00 d0       	rcall	.+0      	; 0x6be <prvSetupTimerInterrupt+0x6>
     6be:	00 d0       	rcall	.+0      	; 0x6c0 <prvSetupTimerInterrupt+0x8>
     6c0:	00 d0       	rcall	.+0      	; 0x6c2 <prvSetupTimerInterrupt+0xa>
     6c2:	cd b7       	in	r28, 0x3d	; 61
     6c4:	de b7       	in	r29, 0x3e	; 62
uint8_t ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
     6c6:	80 e4       	ldi	r24, 0x40	; 64
     6c8:	9f e1       	ldi	r25, 0x1F	; 31
     6ca:	a0 e0       	ldi	r26, 0x00	; 0
     6cc:	b0 e0       	ldi	r27, 0x00	; 0
     6ce:	8b 83       	std	Y+3, r24	; 0x03
     6d0:	9c 83       	std	Y+4, r25	; 0x04
     6d2:	ad 83       	std	Y+5, r26	; 0x05
     6d4:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
     6d6:	8b 81       	ldd	r24, Y+3	; 0x03
     6d8:	9c 81       	ldd	r25, Y+4	; 0x04
     6da:	ad 81       	ldd	r26, Y+5	; 0x05
     6dc:	be 81       	ldd	r27, Y+6	; 0x06
     6de:	68 94       	set
     6e0:	15 f8       	bld	r1, 5
     6e2:	b6 95       	lsr	r27
     6e4:	a7 95       	ror	r26
     6e6:	97 95       	ror	r25
     6e8:	87 95       	ror	r24
     6ea:	16 94       	lsr	r1
     6ec:	d1 f7       	brne	.-12     	; 0x6e2 <prvSetupTimerInterrupt+0x2a>
     6ee:	8b 83       	std	Y+3, r24	; 0x03
     6f0:	9c 83       	std	Y+4, r25	; 0x04
     6f2:	ad 83       	std	Y+5, r26	; 0x05
     6f4:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( uint32_t ) 1;
     6f6:	8b 81       	ldd	r24, Y+3	; 0x03
     6f8:	9c 81       	ldd	r25, Y+4	; 0x04
     6fa:	ad 81       	ldd	r26, Y+5	; 0x05
     6fc:	be 81       	ldd	r27, Y+6	; 0x06
     6fe:	01 97       	sbiw	r24, 0x01	; 1
     700:	a1 09       	sbc	r26, r1
     702:	b1 09       	sbc	r27, r1
     704:	8b 83       	std	Y+3, r24	; 0x03
     706:	9c 83       	std	Y+4, r25	; 0x04
     708:	ad 83       	std	Y+5, r26	; 0x05
     70a:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
     70c:	8b 81       	ldd	r24, Y+3	; 0x03
     70e:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
     710:	8b 81       	ldd	r24, Y+3	; 0x03
     712:	9c 81       	ldd	r25, Y+4	; 0x04
     714:	ad 81       	ldd	r26, Y+5	; 0x05
     716:	be 81       	ldd	r27, Y+6	; 0x06
     718:	89 2f       	mov	r24, r25
     71a:	9a 2f       	mov	r25, r26
     71c:	ab 2f       	mov	r26, r27
     71e:	bb 27       	eor	r27, r27
     720:	8b 83       	std	Y+3, r24	; 0x03
     722:	9c 83       	std	Y+4, r25	; 0x04
     724:	ad 83       	std	Y+5, r26	; 0x05
     726:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
     728:	8b 81       	ldd	r24, Y+3	; 0x03
     72a:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
     72c:	eb e4       	ldi	r30, 0x4B	; 75
     72e:	f0 e0       	ldi	r31, 0x00	; 0
     730:	8a 81       	ldd	r24, Y+2	; 0x02
     732:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
     734:	ea e4       	ldi	r30, 0x4A	; 74
     736:	f0 e0       	ldi	r31, 0x00	; 0
     738:	89 81       	ldd	r24, Y+1	; 0x01
     73a:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
     73c:	8b e0       	ldi	r24, 0x0B	; 11
     73e:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
     740:	ee e4       	ldi	r30, 0x4E	; 78
     742:	f0 e0       	ldi	r31, 0x00	; 0
     744:	89 81       	ldd	r24, Y+1	; 0x01
     746:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
     748:	e7 e5       	ldi	r30, 0x57	; 87
     74a:	f0 e0       	ldi	r31, 0x00	; 0
     74c:	80 81       	ld	r24, Z
     74e:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
     750:	89 81       	ldd	r24, Y+1	; 0x01
     752:	80 61       	ori	r24, 0x10	; 16
     754:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
     756:	e7 e5       	ldi	r30, 0x57	; 87
     758:	f0 e0       	ldi	r31, 0x00	; 0
     75a:	89 81       	ldd	r24, Y+1	; 0x01
     75c:	80 83       	st	Z, r24
}
     75e:	26 96       	adiw	r28, 0x06	; 6
     760:	0f b6       	in	r0, 0x3f	; 63
     762:	f8 94       	cli
     764:	de bf       	out	0x3e, r29	; 62
     766:	0f be       	out	0x3f, r0	; 63
     768:	cd bf       	out	0x3d, r28	; 61
     76a:	cf 91       	pop	r28
     76c:	df 91       	pop	r29
     76e:	08 95       	ret

00000770 <__vector_12>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
     770:	0e 94 ff 02 	call	0x5fe	; 0x5fe <vPortYieldFromTick>
		asm volatile ( "reti" );
     774:	18 95       	reti

00000776 <xCoRoutineCreate>:
/*-----------------------------------------------------------*/

    BaseType_t xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode,
                                 UBaseType_t uxPriority,
                                 UBaseType_t uxIndex )
    {
     776:	df 93       	push	r29
     778:	cf 93       	push	r28
     77a:	cd b7       	in	r28, 0x3d	; 61
     77c:	de b7       	in	r29, 0x3e	; 62
     77e:	27 97       	sbiw	r28, 0x07	; 7
     780:	0f b6       	in	r0, 0x3f	; 63
     782:	f8 94       	cli
     784:	de bf       	out	0x3e, r29	; 62
     786:	0f be       	out	0x3f, r0	; 63
     788:	cd bf       	out	0x3d, r28	; 61
     78a:	9d 83       	std	Y+5, r25	; 0x05
     78c:	8c 83       	std	Y+4, r24	; 0x04
     78e:	6e 83       	std	Y+6, r22	; 0x06
     790:	4f 83       	std	Y+7, r20	; 0x07
        BaseType_t xReturn;
        CRCB_t * pxCoRoutine;

        /* Allocate the memory that will store the co-routine control block. */
        pxCoRoutine = ( CRCB_t * ) pvPortMalloc( sizeof( CRCB_t ) );
     792:	8a e1       	ldi	r24, 0x1A	; 26
     794:	90 e0       	ldi	r25, 0x00	; 0
     796:	0e 94 67 00 	call	0xce	; 0xce <pvPortMalloc>
     79a:	9a 83       	std	Y+2, r25	; 0x02
     79c:	89 83       	std	Y+1, r24	; 0x01

        if( pxCoRoutine )
     79e:	89 81       	ldd	r24, Y+1	; 0x01
     7a0:	9a 81       	ldd	r25, Y+2	; 0x02
     7a2:	00 97       	sbiw	r24, 0x00	; 0
     7a4:	09 f4       	brne	.+2      	; 0x7a8 <xCoRoutineCreate+0x32>
     7a6:	6f c0       	rjmp	.+222    	; 0x886 <xCoRoutineCreate+0x110>
        {
            /* If pxCurrentCoRoutine is NULL then this is the first co-routine to
            * be created and the co-routine data structures need initialising. */
            if( pxCurrentCoRoutine == NULL )
     7a8:	80 91 f8 06 	lds	r24, 0x06F8
     7ac:	90 91 f9 06 	lds	r25, 0x06F9
     7b0:	00 97       	sbiw	r24, 0x00	; 0
     7b2:	41 f4       	brne	.+16     	; 0x7c4 <xCoRoutineCreate+0x4e>
            {
                pxCurrentCoRoutine = pxCoRoutine;
     7b4:	89 81       	ldd	r24, Y+1	; 0x01
     7b6:	9a 81       	ldd	r25, Y+2	; 0x02
     7b8:	90 93 f9 06 	sts	0x06F9, r25
     7bc:	80 93 f8 06 	sts	0x06F8, r24
                prvInitialiseCoRoutineLists();
     7c0:	0e 94 29 06 	call	0xc52	; 0xc52 <prvInitialiseCoRoutineLists>
            }

            /* Check the priority is within limits. */
            if( uxPriority >= configMAX_CO_ROUTINE_PRIORITIES )
     7c4:	8e 81       	ldd	r24, Y+6	; 0x06
     7c6:	82 30       	cpi	r24, 0x02	; 2
     7c8:	10 f0       	brcs	.+4      	; 0x7ce <xCoRoutineCreate+0x58>
            {
                uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
     7ca:	81 e0       	ldi	r24, 0x01	; 1
     7cc:	8e 83       	std	Y+6, r24	; 0x06
            }

            /* Fill out the co-routine control block from the function parameters. */
            pxCoRoutine->uxState = corINITIAL_STATE;
     7ce:	e9 81       	ldd	r30, Y+1	; 0x01
     7d0:	fa 81       	ldd	r31, Y+2	; 0x02
     7d2:	11 8e       	std	Z+25, r1	; 0x19
     7d4:	10 8e       	std	Z+24, r1	; 0x18
            pxCoRoutine->uxPriority = uxPriority;
     7d6:	e9 81       	ldd	r30, Y+1	; 0x01
     7d8:	fa 81       	ldd	r31, Y+2	; 0x02
     7da:	8e 81       	ldd	r24, Y+6	; 0x06
     7dc:	86 8b       	std	Z+22, r24	; 0x16
            pxCoRoutine->uxIndex = uxIndex;
     7de:	e9 81       	ldd	r30, Y+1	; 0x01
     7e0:	fa 81       	ldd	r31, Y+2	; 0x02
     7e2:	8f 81       	ldd	r24, Y+7	; 0x07
     7e4:	87 8b       	std	Z+23, r24	; 0x17
            pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
     7e6:	e9 81       	ldd	r30, Y+1	; 0x01
     7e8:	fa 81       	ldd	r31, Y+2	; 0x02
     7ea:	8c 81       	ldd	r24, Y+4	; 0x04
     7ec:	9d 81       	ldd	r25, Y+5	; 0x05
     7ee:	91 83       	std	Z+1, r25	; 0x01
     7f0:	80 83       	st	Z, r24

            /* Initialise all the other co-routine control block parameters. */
            vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
     7f2:	89 81       	ldd	r24, Y+1	; 0x01
     7f4:	9a 81       	ldd	r25, Y+2	; 0x02
     7f6:	02 96       	adiw	r24, 0x02	; 2
     7f8:	0e 94 09 0a 	call	0x1412	; 0x1412 <vListInitialiseItem>
            vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
     7fc:	89 81       	ldd	r24, Y+1	; 0x01
     7fe:	9a 81       	ldd	r25, Y+2	; 0x02
     800:	0c 96       	adiw	r24, 0x0c	; 12
     802:	0e 94 09 0a 	call	0x1412	; 0x1412 <vListInitialiseItem>

            /* Set the co-routine control block as a link back from the ListItem_t.
             * This is so we can get back to the containing CRCB from a generic item
             * in a list. */
            listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
     806:	e9 81       	ldd	r30, Y+1	; 0x01
     808:	fa 81       	ldd	r31, Y+2	; 0x02
     80a:	89 81       	ldd	r24, Y+1	; 0x01
     80c:	9a 81       	ldd	r25, Y+2	; 0x02
     80e:	91 87       	std	Z+9, r25	; 0x09
     810:	80 87       	std	Z+8, r24	; 0x08
            listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
     812:	e9 81       	ldd	r30, Y+1	; 0x01
     814:	fa 81       	ldd	r31, Y+2	; 0x02
     816:	89 81       	ldd	r24, Y+1	; 0x01
     818:	9a 81       	ldd	r25, Y+2	; 0x02
     81a:	93 8b       	std	Z+19, r25	; 0x13
     81c:	82 8b       	std	Z+18, r24	; 0x12

            /* Event lists are always in priority order. */
            listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), ( ( TickType_t ) configMAX_CO_ROUTINE_PRIORITIES - ( TickType_t ) uxPriority ) );
     81e:	8e 81       	ldd	r24, Y+6	; 0x06
     820:	28 2f       	mov	r18, r24
     822:	30 e0       	ldi	r19, 0x00	; 0
     824:	82 e0       	ldi	r24, 0x02	; 2
     826:	90 e0       	ldi	r25, 0x00	; 0
     828:	82 1b       	sub	r24, r18
     82a:	93 0b       	sbc	r25, r19
     82c:	e9 81       	ldd	r30, Y+1	; 0x01
     82e:	fa 81       	ldd	r31, Y+2	; 0x02
     830:	95 87       	std	Z+13, r25	; 0x0d
     832:	84 87       	std	Z+12, r24	; 0x0c

            /* Now the co-routine has been initialised it can be added to the ready
             * list at the correct priority. */
            prvAddCoRoutineToReadyQueue( pxCoRoutine );
     834:	e9 81       	ldd	r30, Y+1	; 0x01
     836:	fa 81       	ldd	r31, Y+2	; 0x02
     838:	96 89       	ldd	r25, Z+22	; 0x16
     83a:	80 91 fa 06 	lds	r24, 0x06FA
     83e:	89 17       	cp	r24, r25
     840:	28 f4       	brcc	.+10     	; 0x84c <xCoRoutineCreate+0xd6>
     842:	e9 81       	ldd	r30, Y+1	; 0x01
     844:	fa 81       	ldd	r31, Y+2	; 0x02
     846:	86 89       	ldd	r24, Z+22	; 0x16
     848:	80 93 fa 06 	sts	0x06FA, r24
     84c:	e9 81       	ldd	r30, Y+1	; 0x01
     84e:	fa 81       	ldd	r31, Y+2	; 0x02
     850:	86 89       	ldd	r24, Z+22	; 0x16
     852:	28 2f       	mov	r18, r24
     854:	30 e0       	ldi	r19, 0x00	; 0
     856:	c9 01       	movw	r24, r18
     858:	88 0f       	add	r24, r24
     85a:	99 1f       	adc	r25, r25
     85c:	88 0f       	add	r24, r24
     85e:	99 1f       	adc	r25, r25
     860:	88 0f       	add	r24, r24
     862:	99 1f       	adc	r25, r25
     864:	82 0f       	add	r24, r18
     866:	93 1f       	adc	r25, r19
     868:	ac 01       	movw	r20, r24
     86a:	4f 5f       	subi	r20, 0xFF	; 255
     86c:	58 4f       	sbci	r21, 0xF8	; 248
     86e:	89 81       	ldd	r24, Y+1	; 0x01
     870:	9a 81       	ldd	r25, Y+2	; 0x02
     872:	9c 01       	movw	r18, r24
     874:	2e 5f       	subi	r18, 0xFE	; 254
     876:	3f 4f       	sbci	r19, 0xFF	; 255
     878:	ca 01       	movw	r24, r20
     87a:	b9 01       	movw	r22, r18
     87c:	0e 94 19 0a 	call	0x1432	; 0x1432 <vListInsertEnd>

            xReturn = pdPASS;
     880:	81 e0       	ldi	r24, 0x01	; 1
     882:	8b 83       	std	Y+3, r24	; 0x03
     884:	02 c0       	rjmp	.+4      	; 0x88a <xCoRoutineCreate+0x114>
        }
        else
        {
            xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     886:	8f ef       	ldi	r24, 0xFF	; 255
     888:	8b 83       	std	Y+3, r24	; 0x03
        }

        return xReturn;
     88a:	8b 81       	ldd	r24, Y+3	; 0x03
    }
     88c:	27 96       	adiw	r28, 0x07	; 7
     88e:	0f b6       	in	r0, 0x3f	; 63
     890:	f8 94       	cli
     892:	de bf       	out	0x3e, r29	; 62
     894:	0f be       	out	0x3f, r0	; 63
     896:	cd bf       	out	0x3d, r28	; 61
     898:	cf 91       	pop	r28
     89a:	df 91       	pop	r29
     89c:	08 95       	ret

0000089e <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

    void vCoRoutineAddToDelayedList( TickType_t xTicksToDelay,
                                     List_t * pxEventList )
    {
     89e:	df 93       	push	r29
     8a0:	cf 93       	push	r28
     8a2:	00 d0       	rcall	.+0      	; 0x8a4 <vCoRoutineAddToDelayedList+0x6>
     8a4:	00 d0       	rcall	.+0      	; 0x8a6 <vCoRoutineAddToDelayedList+0x8>
     8a6:	00 d0       	rcall	.+0      	; 0x8a8 <vCoRoutineAddToDelayedList+0xa>
     8a8:	cd b7       	in	r28, 0x3d	; 61
     8aa:	de b7       	in	r29, 0x3e	; 62
     8ac:	9c 83       	std	Y+4, r25	; 0x04
     8ae:	8b 83       	std	Y+3, r24	; 0x03
     8b0:	7e 83       	std	Y+6, r23	; 0x06
     8b2:	6d 83       	std	Y+5, r22	; 0x05
        TickType_t xTimeToWake;

        /* Calculate the time to wake - this may overflow but this is
         * not a problem. */
        xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
     8b4:	20 91 fb 06 	lds	r18, 0x06FB
     8b8:	30 91 fc 06 	lds	r19, 0x06FC
     8bc:	8b 81       	ldd	r24, Y+3	; 0x03
     8be:	9c 81       	ldd	r25, Y+4	; 0x04
     8c0:	82 0f       	add	r24, r18
     8c2:	93 1f       	adc	r25, r19
     8c4:	9a 83       	std	Y+2, r25	; 0x02
     8c6:	89 83       	std	Y+1, r24	; 0x01

        /* We must remove ourselves from the ready list before adding
         * ourselves to the blocked list as the same list item is used for
         * both lists. */
        ( void ) uxListRemove( ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     8c8:	80 91 f8 06 	lds	r24, 0x06F8
     8cc:	90 91 f9 06 	lds	r25, 0x06F9
     8d0:	02 96       	adiw	r24, 0x02	; 2
     8d2:	0e 94 c9 0a 	call	0x1592	; 0x1592 <uxListRemove>

        /* The list item will be inserted in wake time order. */
        listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
     8d6:	e0 91 f8 06 	lds	r30, 0x06F8
     8da:	f0 91 f9 06 	lds	r31, 0x06F9
     8de:	89 81       	ldd	r24, Y+1	; 0x01
     8e0:	9a 81       	ldd	r25, Y+2	; 0x02
     8e2:	93 83       	std	Z+3, r25	; 0x03
     8e4:	82 83       	std	Z+2, r24	; 0x02

        if( xTimeToWake < xCoRoutineTickCount )
     8e6:	20 91 fb 06 	lds	r18, 0x06FB
     8ea:	30 91 fc 06 	lds	r19, 0x06FC
     8ee:	89 81       	ldd	r24, Y+1	; 0x01
     8f0:	9a 81       	ldd	r25, Y+2	; 0x02
     8f2:	82 17       	cp	r24, r18
     8f4:	93 07       	cpc	r25, r19
     8f6:	70 f4       	brcc	.+28     	; 0x914 <vCoRoutineAddToDelayedList+0x76>
        {
            /* Wake time has overflowed.  Place this item in the
             * overflow list. */
            vListInsert( ( List_t * ) pxOverflowDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     8f8:	80 91 f6 06 	lds	r24, 0x06F6
     8fc:	90 91 f7 06 	lds	r25, 0x06F7
     900:	20 91 f8 06 	lds	r18, 0x06F8
     904:	30 91 f9 06 	lds	r19, 0x06F9
     908:	2e 5f       	subi	r18, 0xFE	; 254
     90a:	3f 4f       	sbci	r19, 0xFF	; 255
     90c:	b9 01       	movw	r22, r18
     90e:	0e 94 5d 0a 	call	0x14ba	; 0x14ba <vListInsert>
     912:	0d c0       	rjmp	.+26     	; 0x92e <vCoRoutineAddToDelayedList+0x90>
        }
        else
        {
            /* The wake time has not overflowed, so we can use the
             * current block list. */
            vListInsert( ( List_t * ) pxDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     914:	80 91 f4 06 	lds	r24, 0x06F4
     918:	90 91 f5 06 	lds	r25, 0x06F5
     91c:	20 91 f8 06 	lds	r18, 0x06F8
     920:	30 91 f9 06 	lds	r19, 0x06F9
     924:	2e 5f       	subi	r18, 0xFE	; 254
     926:	3f 4f       	sbci	r19, 0xFF	; 255
     928:	b9 01       	movw	r22, r18
     92a:	0e 94 5d 0a 	call	0x14ba	; 0x14ba <vListInsert>
        }

        if( pxEventList )
     92e:	8d 81       	ldd	r24, Y+5	; 0x05
     930:	9e 81       	ldd	r25, Y+6	; 0x06
     932:	00 97       	sbiw	r24, 0x00	; 0
     934:	61 f0       	breq	.+24     	; 0x94e <vCoRoutineAddToDelayedList+0xb0>
        {
            /* Also add the co-routine to an event list.  If this is done then the
             * function must be called with interrupts disabled. */
            vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
     936:	80 91 f8 06 	lds	r24, 0x06F8
     93a:	90 91 f9 06 	lds	r25, 0x06F9
     93e:	9c 01       	movw	r18, r24
     940:	24 5f       	subi	r18, 0xF4	; 244
     942:	3f 4f       	sbci	r19, 0xFF	; 255
     944:	8d 81       	ldd	r24, Y+5	; 0x05
     946:	9e 81       	ldd	r25, Y+6	; 0x06
     948:	b9 01       	movw	r22, r18
     94a:	0e 94 5d 0a 	call	0x14ba	; 0x14ba <vListInsert>
        }
    }
     94e:	26 96       	adiw	r28, 0x06	; 6
     950:	0f b6       	in	r0, 0x3f	; 63
     952:	f8 94       	cli
     954:	de bf       	out	0x3e, r29	; 62
     956:	0f be       	out	0x3f, r0	; 63
     958:	cd bf       	out	0x3d, r28	; 61
     95a:	cf 91       	pop	r28
     95c:	df 91       	pop	r29
     95e:	08 95       	ret

00000960 <prvCheckPendingReadyList>:
/*-----------------------------------------------------------*/

    static void prvCheckPendingReadyList( void )
    {
     960:	df 93       	push	r29
     962:	cf 93       	push	r28
     964:	00 d0       	rcall	.+0      	; 0x966 <prvCheckPendingReadyList+0x6>
     966:	cd b7       	in	r28, 0x3d	; 61
     968:	de b7       	in	r29, 0x3e	; 62
     96a:	3a c0       	rjmp	.+116    	; 0x9e0 <prvCheckPendingReadyList+0x80>
        while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
        {
            CRCB_t * pxUnblockedCRCB;

            /* The pending ready list can be accessed by an ISR. */
            portDISABLE_INTERRUPTS();
     96c:	f8 94       	cli
            {
                pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyCoRoutineList ) );
     96e:	e0 91 2a 07 	lds	r30, 0x072A
     972:	f0 91 2b 07 	lds	r31, 0x072B
     976:	86 81       	ldd	r24, Z+6	; 0x06
     978:	97 81       	ldd	r25, Z+7	; 0x07
     97a:	9a 83       	std	Y+2, r25	; 0x02
     97c:	89 83       	std	Y+1, r24	; 0x01
                ( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     97e:	89 81       	ldd	r24, Y+1	; 0x01
     980:	9a 81       	ldd	r25, Y+2	; 0x02
     982:	0c 96       	adiw	r24, 0x0c	; 12
     984:	0e 94 c9 0a 	call	0x1592	; 0x1592 <uxListRemove>
            }
            portENABLE_INTERRUPTS();
     988:	78 94       	sei

            ( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
     98a:	89 81       	ldd	r24, Y+1	; 0x01
     98c:	9a 81       	ldd	r25, Y+2	; 0x02
     98e:	02 96       	adiw	r24, 0x02	; 2
     990:	0e 94 c9 0a 	call	0x1592	; 0x1592 <uxListRemove>
            prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
     994:	e9 81       	ldd	r30, Y+1	; 0x01
     996:	fa 81       	ldd	r31, Y+2	; 0x02
     998:	96 89       	ldd	r25, Z+22	; 0x16
     99a:	80 91 fa 06 	lds	r24, 0x06FA
     99e:	89 17       	cp	r24, r25
     9a0:	28 f4       	brcc	.+10     	; 0x9ac <prvCheckPendingReadyList+0x4c>
     9a2:	e9 81       	ldd	r30, Y+1	; 0x01
     9a4:	fa 81       	ldd	r31, Y+2	; 0x02
     9a6:	86 89       	ldd	r24, Z+22	; 0x16
     9a8:	80 93 fa 06 	sts	0x06FA, r24
     9ac:	e9 81       	ldd	r30, Y+1	; 0x01
     9ae:	fa 81       	ldd	r31, Y+2	; 0x02
     9b0:	86 89       	ldd	r24, Z+22	; 0x16
     9b2:	28 2f       	mov	r18, r24
     9b4:	30 e0       	ldi	r19, 0x00	; 0
     9b6:	c9 01       	movw	r24, r18
     9b8:	88 0f       	add	r24, r24
     9ba:	99 1f       	adc	r25, r25
     9bc:	88 0f       	add	r24, r24
     9be:	99 1f       	adc	r25, r25
     9c0:	88 0f       	add	r24, r24
     9c2:	99 1f       	adc	r25, r25
     9c4:	82 0f       	add	r24, r18
     9c6:	93 1f       	adc	r25, r19
     9c8:	ac 01       	movw	r20, r24
     9ca:	4f 5f       	subi	r20, 0xFF	; 255
     9cc:	58 4f       	sbci	r21, 0xF8	; 248
     9ce:	89 81       	ldd	r24, Y+1	; 0x01
     9d0:	9a 81       	ldd	r25, Y+2	; 0x02
     9d2:	9c 01       	movw	r18, r24
     9d4:	2e 5f       	subi	r18, 0xFE	; 254
     9d6:	3f 4f       	sbci	r19, 0xFF	; 255
     9d8:	ca 01       	movw	r24, r20
     9da:	b9 01       	movw	r22, r18
     9dc:	0e 94 19 0a 	call	0x1432	; 0x1432 <vListInsertEnd>
    static void prvCheckPendingReadyList( void )
    {
        /* Are there any co-routines waiting to get moved to the ready list?  These
         * are co-routines that have been readied by an ISR.  The ISR cannot access
         * the ready lists itself. */
        while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
     9e0:	80 91 25 07 	lds	r24, 0x0725
     9e4:	88 23       	and	r24, r24
     9e6:	09 f0       	breq	.+2      	; 0x9ea <prvCheckPendingReadyList+0x8a>
     9e8:	c1 cf       	rjmp	.-126    	; 0x96c <prvCheckPendingReadyList+0xc>
            portENABLE_INTERRUPTS();

            ( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
            prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
        }
    }
     9ea:	0f 90       	pop	r0
     9ec:	0f 90       	pop	r0
     9ee:	cf 91       	pop	r28
     9f0:	df 91       	pop	r29
     9f2:	08 95       	ret

000009f4 <prvCheckDelayedList>:
/*-----------------------------------------------------------*/

    static void prvCheckDelayedList( void )
    {
     9f4:	df 93       	push	r29
     9f6:	cf 93       	push	r28
     9f8:	00 d0       	rcall	.+0      	; 0x9fa <prvCheckDelayedList+0x6>
     9fa:	00 d0       	rcall	.+0      	; 0x9fc <prvCheckDelayedList+0x8>
     9fc:	cd b7       	in	r28, 0x3d	; 61
     9fe:	de b7       	in	r29, 0x3e	; 62
        CRCB_t * pxCRCB;

        xPassedTicks = xTaskGetTickCount() - xLastTickCount;
     a00:	0e 94 cf 18 	call	0x319e	; 0x319e <xTaskGetTickCount>
     a04:	20 91 fd 06 	lds	r18, 0x06FD
     a08:	30 91 fe 06 	lds	r19, 0x06FE
     a0c:	82 1b       	sub	r24, r18
     a0e:	93 0b       	sbc	r25, r19
     a10:	90 93 00 07 	sts	0x0700, r25
     a14:	80 93 ff 06 	sts	0x06FF, r24
     a18:	85 c0       	rjmp	.+266    	; 0xb24 <prvCheckDelayedList+0x130>

        while( xPassedTicks )
        {
            xCoRoutineTickCount++;
     a1a:	80 91 fb 06 	lds	r24, 0x06FB
     a1e:	90 91 fc 06 	lds	r25, 0x06FC
     a22:	01 96       	adiw	r24, 0x01	; 1
     a24:	90 93 fc 06 	sts	0x06FC, r25
     a28:	80 93 fb 06 	sts	0x06FB, r24
            xPassedTicks--;
     a2c:	80 91 ff 06 	lds	r24, 0x06FF
     a30:	90 91 00 07 	lds	r25, 0x0700
     a34:	01 97       	sbiw	r24, 0x01	; 1
     a36:	90 93 00 07 	sts	0x0700, r25
     a3a:	80 93 ff 06 	sts	0x06FF, r24

            /* If the tick count has overflowed we need to swap the ready lists. */
            if( xCoRoutineTickCount == 0 )
     a3e:	80 91 fb 06 	lds	r24, 0x06FB
     a42:	90 91 fc 06 	lds	r25, 0x06FC
     a46:	00 97       	sbiw	r24, 0x00	; 0
     a48:	09 f0       	breq	.+2      	; 0xa4c <prvCheckDelayedList+0x58>
     a4a:	64 c0       	rjmp	.+200    	; 0xb14 <prvCheckDelayedList+0x120>
            {
                List_t * pxTemp;

                /* Tick count has overflowed so we need to swap the delay lists.  If there are
                 * any items in pxDelayedCoRoutineList here then there is an error! */
                pxTemp = pxDelayedCoRoutineList;
     a4c:	80 91 f4 06 	lds	r24, 0x06F4
     a50:	90 91 f5 06 	lds	r25, 0x06F5
     a54:	9a 83       	std	Y+2, r25	; 0x02
     a56:	89 83       	std	Y+1, r24	; 0x01
                pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
     a58:	80 91 f6 06 	lds	r24, 0x06F6
     a5c:	90 91 f7 06 	lds	r25, 0x06F7
     a60:	90 93 f5 06 	sts	0x06F5, r25
     a64:	80 93 f4 06 	sts	0x06F4, r24
                pxOverflowDelayedCoRoutineList = pxTemp;
     a68:	89 81       	ldd	r24, Y+1	; 0x01
     a6a:	9a 81       	ldd	r25, Y+2	; 0x02
     a6c:	90 93 f7 06 	sts	0x06F7, r25
     a70:	80 93 f6 06 	sts	0x06F6, r24
     a74:	4f c0       	rjmp	.+158    	; 0xb14 <prvCheckDelayedList+0x120>
            }

            /* See if this tick has made a timeout expire. */
            while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
            {
                pxCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
     a76:	e0 91 f4 06 	lds	r30, 0x06F4
     a7a:	f0 91 f5 06 	lds	r31, 0x06F5
     a7e:	05 80       	ldd	r0, Z+5	; 0x05
     a80:	f6 81       	ldd	r31, Z+6	; 0x06
     a82:	e0 2d       	mov	r30, r0
     a84:	86 81       	ldd	r24, Z+6	; 0x06
     a86:	97 81       	ldd	r25, Z+7	; 0x07
     a88:	9c 83       	std	Y+4, r25	; 0x04
     a8a:	8b 83       	std	Y+3, r24	; 0x03

                if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )
     a8c:	eb 81       	ldd	r30, Y+3	; 0x03
     a8e:	fc 81       	ldd	r31, Y+4	; 0x04
     a90:	22 81       	ldd	r18, Z+2	; 0x02
     a92:	33 81       	ldd	r19, Z+3	; 0x03
     a94:	80 91 fb 06 	lds	r24, 0x06FB
     a98:	90 91 fc 06 	lds	r25, 0x06FC
     a9c:	82 17       	cp	r24, r18
     a9e:	93 07       	cpc	r25, r19
     aa0:	08 f4       	brcc	.+2      	; 0xaa4 <prvCheckDelayedList+0xb0>
     aa2:	40 c0       	rjmp	.+128    	; 0xb24 <prvCheckDelayedList+0x130>
                {
                    /* Timeout not yet expired. */
                    break;
                }

                portDISABLE_INTERRUPTS();
     aa4:	f8 94       	cli
                    /* The event could have occurred just before this critical
                     *  section.  If this is the case then the generic list item will
                     *  have been moved to the pending ready list and the following
                     *  line is still valid.  Also the pvContainer parameter will have
                     *  been set to NULL so the following lines are also valid. */
                    ( void ) uxListRemove( &( pxCRCB->xGenericListItem ) );
     aa6:	8b 81       	ldd	r24, Y+3	; 0x03
     aa8:	9c 81       	ldd	r25, Y+4	; 0x04
     aaa:	02 96       	adiw	r24, 0x02	; 2
     aac:	0e 94 c9 0a 	call	0x1592	; 0x1592 <uxListRemove>

                    /* Is the co-routine waiting on an event also? */
                    if( pxCRCB->xEventListItem.pxContainer )
     ab0:	eb 81       	ldd	r30, Y+3	; 0x03
     ab2:	fc 81       	ldd	r31, Y+4	; 0x04
     ab4:	84 89       	ldd	r24, Z+20	; 0x14
     ab6:	95 89       	ldd	r25, Z+21	; 0x15
     ab8:	00 97       	sbiw	r24, 0x00	; 0
     aba:	29 f0       	breq	.+10     	; 0xac6 <prvCheckDelayedList+0xd2>
                    {
                        ( void ) uxListRemove( &( pxCRCB->xEventListItem ) );
     abc:	8b 81       	ldd	r24, Y+3	; 0x03
     abe:	9c 81       	ldd	r25, Y+4	; 0x04
     ac0:	0c 96       	adiw	r24, 0x0c	; 12
     ac2:	0e 94 c9 0a 	call	0x1592	; 0x1592 <uxListRemove>
                    }
                }
                portENABLE_INTERRUPTS();
     ac6:	78 94       	sei

                prvAddCoRoutineToReadyQueue( pxCRCB );
     ac8:	eb 81       	ldd	r30, Y+3	; 0x03
     aca:	fc 81       	ldd	r31, Y+4	; 0x04
     acc:	96 89       	ldd	r25, Z+22	; 0x16
     ace:	80 91 fa 06 	lds	r24, 0x06FA
     ad2:	89 17       	cp	r24, r25
     ad4:	28 f4       	brcc	.+10     	; 0xae0 <prvCheckDelayedList+0xec>
     ad6:	eb 81       	ldd	r30, Y+3	; 0x03
     ad8:	fc 81       	ldd	r31, Y+4	; 0x04
     ada:	86 89       	ldd	r24, Z+22	; 0x16
     adc:	80 93 fa 06 	sts	0x06FA, r24
     ae0:	eb 81       	ldd	r30, Y+3	; 0x03
     ae2:	fc 81       	ldd	r31, Y+4	; 0x04
     ae4:	86 89       	ldd	r24, Z+22	; 0x16
     ae6:	28 2f       	mov	r18, r24
     ae8:	30 e0       	ldi	r19, 0x00	; 0
     aea:	c9 01       	movw	r24, r18
     aec:	88 0f       	add	r24, r24
     aee:	99 1f       	adc	r25, r25
     af0:	88 0f       	add	r24, r24
     af2:	99 1f       	adc	r25, r25
     af4:	88 0f       	add	r24, r24
     af6:	99 1f       	adc	r25, r25
     af8:	82 0f       	add	r24, r18
     afa:	93 1f       	adc	r25, r19
     afc:	ac 01       	movw	r20, r24
     afe:	4f 5f       	subi	r20, 0xFF	; 255
     b00:	58 4f       	sbci	r21, 0xF8	; 248
     b02:	8b 81       	ldd	r24, Y+3	; 0x03
     b04:	9c 81       	ldd	r25, Y+4	; 0x04
     b06:	9c 01       	movw	r18, r24
     b08:	2e 5f       	subi	r18, 0xFE	; 254
     b0a:	3f 4f       	sbci	r19, 0xFF	; 255
     b0c:	ca 01       	movw	r24, r20
     b0e:	b9 01       	movw	r22, r18
     b10:	0e 94 19 0a 	call	0x1432	; 0x1432 <vListInsertEnd>
                pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
                pxOverflowDelayedCoRoutineList = pxTemp;
            }

            /* See if this tick has made a timeout expire. */
            while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
     b14:	e0 91 f4 06 	lds	r30, 0x06F4
     b18:	f0 91 f5 06 	lds	r31, 0x06F5
     b1c:	80 81       	ld	r24, Z
     b1e:	88 23       	and	r24, r24
     b20:	09 f0       	breq	.+2      	; 0xb24 <prvCheckDelayedList+0x130>
     b22:	a9 cf       	rjmp	.-174    	; 0xa76 <prvCheckDelayedList+0x82>
    {
        CRCB_t * pxCRCB;

        xPassedTicks = xTaskGetTickCount() - xLastTickCount;

        while( xPassedTicks )
     b24:	80 91 ff 06 	lds	r24, 0x06FF
     b28:	90 91 00 07 	lds	r25, 0x0700
     b2c:	00 97       	sbiw	r24, 0x00	; 0
     b2e:	09 f0       	breq	.+2      	; 0xb32 <prvCheckDelayedList+0x13e>
     b30:	74 cf       	rjmp	.-280    	; 0xa1a <prvCheckDelayedList+0x26>

                prvAddCoRoutineToReadyQueue( pxCRCB );
            }
        }

        xLastTickCount = xCoRoutineTickCount;
     b32:	80 91 fb 06 	lds	r24, 0x06FB
     b36:	90 91 fc 06 	lds	r25, 0x06FC
     b3a:	90 93 fe 06 	sts	0x06FE, r25
     b3e:	80 93 fd 06 	sts	0x06FD, r24
    }
     b42:	0f 90       	pop	r0
     b44:	0f 90       	pop	r0
     b46:	0f 90       	pop	r0
     b48:	0f 90       	pop	r0
     b4a:	cf 91       	pop	r28
     b4c:	df 91       	pop	r29
     b4e:	08 95       	ret

00000b50 <vCoRoutineSchedule>:
/*-----------------------------------------------------------*/

    void vCoRoutineSchedule( void )
    {
     b50:	df 93       	push	r29
     b52:	cf 93       	push	r28
     b54:	00 d0       	rcall	.+0      	; 0xb56 <vCoRoutineSchedule+0x6>
     b56:	cd b7       	in	r28, 0x3d	; 61
     b58:	de b7       	in	r29, 0x3e	; 62
        /* Only run a co-routine after prvInitialiseCoRoutineLists() has been
         * called.  prvInitialiseCoRoutineLists() is called automatically when a
         * co-routine is created. */
        if( pxDelayedCoRoutineList != NULL )
     b5a:	80 91 f4 06 	lds	r24, 0x06F4
     b5e:	90 91 f5 06 	lds	r25, 0x06F5
     b62:	00 97       	sbiw	r24, 0x00	; 0
     b64:	09 f4       	brne	.+2      	; 0xb68 <vCoRoutineSchedule+0x18>
     b66:	70 c0       	rjmp	.+224    	; 0xc48 <vCoRoutineSchedule+0xf8>
        {
            /* See if any co-routines readied by events need moving to the ready lists. */
            prvCheckPendingReadyList();
     b68:	0e 94 b0 04 	call	0x960	; 0x960 <prvCheckPendingReadyList>

            /* See if any delayed co-routines have timed out. */
            prvCheckDelayedList();
     b6c:	0e 94 fa 04 	call	0x9f4	; 0x9f4 <prvCheckDelayedList>
     b70:	0a c0       	rjmp	.+20     	; 0xb86 <vCoRoutineSchedule+0x36>

            /* Find the highest priority queue that contains ready co-routines. */
            while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
            {
                if( uxTopCoRoutineReadyPriority == 0 )
     b72:	80 91 fa 06 	lds	r24, 0x06FA
     b76:	88 23       	and	r24, r24
     b78:	09 f4       	brne	.+2      	; 0xb7c <vCoRoutineSchedule+0x2c>
     b7a:	66 c0       	rjmp	.+204    	; 0xc48 <vCoRoutineSchedule+0xf8>
                {
                    /* No more co-routines to check. */
                    return;
                }

                --uxTopCoRoutineReadyPriority;
     b7c:	80 91 fa 06 	lds	r24, 0x06FA
     b80:	81 50       	subi	r24, 0x01	; 1
     b82:	80 93 fa 06 	sts	0x06FA, r24

            /* See if any delayed co-routines have timed out. */
            prvCheckDelayedList();

            /* Find the highest priority queue that contains ready co-routines. */
            while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
     b86:	80 91 fa 06 	lds	r24, 0x06FA
     b8a:	28 2f       	mov	r18, r24
     b8c:	30 e0       	ldi	r19, 0x00	; 0
     b8e:	c9 01       	movw	r24, r18
     b90:	88 0f       	add	r24, r24
     b92:	99 1f       	adc	r25, r25
     b94:	88 0f       	add	r24, r24
     b96:	99 1f       	adc	r25, r25
     b98:	88 0f       	add	r24, r24
     b9a:	99 1f       	adc	r25, r25
     b9c:	82 0f       	add	r24, r18
     b9e:	93 1f       	adc	r25, r19
     ba0:	fc 01       	movw	r30, r24
     ba2:	ef 5f       	subi	r30, 0xFF	; 255
     ba4:	f8 4f       	sbci	r31, 0xF8	; 248
     ba6:	80 81       	ld	r24, Z
     ba8:	88 23       	and	r24, r24
     baa:	19 f3       	breq	.-58     	; 0xb72 <vCoRoutineSchedule+0x22>
                --uxTopCoRoutineReadyPriority;
            }

            /* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
             * of the same priority get an equal share of the processor time. */
            listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
     bac:	80 91 fa 06 	lds	r24, 0x06FA
     bb0:	28 2f       	mov	r18, r24
     bb2:	30 e0       	ldi	r19, 0x00	; 0
     bb4:	c9 01       	movw	r24, r18
     bb6:	88 0f       	add	r24, r24
     bb8:	99 1f       	adc	r25, r25
     bba:	88 0f       	add	r24, r24
     bbc:	99 1f       	adc	r25, r25
     bbe:	88 0f       	add	r24, r24
     bc0:	99 1f       	adc	r25, r25
     bc2:	82 0f       	add	r24, r18
     bc4:	93 1f       	adc	r25, r19
     bc6:	8f 5f       	subi	r24, 0xFF	; 255
     bc8:	98 4f       	sbci	r25, 0xF8	; 248
     bca:	9a 83       	std	Y+2, r25	; 0x02
     bcc:	89 83       	std	Y+1, r24	; 0x01
     bce:	e9 81       	ldd	r30, Y+1	; 0x01
     bd0:	fa 81       	ldd	r31, Y+2	; 0x02
     bd2:	01 80       	ldd	r0, Z+1	; 0x01
     bd4:	f2 81       	ldd	r31, Z+2	; 0x02
     bd6:	e0 2d       	mov	r30, r0
     bd8:	82 81       	ldd	r24, Z+2	; 0x02
     bda:	93 81       	ldd	r25, Z+3	; 0x03
     bdc:	e9 81       	ldd	r30, Y+1	; 0x01
     bde:	fa 81       	ldd	r31, Y+2	; 0x02
     be0:	92 83       	std	Z+2, r25	; 0x02
     be2:	81 83       	std	Z+1, r24	; 0x01
     be4:	e9 81       	ldd	r30, Y+1	; 0x01
     be6:	fa 81       	ldd	r31, Y+2	; 0x02
     be8:	21 81       	ldd	r18, Z+1	; 0x01
     bea:	32 81       	ldd	r19, Z+2	; 0x02
     bec:	89 81       	ldd	r24, Y+1	; 0x01
     bee:	9a 81       	ldd	r25, Y+2	; 0x02
     bf0:	03 96       	adiw	r24, 0x03	; 3
     bf2:	28 17       	cp	r18, r24
     bf4:	39 07       	cpc	r19, r25
     bf6:	59 f4       	brne	.+22     	; 0xc0e <vCoRoutineSchedule+0xbe>
     bf8:	e9 81       	ldd	r30, Y+1	; 0x01
     bfa:	fa 81       	ldd	r31, Y+2	; 0x02
     bfc:	01 80       	ldd	r0, Z+1	; 0x01
     bfe:	f2 81       	ldd	r31, Z+2	; 0x02
     c00:	e0 2d       	mov	r30, r0
     c02:	82 81       	ldd	r24, Z+2	; 0x02
     c04:	93 81       	ldd	r25, Z+3	; 0x03
     c06:	e9 81       	ldd	r30, Y+1	; 0x01
     c08:	fa 81       	ldd	r31, Y+2	; 0x02
     c0a:	92 83       	std	Z+2, r25	; 0x02
     c0c:	81 83       	std	Z+1, r24	; 0x01
     c0e:	e9 81       	ldd	r30, Y+1	; 0x01
     c10:	fa 81       	ldd	r31, Y+2	; 0x02
     c12:	01 80       	ldd	r0, Z+1	; 0x01
     c14:	f2 81       	ldd	r31, Z+2	; 0x02
     c16:	e0 2d       	mov	r30, r0
     c18:	86 81       	ldd	r24, Z+6	; 0x06
     c1a:	97 81       	ldd	r25, Z+7	; 0x07
     c1c:	90 93 f9 06 	sts	0x06F9, r25
     c20:	80 93 f8 06 	sts	0x06F8, r24

            /* Call the co-routine. */
            ( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
     c24:	e0 91 f8 06 	lds	r30, 0x06F8
     c28:	f0 91 f9 06 	lds	r31, 0x06F9
     c2c:	40 81       	ld	r20, Z
     c2e:	51 81       	ldd	r21, Z+1	; 0x01
     c30:	80 91 f8 06 	lds	r24, 0x06F8
     c34:	90 91 f9 06 	lds	r25, 0x06F9
     c38:	e0 91 f8 06 	lds	r30, 0x06F8
     c3c:	f0 91 f9 06 	lds	r31, 0x06F9
     c40:	27 89       	ldd	r18, Z+23	; 0x17
     c42:	62 2f       	mov	r22, r18
     c44:	fa 01       	movw	r30, r20
     c46:	09 95       	icall
        }
    }
     c48:	0f 90       	pop	r0
     c4a:	0f 90       	pop	r0
     c4c:	cf 91       	pop	r28
     c4e:	df 91       	pop	r29
     c50:	08 95       	ret

00000c52 <prvInitialiseCoRoutineLists>:
/*-----------------------------------------------------------*/

    static void prvInitialiseCoRoutineLists( void )
    {
     c52:	df 93       	push	r29
     c54:	cf 93       	push	r28
     c56:	0f 92       	push	r0
     c58:	cd b7       	in	r28, 0x3d	; 61
     c5a:	de b7       	in	r29, 0x3e	; 62
        UBaseType_t uxPriority;

        for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
     c5c:	19 82       	std	Y+1, r1	; 0x01
     c5e:	13 c0       	rjmp	.+38     	; 0xc86 <prvInitialiseCoRoutineLists+0x34>
        {
            vListInitialise( ( List_t * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
     c60:	89 81       	ldd	r24, Y+1	; 0x01
     c62:	28 2f       	mov	r18, r24
     c64:	30 e0       	ldi	r19, 0x00	; 0
     c66:	c9 01       	movw	r24, r18
     c68:	88 0f       	add	r24, r24
     c6a:	99 1f       	adc	r25, r25
     c6c:	88 0f       	add	r24, r24
     c6e:	99 1f       	adc	r25, r25
     c70:	88 0f       	add	r24, r24
     c72:	99 1f       	adc	r25, r25
     c74:	82 0f       	add	r24, r18
     c76:	93 1f       	adc	r25, r19
     c78:	8f 5f       	subi	r24, 0xFF	; 255
     c7a:	98 4f       	sbci	r25, 0xF8	; 248
     c7c:	0e 94 df 09 	call	0x13be	; 0x13be <vListInitialise>

    static void prvInitialiseCoRoutineLists( void )
    {
        UBaseType_t uxPriority;

        for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
     c80:	89 81       	ldd	r24, Y+1	; 0x01
     c82:	8f 5f       	subi	r24, 0xFF	; 255
     c84:	89 83       	std	Y+1, r24	; 0x01
     c86:	89 81       	ldd	r24, Y+1	; 0x01
     c88:	82 30       	cpi	r24, 0x02	; 2
     c8a:	50 f3       	brcs	.-44     	; 0xc60 <prvInitialiseCoRoutineLists+0xe>
        {
            vListInitialise( ( List_t * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
        }

        vListInitialise( ( List_t * ) &xDelayedCoRoutineList1 );
     c8c:	83 e1       	ldi	r24, 0x13	; 19
     c8e:	97 e0       	ldi	r25, 0x07	; 7
     c90:	0e 94 df 09 	call	0x13be	; 0x13be <vListInitialise>
        vListInitialise( ( List_t * ) &xDelayedCoRoutineList2 );
     c94:	8c e1       	ldi	r24, 0x1C	; 28
     c96:	97 e0       	ldi	r25, 0x07	; 7
     c98:	0e 94 df 09 	call	0x13be	; 0x13be <vListInitialise>
        vListInitialise( ( List_t * ) &xPendingReadyCoRoutineList );
     c9c:	85 e2       	ldi	r24, 0x25	; 37
     c9e:	97 e0       	ldi	r25, 0x07	; 7
     ca0:	0e 94 df 09 	call	0x13be	; 0x13be <vListInitialise>

        /* Start with pxDelayedCoRoutineList using list1 and the
         * pxOverflowDelayedCoRoutineList using list2. */
        pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
     ca4:	83 e1       	ldi	r24, 0x13	; 19
     ca6:	97 e0       	ldi	r25, 0x07	; 7
     ca8:	90 93 f5 06 	sts	0x06F5, r25
     cac:	80 93 f4 06 	sts	0x06F4, r24
        pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
     cb0:	8c e1       	ldi	r24, 0x1C	; 28
     cb2:	97 e0       	ldi	r25, 0x07	; 7
     cb4:	90 93 f7 06 	sts	0x06F7, r25
     cb8:	80 93 f6 06 	sts	0x06F6, r24
    }
     cbc:	0f 90       	pop	r0
     cbe:	cf 91       	pop	r28
     cc0:	df 91       	pop	r29
     cc2:	08 95       	ret

00000cc4 <xCoRoutineRemoveFromEventList>:
/*-----------------------------------------------------------*/

    BaseType_t xCoRoutineRemoveFromEventList( const List_t * pxEventList )
    {
     cc4:	df 93       	push	r29
     cc6:	cf 93       	push	r28
     cc8:	00 d0       	rcall	.+0      	; 0xcca <xCoRoutineRemoveFromEventList+0x6>
     cca:	00 d0       	rcall	.+0      	; 0xccc <xCoRoutineRemoveFromEventList+0x8>
     ccc:	0f 92       	push	r0
     cce:	cd b7       	in	r28, 0x3d	; 61
     cd0:	de b7       	in	r29, 0x3e	; 62
     cd2:	9d 83       	std	Y+5, r25	; 0x05
     cd4:	8c 83       	std	Y+4, r24	; 0x04
        BaseType_t xReturn;

        /* This function is called from within an interrupt.  It can only access
         * event lists and the pending ready list.  This function assumes that a
         * check has already been made to ensure pxEventList is not empty. */
        pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
     cd6:	ec 81       	ldd	r30, Y+4	; 0x04
     cd8:	fd 81       	ldd	r31, Y+5	; 0x05
     cda:	05 80       	ldd	r0, Z+5	; 0x05
     cdc:	f6 81       	ldd	r31, Z+6	; 0x06
     cde:	e0 2d       	mov	r30, r0
     ce0:	86 81       	ldd	r24, Z+6	; 0x06
     ce2:	97 81       	ldd	r25, Z+7	; 0x07
     ce4:	9b 83       	std	Y+3, r25	; 0x03
     ce6:	8a 83       	std	Y+2, r24	; 0x02
        ( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     ce8:	8a 81       	ldd	r24, Y+2	; 0x02
     cea:	9b 81       	ldd	r25, Y+3	; 0x03
     cec:	0c 96       	adiw	r24, 0x0c	; 12
     cee:	0e 94 c9 0a 	call	0x1592	; 0x1592 <uxListRemove>
        vListInsertEnd( ( List_t * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
     cf2:	8a 81       	ldd	r24, Y+2	; 0x02
     cf4:	9b 81       	ldd	r25, Y+3	; 0x03
     cf6:	9c 01       	movw	r18, r24
     cf8:	24 5f       	subi	r18, 0xF4	; 244
     cfa:	3f 4f       	sbci	r19, 0xFF	; 255
     cfc:	85 e2       	ldi	r24, 0x25	; 37
     cfe:	97 e0       	ldi	r25, 0x07	; 7
     d00:	b9 01       	movw	r22, r18
     d02:	0e 94 19 0a 	call	0x1432	; 0x1432 <vListInsertEnd>

        if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
     d06:	ea 81       	ldd	r30, Y+2	; 0x02
     d08:	fb 81       	ldd	r31, Y+3	; 0x03
     d0a:	96 89       	ldd	r25, Z+22	; 0x16
     d0c:	e0 91 f8 06 	lds	r30, 0x06F8
     d10:	f0 91 f9 06 	lds	r31, 0x06F9
     d14:	86 89       	ldd	r24, Z+22	; 0x16
     d16:	98 17       	cp	r25, r24
     d18:	18 f0       	brcs	.+6      	; 0xd20 <xCoRoutineRemoveFromEventList+0x5c>
        {
            xReturn = pdTRUE;
     d1a:	81 e0       	ldi	r24, 0x01	; 1
     d1c:	89 83       	std	Y+1, r24	; 0x01
     d1e:	01 c0       	rjmp	.+2      	; 0xd22 <xCoRoutineRemoveFromEventList+0x5e>
        }
        else
        {
            xReturn = pdFALSE;
     d20:	19 82       	std	Y+1, r1	; 0x01
        }

        return xReturn;
     d22:	89 81       	ldd	r24, Y+1	; 0x01
    }
     d24:	0f 90       	pop	r0
     d26:	0f 90       	pop	r0
     d28:	0f 90       	pop	r0
     d2a:	0f 90       	pop	r0
     d2c:	0f 90       	pop	r0
     d2e:	cf 91       	pop	r28
     d30:	df 91       	pop	r29
     d32:	08 95       	ret

00000d34 <xEventGroupCreate>:
/*-----------------------------------------------------------*/

#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

    EventGroupHandle_t xEventGroupCreate( void )
    {
     d34:	df 93       	push	r29
     d36:	cf 93       	push	r28
     d38:	00 d0       	rcall	.+0      	; 0xd3a <xEventGroupCreate+0x6>
     d3a:	cd b7       	in	r28, 0x3d	; 61
     d3c:	de b7       	in	r29, 0x3e	; 62
         * TickType_t alignment requirements the cast is safe.  In other cases,
         * where the natural word size of the architecture is less than
         * sizeof( TickType_t ), the TickType_t variables will be accessed in two
         * or more reads operations, and the alignment requirements is only that
         * of each individual read. */
        pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) ); /*lint !e9087 !e9079 see comment above. */
     d3e:	8b e0       	ldi	r24, 0x0B	; 11
     d40:	90 e0       	ldi	r25, 0x00	; 0
     d42:	0e 94 67 00 	call	0xce	; 0xce <pvPortMalloc>
     d46:	9a 83       	std	Y+2, r25	; 0x02
     d48:	89 83       	std	Y+1, r24	; 0x01

        if( pxEventBits != NULL )
     d4a:	89 81       	ldd	r24, Y+1	; 0x01
     d4c:	9a 81       	ldd	r25, Y+2	; 0x02
     d4e:	00 97       	sbiw	r24, 0x00	; 0
     d50:	49 f0       	breq	.+18     	; 0xd64 <xEventGroupCreate+0x30>
        {
            pxEventBits->uxEventBits = 0;
     d52:	e9 81       	ldd	r30, Y+1	; 0x01
     d54:	fa 81       	ldd	r31, Y+2	; 0x02
     d56:	11 82       	std	Z+1, r1	; 0x01
     d58:	10 82       	st	Z, r1
            vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
     d5a:	89 81       	ldd	r24, Y+1	; 0x01
     d5c:	9a 81       	ldd	r25, Y+2	; 0x02
     d5e:	02 96       	adiw	r24, 0x02	; 2
     d60:	0e 94 df 09 	call	0x13be	; 0x13be <vListInitialise>
        else
        {
            traceEVENT_GROUP_CREATE_FAILED(); /*lint !e9063 Else branch only exists to allow tracing and does not generate code if trace macros are not defined. */
        }

        return pxEventBits;
     d64:	89 81       	ldd	r24, Y+1	; 0x01
     d66:	9a 81       	ldd	r25, Y+2	; 0x02
    }
     d68:	0f 90       	pop	r0
     d6a:	0f 90       	pop	r0
     d6c:	cf 91       	pop	r28
     d6e:	df 91       	pop	r29
     d70:	08 95       	ret

00000d72 <xEventGroupSync>:

EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup,
                             const EventBits_t uxBitsToSet,
                             const EventBits_t uxBitsToWaitFor,
                             TickType_t xTicksToWait )
{
     d72:	df 93       	push	r29
     d74:	cf 93       	push	r28
     d76:	cd b7       	in	r28, 0x3d	; 61
     d78:	de b7       	in	r29, 0x3e	; 62
     d7a:	60 97       	sbiw	r28, 0x10	; 16
     d7c:	0f b6       	in	r0, 0x3f	; 63
     d7e:	f8 94       	cli
     d80:	de bf       	out	0x3e, r29	; 62
     d82:	0f be       	out	0x3f, r0	; 63
     d84:	cd bf       	out	0x3d, r28	; 61
     d86:	9a 87       	std	Y+10, r25	; 0x0a
     d88:	89 87       	std	Y+9, r24	; 0x09
     d8a:	7c 87       	std	Y+12, r23	; 0x0c
     d8c:	6b 87       	std	Y+11, r22	; 0x0b
     d8e:	5e 87       	std	Y+14, r21	; 0x0e
     d90:	4d 87       	std	Y+13, r20	; 0x0d
     d92:	38 8b       	std	Y+16, r19	; 0x10
     d94:	2f 87       	std	Y+15, r18	; 0x0f
    EventBits_t uxOriginalBitValue, uxReturn;
    EventGroup_t * pxEventBits = xEventGroup;
     d96:	89 85       	ldd	r24, Y+9	; 0x09
     d98:	9a 85       	ldd	r25, Y+10	; 0x0a
     d9a:	9c 83       	std	Y+4, r25	; 0x04
     d9c:	8b 83       	std	Y+3, r24	; 0x03
    BaseType_t xAlreadyYielded;
    BaseType_t xTimeoutOccurred = pdFALSE;
     d9e:	19 82       	std	Y+1, r1	; 0x01
        {
            configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
        }
    #endif

    vTaskSuspendAll();
     da0:	0e 94 73 17 	call	0x2ee6	; 0x2ee6 <vTaskSuspendAll>
    {
        uxOriginalBitValue = pxEventBits->uxEventBits;
     da4:	eb 81       	ldd	r30, Y+3	; 0x03
     da6:	fc 81       	ldd	r31, Y+4	; 0x04
     da8:	80 81       	ld	r24, Z
     daa:	91 81       	ldd	r25, Z+1	; 0x01
     dac:	98 87       	std	Y+8, r25	; 0x08
     dae:	8f 83       	std	Y+7, r24	; 0x07

        ( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
     db0:	89 85       	ldd	r24, Y+9	; 0x09
     db2:	9a 85       	ldd	r25, Y+10	; 0x0a
     db4:	2b 85       	ldd	r18, Y+11	; 0x0b
     db6:	3c 85       	ldd	r19, Y+12	; 0x0c
     db8:	b9 01       	movw	r22, r18
     dba:	0e 94 90 08 	call	0x1120	; 0x1120 <xEventGroupSetBits>

        if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
     dbe:	2f 81       	ldd	r18, Y+7	; 0x07
     dc0:	38 85       	ldd	r19, Y+8	; 0x08
     dc2:	8b 85       	ldd	r24, Y+11	; 0x0b
     dc4:	9c 85       	ldd	r25, Y+12	; 0x0c
     dc6:	28 2b       	or	r18, r24
     dc8:	39 2b       	or	r19, r25
     dca:	8d 85       	ldd	r24, Y+13	; 0x0d
     dcc:	9e 85       	ldd	r25, Y+14	; 0x0e
     dce:	28 23       	and	r18, r24
     dd0:	39 23       	and	r19, r25
     dd2:	8d 85       	ldd	r24, Y+13	; 0x0d
     dd4:	9e 85       	ldd	r25, Y+14	; 0x0e
     dd6:	28 17       	cp	r18, r24
     dd8:	39 07       	cpc	r19, r25
     dda:	c9 f4       	brne	.+50     	; 0xe0e <xEventGroupSync+0x9c>
        {
            /* All the rendezvous bits are now set - no need to block. */
            uxReturn = ( uxOriginalBitValue | uxBitsToSet );
     ddc:	2f 81       	ldd	r18, Y+7	; 0x07
     dde:	38 85       	ldd	r19, Y+8	; 0x08
     de0:	8b 85       	ldd	r24, Y+11	; 0x0b
     de2:	9c 85       	ldd	r25, Y+12	; 0x0c
     de4:	82 2b       	or	r24, r18
     de6:	93 2b       	or	r25, r19
     de8:	9e 83       	std	Y+6, r25	; 0x06
     dea:	8d 83       	std	Y+5, r24	; 0x05

            /* Rendezvous always clear the bits.  They will have been cleared
             * already unless this is the only task in the rendezvous. */
            pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     dec:	eb 81       	ldd	r30, Y+3	; 0x03
     dee:	fc 81       	ldd	r31, Y+4	; 0x04
     df0:	20 81       	ld	r18, Z
     df2:	31 81       	ldd	r19, Z+1	; 0x01
     df4:	8d 85       	ldd	r24, Y+13	; 0x0d
     df6:	9e 85       	ldd	r25, Y+14	; 0x0e
     df8:	80 95       	com	r24
     dfa:	90 95       	com	r25
     dfc:	82 23       	and	r24, r18
     dfe:	93 23       	and	r25, r19
     e00:	eb 81       	ldd	r30, Y+3	; 0x03
     e02:	fc 81       	ldd	r31, Y+4	; 0x04
     e04:	91 83       	std	Z+1, r25	; 0x01
     e06:	80 83       	st	Z, r24

            xTicksToWait = 0;
     e08:	18 8a       	std	Y+16, r1	; 0x10
     e0a:	1f 86       	std	Y+15, r1	; 0x0f
     e0c:	1e c0       	rjmp	.+60     	; 0xe4a <xEventGroupSync+0xd8>
        }
        else
        {
            if( xTicksToWait != ( TickType_t ) 0 )
     e0e:	8f 85       	ldd	r24, Y+15	; 0x0f
     e10:	98 89       	ldd	r25, Y+16	; 0x10
     e12:	00 97       	sbiw	r24, 0x00	; 0
     e14:	91 f0       	breq	.+36     	; 0xe3a <xEventGroupSync+0xc8>
                traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );

                /* Store the bits that the calling task is waiting for in the
                 * task's event list item so the kernel knows when a match is
                 * found.  Then enter the blocked state. */
                vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
     e16:	8b 81       	ldd	r24, Y+3	; 0x03
     e18:	9c 81       	ldd	r25, Y+4	; 0x04
     e1a:	bc 01       	movw	r22, r24
     e1c:	6e 5f       	subi	r22, 0xFE	; 254
     e1e:	7f 4f       	sbci	r23, 0xFF	; 255
     e20:	8d 85       	ldd	r24, Y+13	; 0x0d
     e22:	9e 85       	ldd	r25, Y+14	; 0x0e
     e24:	9c 01       	movw	r18, r24
     e26:	35 60       	ori	r19, 0x05	; 5
     e28:	4f 85       	ldd	r20, Y+15	; 0x0f
     e2a:	58 89       	ldd	r21, Y+16	; 0x10
     e2c:	cb 01       	movw	r24, r22
     e2e:	b9 01       	movw	r22, r18
     e30:	0e 94 72 1b 	call	0x36e4	; 0x36e4 <vTaskPlaceOnUnorderedEventList>

                /* This assignment is obsolete as uxReturn will get set after
                 * the task unblocks, but some compilers mistakenly generate a
                 * warning about uxReturn being returned without being set if the
                 * assignment is omitted. */
                uxReturn = 0;
     e34:	1e 82       	std	Y+6, r1	; 0x06
     e36:	1d 82       	std	Y+5, r1	; 0x05
     e38:	08 c0       	rjmp	.+16     	; 0xe4a <xEventGroupSync+0xd8>
            }
            else
            {
                /* The rendezvous bits were not set, but no block time was
                 * specified - just return the current event bit value. */
                uxReturn = pxEventBits->uxEventBits;
     e3a:	eb 81       	ldd	r30, Y+3	; 0x03
     e3c:	fc 81       	ldd	r31, Y+4	; 0x04
     e3e:	80 81       	ld	r24, Z
     e40:	91 81       	ldd	r25, Z+1	; 0x01
     e42:	9e 83       	std	Y+6, r25	; 0x06
     e44:	8d 83       	std	Y+5, r24	; 0x05
                xTimeoutOccurred = pdTRUE;
     e46:	81 e0       	ldi	r24, 0x01	; 1
     e48:	89 83       	std	Y+1, r24	; 0x01
            }
        }
    }
    xAlreadyYielded = xTaskResumeAll();
     e4a:	0e 94 7f 17 	call	0x2efe	; 0x2efe <xTaskResumeAll>
     e4e:	8a 83       	std	Y+2, r24	; 0x02

    if( xTicksToWait != ( TickType_t ) 0 )
     e50:	8f 85       	ldd	r24, Y+15	; 0x0f
     e52:	98 89       	ldd	r25, Y+16	; 0x10
     e54:	00 97       	sbiw	r24, 0x00	; 0
     e56:	09 f4       	brne	.+2      	; 0xe5a <xEventGroupSync+0xe8>
     e58:	3a c0       	rjmp	.+116    	; 0xece <xEventGroupSync+0x15c>
    {
        if( xAlreadyYielded == pdFALSE )
     e5a:	8a 81       	ldd	r24, Y+2	; 0x02
     e5c:	88 23       	and	r24, r24
     e5e:	11 f4       	brne	.+4      	; 0xe64 <xEventGroupSync+0xf2>
        {
            portYIELD_WITHIN_API();
     e60:	0e 94 a6 02 	call	0x54c	; 0x54c <vPortYield>

        /* The task blocked to wait for its required bits to be set - at this
         * point either the required bits were set or the block time expired.  If
         * the required bits were set they will have been stored in the task's
         * event list item, and they should now be retrieved then cleared. */
        uxReturn = uxTaskResetEventItemValue();
     e64:	0e 94 85 1f 	call	0x3f0a	; 0x3f0a <uxTaskResetEventItemValue>
     e68:	9e 83       	std	Y+6, r25	; 0x06
     e6a:	8d 83       	std	Y+5, r24	; 0x05

        if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
     e6c:	8d 81       	ldd	r24, Y+5	; 0x05
     e6e:	9e 81       	ldd	r25, Y+6	; 0x06
     e70:	80 70       	andi	r24, 0x00	; 0
     e72:	92 70       	andi	r25, 0x02	; 2
     e74:	00 97       	sbiw	r24, 0x00	; 0
     e76:	31 f5       	brne	.+76     	; 0xec4 <xEventGroupSync+0x152>
        {
            /* The task timed out, just return the current event bit value. */
            taskENTER_CRITICAL();
     e78:	0f b6       	in	r0, 0x3f	; 63
     e7a:	f8 94       	cli
     e7c:	0f 92       	push	r0
            {
                uxReturn = pxEventBits->uxEventBits;
     e7e:	eb 81       	ldd	r30, Y+3	; 0x03
     e80:	fc 81       	ldd	r31, Y+4	; 0x04
     e82:	80 81       	ld	r24, Z
     e84:	91 81       	ldd	r25, Z+1	; 0x01
     e86:	9e 83       	std	Y+6, r25	; 0x06
     e88:	8d 83       	std	Y+5, r24	; 0x05

                /* Although the task got here because it timed out before the
                 * bits it was waiting for were set, it is possible that since it
                 * unblocked another task has set the bits.  If this is the case
                 * then it needs to clear the bits before exiting. */
                if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
     e8a:	2d 81       	ldd	r18, Y+5	; 0x05
     e8c:	3e 81       	ldd	r19, Y+6	; 0x06
     e8e:	8d 85       	ldd	r24, Y+13	; 0x0d
     e90:	9e 85       	ldd	r25, Y+14	; 0x0e
     e92:	28 23       	and	r18, r24
     e94:	39 23       	and	r19, r25
     e96:	8d 85       	ldd	r24, Y+13	; 0x0d
     e98:	9e 85       	ldd	r25, Y+14	; 0x0e
     e9a:	28 17       	cp	r18, r24
     e9c:	39 07       	cpc	r19, r25
     e9e:	71 f4       	brne	.+28     	; 0xebc <xEventGroupSync+0x14a>
                {
                    pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     ea0:	eb 81       	ldd	r30, Y+3	; 0x03
     ea2:	fc 81       	ldd	r31, Y+4	; 0x04
     ea4:	20 81       	ld	r18, Z
     ea6:	31 81       	ldd	r19, Z+1	; 0x01
     ea8:	8d 85       	ldd	r24, Y+13	; 0x0d
     eaa:	9e 85       	ldd	r25, Y+14	; 0x0e
     eac:	80 95       	com	r24
     eae:	90 95       	com	r25
     eb0:	82 23       	and	r24, r18
     eb2:	93 23       	and	r25, r19
     eb4:	eb 81       	ldd	r30, Y+3	; 0x03
     eb6:	fc 81       	ldd	r31, Y+4	; 0x04
     eb8:	91 83       	std	Z+1, r25	; 0x01
     eba:	80 83       	st	Z, r24
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            taskEXIT_CRITICAL();
     ebc:	0f 90       	pop	r0
     ebe:	0f be       	out	0x3f, r0	; 63

            xTimeoutOccurred = pdTRUE;
     ec0:	81 e0       	ldi	r24, 0x01	; 1
     ec2:	89 83       	std	Y+1, r24	; 0x01
            /* The task unblocked because the bits were set. */
        }

        /* Control bits might be set as the task had blocked should not be
         * returned. */
        uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
     ec4:	8d 81       	ldd	r24, Y+5	; 0x05
     ec6:	9e 81       	ldd	r25, Y+6	; 0x06
     ec8:	90 70       	andi	r25, 0x00	; 0
     eca:	9e 83       	std	Y+6, r25	; 0x06
     ecc:	8d 83       	std	Y+5, r24	; 0x05
    traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );

    /* Prevent compiler warnings when trace macros are not used. */
    ( void ) xTimeoutOccurred;

    return uxReturn;
     ece:	8d 81       	ldd	r24, Y+5	; 0x05
     ed0:	9e 81       	ldd	r25, Y+6	; 0x06
}
     ed2:	60 96       	adiw	r28, 0x10	; 16
     ed4:	0f b6       	in	r0, 0x3f	; 63
     ed6:	f8 94       	cli
     ed8:	de bf       	out	0x3e, r29	; 62
     eda:	0f be       	out	0x3f, r0	; 63
     edc:	cd bf       	out	0x3d, r28	; 61
     ede:	cf 91       	pop	r28
     ee0:	df 91       	pop	r29
     ee2:	08 95       	ret

00000ee4 <xEventGroupWaitBits>:
EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup,
                                 const EventBits_t uxBitsToWaitFor,
                                 const BaseType_t xClearOnExit,
                                 const BaseType_t xWaitForAllBits,
                                 TickType_t xTicksToWait )
{
     ee4:	0f 93       	push	r16
     ee6:	1f 93       	push	r17
     ee8:	df 93       	push	r29
     eea:	cf 93       	push	r28
     eec:	cd b7       	in	r28, 0x3d	; 61
     eee:	de b7       	in	r29, 0x3e	; 62
     ef0:	63 97       	sbiw	r28, 0x13	; 19
     ef2:	0f b6       	in	r0, 0x3f	; 63
     ef4:	f8 94       	cli
     ef6:	de bf       	out	0x3e, r29	; 62
     ef8:	0f be       	out	0x3f, r0	; 63
     efa:	cd bf       	out	0x3d, r28	; 61
     efc:	9d 87       	std	Y+13, r25	; 0x0d
     efe:	8c 87       	std	Y+12, r24	; 0x0c
     f00:	7f 87       	std	Y+15, r23	; 0x0f
     f02:	6e 87       	std	Y+14, r22	; 0x0e
     f04:	48 8b       	std	Y+16, r20	; 0x10
     f06:	29 8b       	std	Y+17, r18	; 0x11
     f08:	1b 8b       	std	Y+19, r17	; 0x13
     f0a:	0a 8b       	std	Y+18, r16	; 0x12
    EventGroup_t * pxEventBits = xEventGroup;
     f0c:	8c 85       	ldd	r24, Y+12	; 0x0c
     f0e:	9d 85       	ldd	r25, Y+13	; 0x0d
     f10:	9b 87       	std	Y+11, r25	; 0x0b
     f12:	8a 87       	std	Y+10, r24	; 0x0a
    EventBits_t uxReturn, uxControlBits = 0;
     f14:	1f 82       	std	Y+7, r1	; 0x07
     f16:	1e 82       	std	Y+6, r1	; 0x06
    BaseType_t xWaitConditionMet, xAlreadyYielded;
    BaseType_t xTimeoutOccurred = pdFALSE;
     f18:	1b 82       	std	Y+3, r1	; 0x03
        {
            configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
        }
    #endif

    vTaskSuspendAll();
     f1a:	0e 94 73 17 	call	0x2ee6	; 0x2ee6 <vTaskSuspendAll>
    {
        const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
     f1e:	ea 85       	ldd	r30, Y+10	; 0x0a
     f20:	fb 85       	ldd	r31, Y+11	; 0x0b
     f22:	80 81       	ld	r24, Z
     f24:	91 81       	ldd	r25, Z+1	; 0x01
     f26:	9a 83       	std	Y+2, r25	; 0x02
     f28:	89 83       	std	Y+1, r24	; 0x01

        /* Check to see if the wait condition is already met or not. */
        xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
     f2a:	89 81       	ldd	r24, Y+1	; 0x01
     f2c:	9a 81       	ldd	r25, Y+2	; 0x02
     f2e:	2e 85       	ldd	r18, Y+14	; 0x0e
     f30:	3f 85       	ldd	r19, Y+15	; 0x0f
     f32:	b9 01       	movw	r22, r18
     f34:	49 89       	ldd	r20, Y+17	; 0x11
     f36:	0e 94 ad 09 	call	0x135a	; 0x135a <prvTestWaitCondition>
     f3a:	8d 83       	std	Y+5, r24	; 0x05

        if( xWaitConditionMet != pdFALSE )
     f3c:	8d 81       	ldd	r24, Y+5	; 0x05
     f3e:	88 23       	and	r24, r24
     f40:	c1 f0       	breq	.+48     	; 0xf72 <xEventGroupWaitBits+0x8e>
        {
            /* The wait condition has already been met so there is no need to
             * block. */
            uxReturn = uxCurrentEventBits;
     f42:	89 81       	ldd	r24, Y+1	; 0x01
     f44:	9a 81       	ldd	r25, Y+2	; 0x02
     f46:	99 87       	std	Y+9, r25	; 0x09
     f48:	88 87       	std	Y+8, r24	; 0x08
            xTicksToWait = ( TickType_t ) 0;
     f4a:	1b 8a       	std	Y+19, r1	; 0x13
     f4c:	1a 8a       	std	Y+18, r1	; 0x12

            /* Clear the wait bits if requested to do so. */
            if( xClearOnExit != pdFALSE )
     f4e:	88 89       	ldd	r24, Y+16	; 0x10
     f50:	88 23       	and	r24, r24
     f52:	e9 f1       	breq	.+122    	; 0xfce <xEventGroupWaitBits+0xea>
            {
                pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     f54:	ea 85       	ldd	r30, Y+10	; 0x0a
     f56:	fb 85       	ldd	r31, Y+11	; 0x0b
     f58:	20 81       	ld	r18, Z
     f5a:	31 81       	ldd	r19, Z+1	; 0x01
     f5c:	8e 85       	ldd	r24, Y+14	; 0x0e
     f5e:	9f 85       	ldd	r25, Y+15	; 0x0f
     f60:	80 95       	com	r24
     f62:	90 95       	com	r25
     f64:	82 23       	and	r24, r18
     f66:	93 23       	and	r25, r19
     f68:	ea 85       	ldd	r30, Y+10	; 0x0a
     f6a:	fb 85       	ldd	r31, Y+11	; 0x0b
     f6c:	91 83       	std	Z+1, r25	; 0x01
     f6e:	80 83       	st	Z, r24
     f70:	2e c0       	rjmp	.+92     	; 0xfce <xEventGroupWaitBits+0xea>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        else if( xTicksToWait == ( TickType_t ) 0 )
     f72:	8a 89       	ldd	r24, Y+18	; 0x12
     f74:	9b 89       	ldd	r25, Y+19	; 0x13
     f76:	00 97       	sbiw	r24, 0x00	; 0
     f78:	39 f4       	brne	.+14     	; 0xf88 <xEventGroupWaitBits+0xa4>
        {
            /* The wait condition has not been met, but no block time was
             * specified, so just return the current value. */
            uxReturn = uxCurrentEventBits;
     f7a:	89 81       	ldd	r24, Y+1	; 0x01
     f7c:	9a 81       	ldd	r25, Y+2	; 0x02
     f7e:	99 87       	std	Y+9, r25	; 0x09
     f80:	88 87       	std	Y+8, r24	; 0x08
            xTimeoutOccurred = pdTRUE;
     f82:	81 e0       	ldi	r24, 0x01	; 1
     f84:	8b 83       	std	Y+3, r24	; 0x03
     f86:	23 c0       	rjmp	.+70     	; 0xfce <xEventGroupWaitBits+0xea>
        {
            /* The task is going to block to wait for its required bits to be
             * set.  uxControlBits are used to remember the specified behaviour of
             * this call to xEventGroupWaitBits() - for use when the event bits
             * unblock the task. */
            if( xClearOnExit != pdFALSE )
     f88:	88 89       	ldd	r24, Y+16	; 0x10
     f8a:	88 23       	and	r24, r24
     f8c:	29 f0       	breq	.+10     	; 0xf98 <xEventGroupWaitBits+0xb4>
            {
                uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
     f8e:	8e 81       	ldd	r24, Y+6	; 0x06
     f90:	9f 81       	ldd	r25, Y+7	; 0x07
     f92:	91 60       	ori	r25, 0x01	; 1
     f94:	9f 83       	std	Y+7, r25	; 0x07
     f96:	8e 83       	std	Y+6, r24	; 0x06
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            if( xWaitForAllBits != pdFALSE )
     f98:	89 89       	ldd	r24, Y+17	; 0x11
     f9a:	88 23       	and	r24, r24
     f9c:	29 f0       	breq	.+10     	; 0xfa8 <xEventGroupWaitBits+0xc4>
            {
                uxControlBits |= eventWAIT_FOR_ALL_BITS;
     f9e:	8e 81       	ldd	r24, Y+6	; 0x06
     fa0:	9f 81       	ldd	r25, Y+7	; 0x07
     fa2:	94 60       	ori	r25, 0x04	; 4
     fa4:	9f 83       	std	Y+7, r25	; 0x07
     fa6:	8e 83       	std	Y+6, r24	; 0x06
            }

            /* Store the bits that the calling task is waiting for in the
             * task's event list item so the kernel knows when a match is
             * found.  Then enter the blocked state. */
            vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
     fa8:	8a 85       	ldd	r24, Y+10	; 0x0a
     faa:	9b 85       	ldd	r25, Y+11	; 0x0b
     fac:	bc 01       	movw	r22, r24
     fae:	6e 5f       	subi	r22, 0xFE	; 254
     fb0:	7f 4f       	sbci	r23, 0xFF	; 255
     fb2:	2e 85       	ldd	r18, Y+14	; 0x0e
     fb4:	3f 85       	ldd	r19, Y+15	; 0x0f
     fb6:	8e 81       	ldd	r24, Y+6	; 0x06
     fb8:	9f 81       	ldd	r25, Y+7	; 0x07
     fba:	28 2b       	or	r18, r24
     fbc:	39 2b       	or	r19, r25
     fbe:	4a 89       	ldd	r20, Y+18	; 0x12
     fc0:	5b 89       	ldd	r21, Y+19	; 0x13
     fc2:	cb 01       	movw	r24, r22
     fc4:	b9 01       	movw	r22, r18
     fc6:	0e 94 72 1b 	call	0x36e4	; 0x36e4 <vTaskPlaceOnUnorderedEventList>

            /* This is obsolete as it will get set after the task unblocks, but
             * some compilers mistakenly generate a warning about the variable
             * being returned without being set if it is not done. */
            uxReturn = 0;
     fca:	19 86       	std	Y+9, r1	; 0x09
     fcc:	18 86       	std	Y+8, r1	; 0x08

            traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
        }
    }
    xAlreadyYielded = xTaskResumeAll();
     fce:	0e 94 7f 17 	call	0x2efe	; 0x2efe <xTaskResumeAll>
     fd2:	8c 83       	std	Y+4, r24	; 0x04

    if( xTicksToWait != ( TickType_t ) 0 )
     fd4:	8a 89       	ldd	r24, Y+18	; 0x12
     fd6:	9b 89       	ldd	r25, Y+19	; 0x13
     fd8:	00 97       	sbiw	r24, 0x00	; 0
     fda:	09 f4       	brne	.+2      	; 0xfde <xEventGroupWaitBits+0xfa>
     fdc:	3c c0       	rjmp	.+120    	; 0x1056 <xEventGroupWaitBits+0x172>
    {
        if( xAlreadyYielded == pdFALSE )
     fde:	8c 81       	ldd	r24, Y+4	; 0x04
     fe0:	88 23       	and	r24, r24
     fe2:	11 f4       	brne	.+4      	; 0xfe8 <xEventGroupWaitBits+0x104>
        {
            portYIELD_WITHIN_API();
     fe4:	0e 94 a6 02 	call	0x54c	; 0x54c <vPortYield>

        /* The task blocked to wait for its required bits to be set - at this
         * point either the required bits were set or the block time expired.  If
         * the required bits were set they will have been stored in the task's
         * event list item, and they should now be retrieved then cleared. */
        uxReturn = uxTaskResetEventItemValue();
     fe8:	0e 94 85 1f 	call	0x3f0a	; 0x3f0a <uxTaskResetEventItemValue>
     fec:	99 87       	std	Y+9, r25	; 0x09
     fee:	88 87       	std	Y+8, r24	; 0x08

        if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
     ff0:	88 85       	ldd	r24, Y+8	; 0x08
     ff2:	99 85       	ldd	r25, Y+9	; 0x09
     ff4:	80 70       	andi	r24, 0x00	; 0
     ff6:	92 70       	andi	r25, 0x02	; 2
     ff8:	00 97       	sbiw	r24, 0x00	; 0
     ffa:	41 f5       	brne	.+80     	; 0x104c <xEventGroupWaitBits+0x168>
        {
            taskENTER_CRITICAL();
     ffc:	0f b6       	in	r0, 0x3f	; 63
     ffe:	f8 94       	cli
    1000:	0f 92       	push	r0
            {
                /* The task timed out, just return the current event bit value. */
                uxReturn = pxEventBits->uxEventBits;
    1002:	ea 85       	ldd	r30, Y+10	; 0x0a
    1004:	fb 85       	ldd	r31, Y+11	; 0x0b
    1006:	80 81       	ld	r24, Z
    1008:	91 81       	ldd	r25, Z+1	; 0x01
    100a:	99 87       	std	Y+9, r25	; 0x09
    100c:	88 87       	std	Y+8, r24	; 0x08

                /* It is possible that the event bits were updated between this
                 * task leaving the Blocked state and running again. */
                if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
    100e:	88 85       	ldd	r24, Y+8	; 0x08
    1010:	99 85       	ldd	r25, Y+9	; 0x09
    1012:	2e 85       	ldd	r18, Y+14	; 0x0e
    1014:	3f 85       	ldd	r19, Y+15	; 0x0f
    1016:	b9 01       	movw	r22, r18
    1018:	49 89       	ldd	r20, Y+17	; 0x11
    101a:	0e 94 ad 09 	call	0x135a	; 0x135a <prvTestWaitCondition>
    101e:	88 23       	and	r24, r24
    1020:	89 f0       	breq	.+34     	; 0x1044 <xEventGroupWaitBits+0x160>
                {
                    if( xClearOnExit != pdFALSE )
    1022:	88 89       	ldd	r24, Y+16	; 0x10
    1024:	88 23       	and	r24, r24
    1026:	71 f0       	breq	.+28     	; 0x1044 <xEventGroupWaitBits+0x160>
                    {
                        pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    1028:	ea 85       	ldd	r30, Y+10	; 0x0a
    102a:	fb 85       	ldd	r31, Y+11	; 0x0b
    102c:	20 81       	ld	r18, Z
    102e:	31 81       	ldd	r19, Z+1	; 0x01
    1030:	8e 85       	ldd	r24, Y+14	; 0x0e
    1032:	9f 85       	ldd	r25, Y+15	; 0x0f
    1034:	80 95       	com	r24
    1036:	90 95       	com	r25
    1038:	82 23       	and	r24, r18
    103a:	93 23       	and	r25, r19
    103c:	ea 85       	ldd	r30, Y+10	; 0x0a
    103e:	fb 85       	ldd	r31, Y+11	; 0x0b
    1040:	91 83       	std	Z+1, r25	; 0x01
    1042:	80 83       	st	Z, r24
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                xTimeoutOccurred = pdTRUE;
    1044:	81 e0       	ldi	r24, 0x01	; 1
    1046:	8b 83       	std	Y+3, r24	; 0x03
            }
            taskEXIT_CRITICAL();
    1048:	0f 90       	pop	r0
    104a:	0f be       	out	0x3f, r0	; 63
        {
            /* The task unblocked because the bits were set. */
        }

        /* The task blocked so control bits may have been set. */
        uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
    104c:	88 85       	ldd	r24, Y+8	; 0x08
    104e:	99 85       	ldd	r25, Y+9	; 0x09
    1050:	90 70       	andi	r25, 0x00	; 0
    1052:	99 87       	std	Y+9, r25	; 0x09
    1054:	88 87       	std	Y+8, r24	; 0x08
    traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );

    /* Prevent compiler warnings when trace macros are not used. */
    ( void ) xTimeoutOccurred;

    return uxReturn;
    1056:	88 85       	ldd	r24, Y+8	; 0x08
    1058:	99 85       	ldd	r25, Y+9	; 0x09
}
    105a:	63 96       	adiw	r28, 0x13	; 19
    105c:	0f b6       	in	r0, 0x3f	; 63
    105e:	f8 94       	cli
    1060:	de bf       	out	0x3e, r29	; 62
    1062:	0f be       	out	0x3f, r0	; 63
    1064:	cd bf       	out	0x3d, r28	; 61
    1066:	cf 91       	pop	r28
    1068:	df 91       	pop	r29
    106a:	1f 91       	pop	r17
    106c:	0f 91       	pop	r16
    106e:	08 95       	ret

00001070 <xEventGroupClearBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup,
                                  const EventBits_t uxBitsToClear )
{
    1070:	df 93       	push	r29
    1072:	cf 93       	push	r28
    1074:	cd b7       	in	r28, 0x3d	; 61
    1076:	de b7       	in	r29, 0x3e	; 62
    1078:	28 97       	sbiw	r28, 0x08	; 8
    107a:	0f b6       	in	r0, 0x3f	; 63
    107c:	f8 94       	cli
    107e:	de bf       	out	0x3e, r29	; 62
    1080:	0f be       	out	0x3f, r0	; 63
    1082:	cd bf       	out	0x3d, r28	; 61
    1084:	9e 83       	std	Y+6, r25	; 0x06
    1086:	8d 83       	std	Y+5, r24	; 0x05
    1088:	78 87       	std	Y+8, r23	; 0x08
    108a:	6f 83       	std	Y+7, r22	; 0x07
    EventGroup_t * pxEventBits = xEventGroup;
    108c:	8d 81       	ldd	r24, Y+5	; 0x05
    108e:	9e 81       	ldd	r25, Y+6	; 0x06
    1090:	9c 83       	std	Y+4, r25	; 0x04
    1092:	8b 83       	std	Y+3, r24	; 0x03
    /* Check the user is not attempting to clear the bits used by the kernel
     * itself. */
    configASSERT( xEventGroup );
    configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

    taskENTER_CRITICAL();
    1094:	0f b6       	in	r0, 0x3f	; 63
    1096:	f8 94       	cli
    1098:	0f 92       	push	r0
    {
        traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );

        /* The value returned is the event group value prior to the bits being
         * cleared. */
        uxReturn = pxEventBits->uxEventBits;
    109a:	eb 81       	ldd	r30, Y+3	; 0x03
    109c:	fc 81       	ldd	r31, Y+4	; 0x04
    109e:	80 81       	ld	r24, Z
    10a0:	91 81       	ldd	r25, Z+1	; 0x01
    10a2:	9a 83       	std	Y+2, r25	; 0x02
    10a4:	89 83       	std	Y+1, r24	; 0x01

        /* Clear the bits. */
        pxEventBits->uxEventBits &= ~uxBitsToClear;
    10a6:	eb 81       	ldd	r30, Y+3	; 0x03
    10a8:	fc 81       	ldd	r31, Y+4	; 0x04
    10aa:	20 81       	ld	r18, Z
    10ac:	31 81       	ldd	r19, Z+1	; 0x01
    10ae:	8f 81       	ldd	r24, Y+7	; 0x07
    10b0:	98 85       	ldd	r25, Y+8	; 0x08
    10b2:	80 95       	com	r24
    10b4:	90 95       	com	r25
    10b6:	82 23       	and	r24, r18
    10b8:	93 23       	and	r25, r19
    10ba:	eb 81       	ldd	r30, Y+3	; 0x03
    10bc:	fc 81       	ldd	r31, Y+4	; 0x04
    10be:	91 83       	std	Z+1, r25	; 0x01
    10c0:	80 83       	st	Z, r24
    }
    taskEXIT_CRITICAL();
    10c2:	0f 90       	pop	r0
    10c4:	0f be       	out	0x3f, r0	; 63

    return uxReturn;
    10c6:	89 81       	ldd	r24, Y+1	; 0x01
    10c8:	9a 81       	ldd	r25, Y+2	; 0x02
}
    10ca:	28 96       	adiw	r28, 0x08	; 8
    10cc:	0f b6       	in	r0, 0x3f	; 63
    10ce:	f8 94       	cli
    10d0:	de bf       	out	0x3e, r29	; 62
    10d2:	0f be       	out	0x3f, r0	; 63
    10d4:	cd bf       	out	0x3d, r28	; 61
    10d6:	cf 91       	pop	r28
    10d8:	df 91       	pop	r29
    10da:	08 95       	ret

000010dc <xEventGroupGetBitsFromISR>:

#endif /* if ( ( configUSE_TRACE_FACILITY == 1 ) && ( INCLUDE_xTimerPendFunctionCall == 1 ) && ( configUSE_TIMERS == 1 ) ) */
/*-----------------------------------------------------------*/

EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
{
    10dc:	df 93       	push	r29
    10de:	cf 93       	push	r28
    10e0:	cd b7       	in	r28, 0x3d	; 61
    10e2:	de b7       	in	r29, 0x3e	; 62
    10e4:	27 97       	sbiw	r28, 0x07	; 7
    10e6:	0f b6       	in	r0, 0x3f	; 63
    10e8:	f8 94       	cli
    10ea:	de bf       	out	0x3e, r29	; 62
    10ec:	0f be       	out	0x3f, r0	; 63
    10ee:	cd bf       	out	0x3d, r28	; 61
    10f0:	9f 83       	std	Y+7, r25	; 0x07
    10f2:	8e 83       	std	Y+6, r24	; 0x06
    UBaseType_t uxSavedInterruptStatus;
    EventGroup_t const * const pxEventBits = xEventGroup;
    10f4:	8e 81       	ldd	r24, Y+6	; 0x06
    10f6:	9f 81       	ldd	r25, Y+7	; 0x07
    10f8:	9c 83       	std	Y+4, r25	; 0x04
    10fa:	8b 83       	std	Y+3, r24	; 0x03
    EventBits_t uxReturn;

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    10fc:	1d 82       	std	Y+5, r1	; 0x05
    {
        uxReturn = pxEventBits->uxEventBits;
    10fe:	eb 81       	ldd	r30, Y+3	; 0x03
    1100:	fc 81       	ldd	r31, Y+4	; 0x04
    1102:	80 81       	ld	r24, Z
    1104:	91 81       	ldd	r25, Z+1	; 0x01
    1106:	9a 83       	std	Y+2, r25	; 0x02
    1108:	89 83       	std	Y+1, r24	; 0x01
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return uxReturn;
    110a:	89 81       	ldd	r24, Y+1	; 0x01
    110c:	9a 81       	ldd	r25, Y+2	; 0x02
} /*lint !e818 EventGroupHandle_t is a typedef used in other functions to so can't be pointer to const. */
    110e:	27 96       	adiw	r28, 0x07	; 7
    1110:	0f b6       	in	r0, 0x3f	; 63
    1112:	f8 94       	cli
    1114:	de bf       	out	0x3e, r29	; 62
    1116:	0f be       	out	0x3f, r0	; 63
    1118:	cd bf       	out	0x3d, r28	; 61
    111a:	cf 91       	pop	r28
    111c:	df 91       	pop	r29
    111e:	08 95       	ret

00001120 <xEventGroupSetBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup,
                                const EventBits_t uxBitsToSet )
{
    1120:	df 93       	push	r29
    1122:	cf 93       	push	r28
    1124:	cd b7       	in	r28, 0x3d	; 61
    1126:	de b7       	in	r29, 0x3e	; 62
    1128:	65 97       	sbiw	r28, 0x15	; 21
    112a:	0f b6       	in	r0, 0x3f	; 63
    112c:	f8 94       	cli
    112e:	de bf       	out	0x3e, r29	; 62
    1130:	0f be       	out	0x3f, r0	; 63
    1132:	cd bf       	out	0x3d, r28	; 61
    1134:	9b 8b       	std	Y+19, r25	; 0x13
    1136:	8a 8b       	std	Y+18, r24	; 0x12
    1138:	7d 8b       	std	Y+21, r23	; 0x15
    113a:	6c 8b       	std	Y+20, r22	; 0x14
    ListItem_t * pxListItem, * pxNext;
    ListItem_t const * pxListEnd;
    List_t const * pxList;
    EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
    113c:	19 86       	std	Y+9, r1	; 0x09
    113e:	18 86       	std	Y+8, r1	; 0x08
    EventGroup_t * pxEventBits = xEventGroup;
    1140:	8a 89       	ldd	r24, Y+18	; 0x12
    1142:	9b 89       	ldd	r25, Y+19	; 0x13
    1144:	9b 83       	std	Y+3, r25	; 0x03
    1146:	8a 83       	std	Y+2, r24	; 0x02
    BaseType_t xMatchFound = pdFALSE;
    1148:	19 82       	std	Y+1, r1	; 0x01
    /* Check the user is not attempting to set the bits used by the kernel
     * itself. */
    configASSERT( xEventGroup );
    configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

    pxList = &( pxEventBits->xTasksWaitingForBits );
    114a:	8a 81       	ldd	r24, Y+2	; 0x02
    114c:	9b 81       	ldd	r25, Y+3	; 0x03
    114e:	02 96       	adiw	r24, 0x02	; 2
    1150:	9b 87       	std	Y+11, r25	; 0x0b
    1152:	8a 87       	std	Y+10, r24	; 0x0a
    pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1154:	8a 85       	ldd	r24, Y+10	; 0x0a
    1156:	9b 85       	ldd	r25, Y+11	; 0x0b
    1158:	03 96       	adiw	r24, 0x03	; 3
    115a:	9d 87       	std	Y+13, r25	; 0x0d
    115c:	8c 87       	std	Y+12, r24	; 0x0c
    vTaskSuspendAll();
    115e:	0e 94 73 17 	call	0x2ee6	; 0x2ee6 <vTaskSuspendAll>
    {
        traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

        pxListItem = listGET_HEAD_ENTRY( pxList );
    1162:	ea 85       	ldd	r30, Y+10	; 0x0a
    1164:	fb 85       	ldd	r31, Y+11	; 0x0b
    1166:	85 81       	ldd	r24, Z+5	; 0x05
    1168:	96 81       	ldd	r25, Z+6	; 0x06
    116a:	99 8b       	std	Y+17, r25	; 0x11
    116c:	88 8b       	std	Y+16, r24	; 0x10

        /* Set the bits. */
        pxEventBits->uxEventBits |= uxBitsToSet;
    116e:	ea 81       	ldd	r30, Y+2	; 0x02
    1170:	fb 81       	ldd	r31, Y+3	; 0x03
    1172:	20 81       	ld	r18, Z
    1174:	31 81       	ldd	r19, Z+1	; 0x01
    1176:	8c 89       	ldd	r24, Y+20	; 0x14
    1178:	9d 89       	ldd	r25, Y+21	; 0x15
    117a:	82 2b       	or	r24, r18
    117c:	93 2b       	or	r25, r19
    117e:	ea 81       	ldd	r30, Y+2	; 0x02
    1180:	fb 81       	ldd	r31, Y+3	; 0x03
    1182:	91 83       	std	Z+1, r25	; 0x01
    1184:	80 83       	st	Z, r24
    1186:	59 c0       	rjmp	.+178    	; 0x123a <xEventGroupSetBits+0x11a>

        /* See if the new bit value should unblock any tasks. */
        while( pxListItem != pxListEnd )
        {
            pxNext = listGET_NEXT( pxListItem );
    1188:	e8 89       	ldd	r30, Y+16	; 0x10
    118a:	f9 89       	ldd	r31, Y+17	; 0x11
    118c:	82 81       	ldd	r24, Z+2	; 0x02
    118e:	93 81       	ldd	r25, Z+3	; 0x03
    1190:	9f 87       	std	Y+15, r25	; 0x0f
    1192:	8e 87       	std	Y+14, r24	; 0x0e
            uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
    1194:	e8 89       	ldd	r30, Y+16	; 0x10
    1196:	f9 89       	ldd	r31, Y+17	; 0x11
    1198:	80 81       	ld	r24, Z
    119a:	91 81       	ldd	r25, Z+1	; 0x01
    119c:	9f 83       	std	Y+7, r25	; 0x07
    119e:	8e 83       	std	Y+6, r24	; 0x06
            xMatchFound = pdFALSE;
    11a0:	19 82       	std	Y+1, r1	; 0x01

            /* Split the bits waited for from the control bits. */
            uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
    11a2:	8e 81       	ldd	r24, Y+6	; 0x06
    11a4:	9f 81       	ldd	r25, Y+7	; 0x07
    11a6:	80 70       	andi	r24, 0x00	; 0
    11a8:	9d 83       	std	Y+5, r25	; 0x05
    11aa:	8c 83       	std	Y+4, r24	; 0x04
            uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
    11ac:	8e 81       	ldd	r24, Y+6	; 0x06
    11ae:	9f 81       	ldd	r25, Y+7	; 0x07
    11b0:	90 70       	andi	r25, 0x00	; 0
    11b2:	9f 83       	std	Y+7, r25	; 0x07
    11b4:	8e 83       	std	Y+6, r24	; 0x06

            if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
    11b6:	8c 81       	ldd	r24, Y+4	; 0x04
    11b8:	9d 81       	ldd	r25, Y+5	; 0x05
    11ba:	80 70       	andi	r24, 0x00	; 0
    11bc:	94 70       	andi	r25, 0x04	; 4
    11be:	00 97       	sbiw	r24, 0x00	; 0
    11c0:	69 f4       	brne	.+26     	; 0x11dc <xEventGroupSetBits+0xbc>
            {
                /* Just looking for single bit being set. */
                if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
    11c2:	ea 81       	ldd	r30, Y+2	; 0x02
    11c4:	fb 81       	ldd	r31, Y+3	; 0x03
    11c6:	20 81       	ld	r18, Z
    11c8:	31 81       	ldd	r19, Z+1	; 0x01
    11ca:	8e 81       	ldd	r24, Y+6	; 0x06
    11cc:	9f 81       	ldd	r25, Y+7	; 0x07
    11ce:	82 23       	and	r24, r18
    11d0:	93 23       	and	r25, r19
    11d2:	00 97       	sbiw	r24, 0x00	; 0
    11d4:	91 f0       	breq	.+36     	; 0x11fa <xEventGroupSetBits+0xda>
                {
                    xMatchFound = pdTRUE;
    11d6:	81 e0       	ldi	r24, 0x01	; 1
    11d8:	89 83       	std	Y+1, r24	; 0x01
    11da:	0f c0       	rjmp	.+30     	; 0x11fa <xEventGroupSetBits+0xda>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
    11dc:	ea 81       	ldd	r30, Y+2	; 0x02
    11de:	fb 81       	ldd	r31, Y+3	; 0x03
    11e0:	20 81       	ld	r18, Z
    11e2:	31 81       	ldd	r19, Z+1	; 0x01
    11e4:	8e 81       	ldd	r24, Y+6	; 0x06
    11e6:	9f 81       	ldd	r25, Y+7	; 0x07
    11e8:	28 23       	and	r18, r24
    11ea:	39 23       	and	r19, r25
    11ec:	8e 81       	ldd	r24, Y+6	; 0x06
    11ee:	9f 81       	ldd	r25, Y+7	; 0x07
    11f0:	28 17       	cp	r18, r24
    11f2:	39 07       	cpc	r19, r25
    11f4:	11 f4       	brne	.+4      	; 0x11fa <xEventGroupSetBits+0xda>
            {
                /* All bits are set. */
                xMatchFound = pdTRUE;
    11f6:	81 e0       	ldi	r24, 0x01	; 1
    11f8:	89 83       	std	Y+1, r24	; 0x01
            else
            {
                /* Need all bits to be set, but not all the bits were set. */
            }

            if( xMatchFound != pdFALSE )
    11fa:	89 81       	ldd	r24, Y+1	; 0x01
    11fc:	88 23       	and	r24, r24
    11fe:	c9 f0       	breq	.+50     	; 0x1232 <xEventGroupSetBits+0x112>
            {
                /* The bits match.  Should the bits be cleared on exit? */
                if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
    1200:	8c 81       	ldd	r24, Y+4	; 0x04
    1202:	9d 81       	ldd	r25, Y+5	; 0x05
    1204:	80 70       	andi	r24, 0x00	; 0
    1206:	91 70       	andi	r25, 0x01	; 1
    1208:	00 97       	sbiw	r24, 0x00	; 0
    120a:	41 f0       	breq	.+16     	; 0x121c <xEventGroupSetBits+0xfc>
                {
                    uxBitsToClear |= uxBitsWaitedFor;
    120c:	88 85       	ldd	r24, Y+8	; 0x08
    120e:	99 85       	ldd	r25, Y+9	; 0x09
    1210:	2e 81       	ldd	r18, Y+6	; 0x06
    1212:	3f 81       	ldd	r19, Y+7	; 0x07
    1214:	82 2b       	or	r24, r18
    1216:	93 2b       	or	r25, r19
    1218:	99 87       	std	Y+9, r25	; 0x09
    121a:	88 87       	std	Y+8, r24	; 0x08
                /* Store the actual event flag value in the task's event list
                 * item before removing the task from the event list.  The
                 * eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
                 * that is was unblocked due to its required bits matching, rather
                 * than because it timed out. */
                vTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
    121c:	ea 81       	ldd	r30, Y+2	; 0x02
    121e:	fb 81       	ldd	r31, Y+3	; 0x03
    1220:	80 81       	ld	r24, Z
    1222:	91 81       	ldd	r25, Z+1	; 0x01
    1224:	9c 01       	movw	r18, r24
    1226:	32 60       	ori	r19, 0x02	; 2
    1228:	88 89       	ldd	r24, Y+16	; 0x10
    122a:	99 89       	ldd	r25, Y+17	; 0x11
    122c:	b9 01       	movw	r22, r18
    122e:	0e 94 1b 1d 	call	0x3a36	; 0x3a36 <vTaskRemoveFromUnorderedEventList>
            }

            /* Move onto the next list item.  Note pxListItem->pxNext is not
             * used here as the list item may have been removed from the event list
             * and inserted into the ready/pending reading list. */
            pxListItem = pxNext;
    1232:	8e 85       	ldd	r24, Y+14	; 0x0e
    1234:	9f 85       	ldd	r25, Y+15	; 0x0f
    1236:	99 8b       	std	Y+17, r25	; 0x11
    1238:	88 8b       	std	Y+16, r24	; 0x10

        /* Set the bits. */
        pxEventBits->uxEventBits |= uxBitsToSet;

        /* See if the new bit value should unblock any tasks. */
        while( pxListItem != pxListEnd )
    123a:	28 89       	ldd	r18, Y+16	; 0x10
    123c:	39 89       	ldd	r19, Y+17	; 0x11
    123e:	8c 85       	ldd	r24, Y+12	; 0x0c
    1240:	9d 85       	ldd	r25, Y+13	; 0x0d
    1242:	28 17       	cp	r18, r24
    1244:	39 07       	cpc	r19, r25
    1246:	09 f0       	breq	.+2      	; 0x124a <xEventGroupSetBits+0x12a>
    1248:	9f cf       	rjmp	.-194    	; 0x1188 <xEventGroupSetBits+0x68>
            pxListItem = pxNext;
        }

        /* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
         * bit was set in the control word. */
        pxEventBits->uxEventBits &= ~uxBitsToClear;
    124a:	ea 81       	ldd	r30, Y+2	; 0x02
    124c:	fb 81       	ldd	r31, Y+3	; 0x03
    124e:	20 81       	ld	r18, Z
    1250:	31 81       	ldd	r19, Z+1	; 0x01
    1252:	88 85       	ldd	r24, Y+8	; 0x08
    1254:	99 85       	ldd	r25, Y+9	; 0x09
    1256:	80 95       	com	r24
    1258:	90 95       	com	r25
    125a:	82 23       	and	r24, r18
    125c:	93 23       	and	r25, r19
    125e:	ea 81       	ldd	r30, Y+2	; 0x02
    1260:	fb 81       	ldd	r31, Y+3	; 0x03
    1262:	91 83       	std	Z+1, r25	; 0x01
    1264:	80 83       	st	Z, r24
    }
    ( void ) xTaskResumeAll();
    1266:	0e 94 7f 17 	call	0x2efe	; 0x2efe <xTaskResumeAll>

    return pxEventBits->uxEventBits;
    126a:	ea 81       	ldd	r30, Y+2	; 0x02
    126c:	fb 81       	ldd	r31, Y+3	; 0x03
    126e:	80 81       	ld	r24, Z
    1270:	91 81       	ldd	r25, Z+1	; 0x01
}
    1272:	65 96       	adiw	r28, 0x15	; 21
    1274:	0f b6       	in	r0, 0x3f	; 63
    1276:	f8 94       	cli
    1278:	de bf       	out	0x3e, r29	; 62
    127a:	0f be       	out	0x3f, r0	; 63
    127c:	cd bf       	out	0x3d, r28	; 61
    127e:	cf 91       	pop	r28
    1280:	df 91       	pop	r29
    1282:	08 95       	ret

00001284 <vEventGroupDelete>:
/*-----------------------------------------------------------*/

void vEventGroupDelete( EventGroupHandle_t xEventGroup )
{
    1284:	df 93       	push	r29
    1286:	cf 93       	push	r28
    1288:	00 d0       	rcall	.+0      	; 0x128a <vEventGroupDelete+0x6>
    128a:	00 d0       	rcall	.+0      	; 0x128c <vEventGroupDelete+0x8>
    128c:	00 d0       	rcall	.+0      	; 0x128e <vEventGroupDelete+0xa>
    128e:	cd b7       	in	r28, 0x3d	; 61
    1290:	de b7       	in	r29, 0x3e	; 62
    1292:	9e 83       	std	Y+6, r25	; 0x06
    1294:	8d 83       	std	Y+5, r24	; 0x05
    EventGroup_t * pxEventBits = xEventGroup;
    1296:	8d 81       	ldd	r24, Y+5	; 0x05
    1298:	9e 81       	ldd	r25, Y+6	; 0x06
    129a:	9c 83       	std	Y+4, r25	; 0x04
    129c:	8b 83       	std	Y+3, r24	; 0x03
    const List_t * pxTasksWaitingForBits;

    configASSERT( pxEventBits );

    pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );
    129e:	8b 81       	ldd	r24, Y+3	; 0x03
    12a0:	9c 81       	ldd	r25, Y+4	; 0x04
    12a2:	02 96       	adiw	r24, 0x02	; 2
    12a4:	9a 83       	std	Y+2, r25	; 0x02
    12a6:	89 83       	std	Y+1, r24	; 0x01

    vTaskSuspendAll();
    12a8:	0e 94 73 17 	call	0x2ee6	; 0x2ee6 <vTaskSuspendAll>
    12ac:	08 c0       	rjmp	.+16     	; 0x12be <vEventGroupDelete+0x3a>
        while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
        {
            /* Unblock the task, returning 0 as the event list is being deleted
             * and cannot therefore have any bits set. */
            configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( const ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
            vTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
    12ae:	e9 81       	ldd	r30, Y+1	; 0x01
    12b0:	fa 81       	ldd	r31, Y+2	; 0x02
    12b2:	85 81       	ldd	r24, Z+5	; 0x05
    12b4:	96 81       	ldd	r25, Z+6	; 0x06
    12b6:	60 e0       	ldi	r22, 0x00	; 0
    12b8:	72 e0       	ldi	r23, 0x02	; 2
    12ba:	0e 94 1b 1d 	call	0x3a36	; 0x3a36 <vTaskRemoveFromUnorderedEventList>

    vTaskSuspendAll();
    {
        traceEVENT_GROUP_DELETE( xEventGroup );

        while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
    12be:	e9 81       	ldd	r30, Y+1	; 0x01
    12c0:	fa 81       	ldd	r31, Y+2	; 0x02
    12c2:	80 81       	ld	r24, Z
    12c4:	88 23       	and	r24, r24
    12c6:	99 f7       	brne	.-26     	; 0x12ae <vEventGroupDelete+0x2a>

        #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
            {
                /* The event group can only have been allocated dynamically - free
                 * it again. */
                vPortFree( pxEventBits );
    12c8:	8b 81       	ldd	r24, Y+3	; 0x03
    12ca:	9c 81       	ldd	r25, Y+4	; 0x04
    12cc:	0e 94 c1 00 	call	0x182	; 0x182 <vPortFree>
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
    }
    ( void ) xTaskResumeAll();
    12d0:	0e 94 7f 17 	call	0x2efe	; 0x2efe <xTaskResumeAll>
}
    12d4:	26 96       	adiw	r28, 0x06	; 6
    12d6:	0f b6       	in	r0, 0x3f	; 63
    12d8:	f8 94       	cli
    12da:	de bf       	out	0x3e, r29	; 62
    12dc:	0f be       	out	0x3f, r0	; 63
    12de:	cd bf       	out	0x3d, r28	; 61
    12e0:	cf 91       	pop	r28
    12e2:	df 91       	pop	r29
    12e4:	08 95       	ret

000012e6 <vEventGroupSetBitsCallback>:

/* For internal use only - execute a 'set bits' command that was pended from
 * an interrupt. */
void vEventGroupSetBitsCallback( void * pvEventGroup,
                                 const uint32_t ulBitsToSet )
{
    12e6:	df 93       	push	r29
    12e8:	cf 93       	push	r28
    12ea:	00 d0       	rcall	.+0      	; 0x12ec <vEventGroupSetBitsCallback+0x6>
    12ec:	00 d0       	rcall	.+0      	; 0x12ee <vEventGroupSetBitsCallback+0x8>
    12ee:	00 d0       	rcall	.+0      	; 0x12f0 <vEventGroupSetBitsCallback+0xa>
    12f0:	cd b7       	in	r28, 0x3d	; 61
    12f2:	de b7       	in	r29, 0x3e	; 62
    12f4:	9a 83       	std	Y+2, r25	; 0x02
    12f6:	89 83       	std	Y+1, r24	; 0x01
    12f8:	4b 83       	std	Y+3, r20	; 0x03
    12fa:	5c 83       	std	Y+4, r21	; 0x04
    12fc:	6d 83       	std	Y+5, r22	; 0x05
    12fe:	7e 83       	std	Y+6, r23	; 0x06
    ( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
    1300:	89 81       	ldd	r24, Y+1	; 0x01
    1302:	9a 81       	ldd	r25, Y+2	; 0x02
    1304:	2b 81       	ldd	r18, Y+3	; 0x03
    1306:	3c 81       	ldd	r19, Y+4	; 0x04
    1308:	b9 01       	movw	r22, r18
    130a:	0e 94 90 08 	call	0x1120	; 0x1120 <xEventGroupSetBits>
}
    130e:	26 96       	adiw	r28, 0x06	; 6
    1310:	0f b6       	in	r0, 0x3f	; 63
    1312:	f8 94       	cli
    1314:	de bf       	out	0x3e, r29	; 62
    1316:	0f be       	out	0x3f, r0	; 63
    1318:	cd bf       	out	0x3d, r28	; 61
    131a:	cf 91       	pop	r28
    131c:	df 91       	pop	r29
    131e:	08 95       	ret

00001320 <vEventGroupClearBitsCallback>:

/* For internal use only - execute a 'clear bits' command that was pended from
 * an interrupt. */
void vEventGroupClearBitsCallback( void * pvEventGroup,
                                   const uint32_t ulBitsToClear )
{
    1320:	df 93       	push	r29
    1322:	cf 93       	push	r28
    1324:	00 d0       	rcall	.+0      	; 0x1326 <vEventGroupClearBitsCallback+0x6>
    1326:	00 d0       	rcall	.+0      	; 0x1328 <vEventGroupClearBitsCallback+0x8>
    1328:	00 d0       	rcall	.+0      	; 0x132a <vEventGroupClearBitsCallback+0xa>
    132a:	cd b7       	in	r28, 0x3d	; 61
    132c:	de b7       	in	r29, 0x3e	; 62
    132e:	9a 83       	std	Y+2, r25	; 0x02
    1330:	89 83       	std	Y+1, r24	; 0x01
    1332:	4b 83       	std	Y+3, r20	; 0x03
    1334:	5c 83       	std	Y+4, r21	; 0x04
    1336:	6d 83       	std	Y+5, r22	; 0x05
    1338:	7e 83       	std	Y+6, r23	; 0x06
    ( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
    133a:	89 81       	ldd	r24, Y+1	; 0x01
    133c:	9a 81       	ldd	r25, Y+2	; 0x02
    133e:	2b 81       	ldd	r18, Y+3	; 0x03
    1340:	3c 81       	ldd	r19, Y+4	; 0x04
    1342:	b9 01       	movw	r22, r18
    1344:	0e 94 38 08 	call	0x1070	; 0x1070 <xEventGroupClearBits>
}
    1348:	26 96       	adiw	r28, 0x06	; 6
    134a:	0f b6       	in	r0, 0x3f	; 63
    134c:	f8 94       	cli
    134e:	de bf       	out	0x3e, r29	; 62
    1350:	0f be       	out	0x3f, r0	; 63
    1352:	cd bf       	out	0x3d, r28	; 61
    1354:	cf 91       	pop	r28
    1356:	df 91       	pop	r29
    1358:	08 95       	ret

0000135a <prvTestWaitCondition>:
/*-----------------------------------------------------------*/

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits,
                                        const EventBits_t uxBitsToWaitFor,
                                        const BaseType_t xWaitForAllBits )
{
    135a:	df 93       	push	r29
    135c:	cf 93       	push	r28
    135e:	00 d0       	rcall	.+0      	; 0x1360 <prvTestWaitCondition+0x6>
    1360:	00 d0       	rcall	.+0      	; 0x1362 <prvTestWaitCondition+0x8>
    1362:	00 d0       	rcall	.+0      	; 0x1364 <prvTestWaitCondition+0xa>
    1364:	cd b7       	in	r28, 0x3d	; 61
    1366:	de b7       	in	r29, 0x3e	; 62
    1368:	9b 83       	std	Y+3, r25	; 0x03
    136a:	8a 83       	std	Y+2, r24	; 0x02
    136c:	7d 83       	std	Y+5, r23	; 0x05
    136e:	6c 83       	std	Y+4, r22	; 0x04
    1370:	4e 83       	std	Y+6, r20	; 0x06
    BaseType_t xWaitConditionMet = pdFALSE;
    1372:	19 82       	std	Y+1, r1	; 0x01

    if( xWaitForAllBits == pdFALSE )
    1374:	8e 81       	ldd	r24, Y+6	; 0x06
    1376:	88 23       	and	r24, r24
    1378:	59 f4       	brne	.+22     	; 0x1390 <prvTestWaitCondition+0x36>
    {
        /* Task only has to wait for one bit within uxBitsToWaitFor to be
         * set.  Is one already set? */
        if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
    137a:	8a 81       	ldd	r24, Y+2	; 0x02
    137c:	9b 81       	ldd	r25, Y+3	; 0x03
    137e:	2c 81       	ldd	r18, Y+4	; 0x04
    1380:	3d 81       	ldd	r19, Y+5	; 0x05
    1382:	82 23       	and	r24, r18
    1384:	93 23       	and	r25, r19
    1386:	00 97       	sbiw	r24, 0x00	; 0
    1388:	81 f0       	breq	.+32     	; 0x13aa <prvTestWaitCondition+0x50>
        {
            xWaitConditionMet = pdTRUE;
    138a:	81 e0       	ldi	r24, 0x01	; 1
    138c:	89 83       	std	Y+1, r24	; 0x01
    138e:	0d c0       	rjmp	.+26     	; 0x13aa <prvTestWaitCondition+0x50>
    }
    else
    {
        /* Task has to wait for all the bits in uxBitsToWaitFor to be set.
         * Are they set already? */
        if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
    1390:	2a 81       	ldd	r18, Y+2	; 0x02
    1392:	3b 81       	ldd	r19, Y+3	; 0x03
    1394:	8c 81       	ldd	r24, Y+4	; 0x04
    1396:	9d 81       	ldd	r25, Y+5	; 0x05
    1398:	28 23       	and	r18, r24
    139a:	39 23       	and	r19, r25
    139c:	8c 81       	ldd	r24, Y+4	; 0x04
    139e:	9d 81       	ldd	r25, Y+5	; 0x05
    13a0:	28 17       	cp	r18, r24
    13a2:	39 07       	cpc	r19, r25
    13a4:	11 f4       	brne	.+4      	; 0x13aa <prvTestWaitCondition+0x50>
        {
            xWaitConditionMet = pdTRUE;
    13a6:	81 e0       	ldi	r24, 0x01	; 1
    13a8:	89 83       	std	Y+1, r24	; 0x01
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }

    return xWaitConditionMet;
    13aa:	89 81       	ldd	r24, Y+1	; 0x01
}
    13ac:	26 96       	adiw	r28, 0x06	; 6
    13ae:	0f b6       	in	r0, 0x3f	; 63
    13b0:	f8 94       	cli
    13b2:	de bf       	out	0x3e, r29	; 62
    13b4:	0f be       	out	0x3f, r0	; 63
    13b6:	cd bf       	out	0x3d, r28	; 61
    13b8:	cf 91       	pop	r28
    13ba:	df 91       	pop	r29
    13bc:	08 95       	ret

000013be <vListInitialise>:
/*-----------------------------------------------------------
* PUBLIC LIST API documented in list.h
*----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    13be:	df 93       	push	r29
    13c0:	cf 93       	push	r28
    13c2:	00 d0       	rcall	.+0      	; 0x13c4 <vListInitialise+0x6>
    13c4:	cd b7       	in	r28, 0x3d	; 61
    13c6:	de b7       	in	r29, 0x3e	; 62
    13c8:	9a 83       	std	Y+2, r25	; 0x02
    13ca:	89 83       	std	Y+1, r24	; 0x01
    /* The list structure contains a list item which is used to mark the
     * end of the list.  To initialise the list the list end is inserted
     * as the only list entry. */
    pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    13cc:	89 81       	ldd	r24, Y+1	; 0x01
    13ce:	9a 81       	ldd	r25, Y+2	; 0x02
    13d0:	03 96       	adiw	r24, 0x03	; 3
    13d2:	e9 81       	ldd	r30, Y+1	; 0x01
    13d4:	fa 81       	ldd	r31, Y+2	; 0x02
    13d6:	92 83       	std	Z+2, r25	; 0x02
    13d8:	81 83       	std	Z+1, r24	; 0x01

    /* The list end value is the highest possible value in the list to
     * ensure it remains at the end of the list. */
    pxList->xListEnd.xItemValue = portMAX_DELAY;
    13da:	e9 81       	ldd	r30, Y+1	; 0x01
    13dc:	fa 81       	ldd	r31, Y+2	; 0x02
    13de:	8f ef       	ldi	r24, 0xFF	; 255
    13e0:	9f ef       	ldi	r25, 0xFF	; 255
    13e2:	94 83       	std	Z+4, r25	; 0x04
    13e4:	83 83       	std	Z+3, r24	; 0x03

    /* The list end next and previous pointers point to itself so we know
     * when the list is empty. */
    pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );     /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    13e6:	89 81       	ldd	r24, Y+1	; 0x01
    13e8:	9a 81       	ldd	r25, Y+2	; 0x02
    13ea:	03 96       	adiw	r24, 0x03	; 3
    13ec:	e9 81       	ldd	r30, Y+1	; 0x01
    13ee:	fa 81       	ldd	r31, Y+2	; 0x02
    13f0:	96 83       	std	Z+6, r25	; 0x06
    13f2:	85 83       	std	Z+5, r24	; 0x05
    pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    13f4:	89 81       	ldd	r24, Y+1	; 0x01
    13f6:	9a 81       	ldd	r25, Y+2	; 0x02
    13f8:	03 96       	adiw	r24, 0x03	; 3
    13fa:	e9 81       	ldd	r30, Y+1	; 0x01
    13fc:	fa 81       	ldd	r31, Y+2	; 0x02
    13fe:	90 87       	std	Z+8, r25	; 0x08
    1400:	87 83       	std	Z+7, r24	; 0x07

    pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    1402:	e9 81       	ldd	r30, Y+1	; 0x01
    1404:	fa 81       	ldd	r31, Y+2	; 0x02
    1406:	10 82       	st	Z, r1

    /* Write known values into the list if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
    listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
    1408:	0f 90       	pop	r0
    140a:	0f 90       	pop	r0
    140c:	cf 91       	pop	r28
    140e:	df 91       	pop	r29
    1410:	08 95       	ret

00001412 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    1412:	df 93       	push	r29
    1414:	cf 93       	push	r28
    1416:	00 d0       	rcall	.+0      	; 0x1418 <vListInitialiseItem+0x6>
    1418:	cd b7       	in	r28, 0x3d	; 61
    141a:	de b7       	in	r29, 0x3e	; 62
    141c:	9a 83       	std	Y+2, r25	; 0x02
    141e:	89 83       	std	Y+1, r24	; 0x01
    /* Make sure the list item is not recorded as being on a list. */
    pxItem->pxContainer = NULL;
    1420:	e9 81       	ldd	r30, Y+1	; 0x01
    1422:	fa 81       	ldd	r31, Y+2	; 0x02
    1424:	11 86       	std	Z+9, r1	; 0x09
    1426:	10 86       	std	Z+8, r1	; 0x08

    /* Write known values into the list item if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
    listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
    1428:	0f 90       	pop	r0
    142a:	0f 90       	pop	r0
    142c:	cf 91       	pop	r28
    142e:	df 91       	pop	r29
    1430:	08 95       	ret

00001432 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList,
                     ListItem_t * const pxNewListItem )
{
    1432:	df 93       	push	r29
    1434:	cf 93       	push	r28
    1436:	00 d0       	rcall	.+0      	; 0x1438 <vListInsertEnd+0x6>
    1438:	00 d0       	rcall	.+0      	; 0x143a <vListInsertEnd+0x8>
    143a:	00 d0       	rcall	.+0      	; 0x143c <vListInsertEnd+0xa>
    143c:	cd b7       	in	r28, 0x3d	; 61
    143e:	de b7       	in	r29, 0x3e	; 62
    1440:	9c 83       	std	Y+4, r25	; 0x04
    1442:	8b 83       	std	Y+3, r24	; 0x03
    1444:	7e 83       	std	Y+6, r23	; 0x06
    1446:	6d 83       	std	Y+5, r22	; 0x05
    ListItem_t * const pxIndex = pxList->pxIndex;
    1448:	eb 81       	ldd	r30, Y+3	; 0x03
    144a:	fc 81       	ldd	r31, Y+4	; 0x04
    144c:	81 81       	ldd	r24, Z+1	; 0x01
    144e:	92 81       	ldd	r25, Z+2	; 0x02
    1450:	9a 83       	std	Y+2, r25	; 0x02
    1452:	89 83       	std	Y+1, r24	; 0x01
    listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

    /* Insert a new list item into pxList, but rather than sort the list,
     * makes the new list item the last item to be removed by a call to
     * listGET_OWNER_OF_NEXT_ENTRY(). */
    pxNewListItem->pxNext = pxIndex;
    1454:	ed 81       	ldd	r30, Y+5	; 0x05
    1456:	fe 81       	ldd	r31, Y+6	; 0x06
    1458:	89 81       	ldd	r24, Y+1	; 0x01
    145a:	9a 81       	ldd	r25, Y+2	; 0x02
    145c:	93 83       	std	Z+3, r25	; 0x03
    145e:	82 83       	std	Z+2, r24	; 0x02
    pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    1460:	e9 81       	ldd	r30, Y+1	; 0x01
    1462:	fa 81       	ldd	r31, Y+2	; 0x02
    1464:	84 81       	ldd	r24, Z+4	; 0x04
    1466:	95 81       	ldd	r25, Z+5	; 0x05
    1468:	ed 81       	ldd	r30, Y+5	; 0x05
    146a:	fe 81       	ldd	r31, Y+6	; 0x06
    146c:	95 83       	std	Z+5, r25	; 0x05
    146e:	84 83       	std	Z+4, r24	; 0x04

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    pxIndex->pxPrevious->pxNext = pxNewListItem;
    1470:	e9 81       	ldd	r30, Y+1	; 0x01
    1472:	fa 81       	ldd	r31, Y+2	; 0x02
    1474:	04 80       	ldd	r0, Z+4	; 0x04
    1476:	f5 81       	ldd	r31, Z+5	; 0x05
    1478:	e0 2d       	mov	r30, r0
    147a:	8d 81       	ldd	r24, Y+5	; 0x05
    147c:	9e 81       	ldd	r25, Y+6	; 0x06
    147e:	93 83       	std	Z+3, r25	; 0x03
    1480:	82 83       	std	Z+2, r24	; 0x02
    pxIndex->pxPrevious = pxNewListItem;
    1482:	e9 81       	ldd	r30, Y+1	; 0x01
    1484:	fa 81       	ldd	r31, Y+2	; 0x02
    1486:	8d 81       	ldd	r24, Y+5	; 0x05
    1488:	9e 81       	ldd	r25, Y+6	; 0x06
    148a:	95 83       	std	Z+5, r25	; 0x05
    148c:	84 83       	std	Z+4, r24	; 0x04

    /* Remember which list the item is in. */
    pxNewListItem->pxContainer = pxList;
    148e:	ed 81       	ldd	r30, Y+5	; 0x05
    1490:	fe 81       	ldd	r31, Y+6	; 0x06
    1492:	8b 81       	ldd	r24, Y+3	; 0x03
    1494:	9c 81       	ldd	r25, Y+4	; 0x04
    1496:	91 87       	std	Z+9, r25	; 0x09
    1498:	80 87       	std	Z+8, r24	; 0x08

    ( pxList->uxNumberOfItems )++;
    149a:	eb 81       	ldd	r30, Y+3	; 0x03
    149c:	fc 81       	ldd	r31, Y+4	; 0x04
    149e:	80 81       	ld	r24, Z
    14a0:	8f 5f       	subi	r24, 0xFF	; 255
    14a2:	eb 81       	ldd	r30, Y+3	; 0x03
    14a4:	fc 81       	ldd	r31, Y+4	; 0x04
    14a6:	80 83       	st	Z, r24
}
    14a8:	26 96       	adiw	r28, 0x06	; 6
    14aa:	0f b6       	in	r0, 0x3f	; 63
    14ac:	f8 94       	cli
    14ae:	de bf       	out	0x3e, r29	; 62
    14b0:	0f be       	out	0x3f, r0	; 63
    14b2:	cd bf       	out	0x3d, r28	; 61
    14b4:	cf 91       	pop	r28
    14b6:	df 91       	pop	r29
    14b8:	08 95       	ret

000014ba <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList,
                  ListItem_t * const pxNewListItem )
{
    14ba:	df 93       	push	r29
    14bc:	cf 93       	push	r28
    14be:	cd b7       	in	r28, 0x3d	; 61
    14c0:	de b7       	in	r29, 0x3e	; 62
    14c2:	28 97       	sbiw	r28, 0x08	; 8
    14c4:	0f b6       	in	r0, 0x3f	; 63
    14c6:	f8 94       	cli
    14c8:	de bf       	out	0x3e, r29	; 62
    14ca:	0f be       	out	0x3f, r0	; 63
    14cc:	cd bf       	out	0x3d, r28	; 61
    14ce:	9e 83       	std	Y+6, r25	; 0x06
    14d0:	8d 83       	std	Y+5, r24	; 0x05
    14d2:	78 87       	std	Y+8, r23	; 0x08
    14d4:	6f 83       	std	Y+7, r22	; 0x07
    ListItem_t * pxIterator;
    const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    14d6:	ef 81       	ldd	r30, Y+7	; 0x07
    14d8:	f8 85       	ldd	r31, Y+8	; 0x08
    14da:	80 81       	ld	r24, Z
    14dc:	91 81       	ldd	r25, Z+1	; 0x01
    14de:	9a 83       	std	Y+2, r25	; 0x02
    14e0:	89 83       	std	Y+1, r24	; 0x01
     * new list item should be placed after it.  This ensures that TCBs which are
     * stored in ready lists (all of which have the same xItemValue value) get a
     * share of the CPU.  However, if the xItemValue is the same as the back marker
     * the iteration loop below will not end.  Therefore the value is checked
     * first, and the algorithm slightly modified if necessary. */
    if( xValueOfInsertion == portMAX_DELAY )
    14e2:	89 81       	ldd	r24, Y+1	; 0x01
    14e4:	9a 81       	ldd	r25, Y+2	; 0x02
    14e6:	2f ef       	ldi	r18, 0xFF	; 255
    14e8:	8f 3f       	cpi	r24, 0xFF	; 255
    14ea:	92 07       	cpc	r25, r18
    14ec:	39 f4       	brne	.+14     	; 0x14fc <vListInsert+0x42>
    {
        pxIterator = pxList->xListEnd.pxPrevious;
    14ee:	ed 81       	ldd	r30, Y+5	; 0x05
    14f0:	fe 81       	ldd	r31, Y+6	; 0x06
    14f2:	87 81       	ldd	r24, Z+7	; 0x07
    14f4:	90 85       	ldd	r25, Z+8	; 0x08
    14f6:	9c 83       	std	Y+4, r25	; 0x04
    14f8:	8b 83       	std	Y+3, r24	; 0x03
    14fa:	18 c0       	rjmp	.+48     	; 0x152c <vListInsert+0x72>
        *   5) If the FreeRTOS port supports interrupt nesting then ensure that
        *      the priority of the tick interrupt is at or below
        *      configMAX_SYSCALL_INTERRUPT_PRIORITY.
        **********************************************************************/

        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    14fc:	8d 81       	ldd	r24, Y+5	; 0x05
    14fe:	9e 81       	ldd	r25, Y+6	; 0x06
    1500:	03 96       	adiw	r24, 0x03	; 3
    1502:	9c 83       	std	Y+4, r25	; 0x04
    1504:	8b 83       	std	Y+3, r24	; 0x03
    1506:	06 c0       	rjmp	.+12     	; 0x1514 <vListInsert+0x5a>
    1508:	eb 81       	ldd	r30, Y+3	; 0x03
    150a:	fc 81       	ldd	r31, Y+4	; 0x04
    150c:	82 81       	ldd	r24, Z+2	; 0x02
    150e:	93 81       	ldd	r25, Z+3	; 0x03
    1510:	9c 83       	std	Y+4, r25	; 0x04
    1512:	8b 83       	std	Y+3, r24	; 0x03
    1514:	eb 81       	ldd	r30, Y+3	; 0x03
    1516:	fc 81       	ldd	r31, Y+4	; 0x04
    1518:	02 80       	ldd	r0, Z+2	; 0x02
    151a:	f3 81       	ldd	r31, Z+3	; 0x03
    151c:	e0 2d       	mov	r30, r0
    151e:	20 81       	ld	r18, Z
    1520:	31 81       	ldd	r19, Z+1	; 0x01
    1522:	89 81       	ldd	r24, Y+1	; 0x01
    1524:	9a 81       	ldd	r25, Y+2	; 0x02
    1526:	82 17       	cp	r24, r18
    1528:	93 07       	cpc	r25, r19
    152a:	70 f7       	brcc	.-36     	; 0x1508 <vListInsert+0x4e>
            /* There is nothing to do here, just iterating to the wanted
             * insertion position. */
        }
    }

    pxNewListItem->pxNext = pxIterator->pxNext;
    152c:	eb 81       	ldd	r30, Y+3	; 0x03
    152e:	fc 81       	ldd	r31, Y+4	; 0x04
    1530:	82 81       	ldd	r24, Z+2	; 0x02
    1532:	93 81       	ldd	r25, Z+3	; 0x03
    1534:	ef 81       	ldd	r30, Y+7	; 0x07
    1536:	f8 85       	ldd	r31, Y+8	; 0x08
    1538:	93 83       	std	Z+3, r25	; 0x03
    153a:	82 83       	std	Z+2, r24	; 0x02
    pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    153c:	ef 81       	ldd	r30, Y+7	; 0x07
    153e:	f8 85       	ldd	r31, Y+8	; 0x08
    1540:	02 80       	ldd	r0, Z+2	; 0x02
    1542:	f3 81       	ldd	r31, Z+3	; 0x03
    1544:	e0 2d       	mov	r30, r0
    1546:	8f 81       	ldd	r24, Y+7	; 0x07
    1548:	98 85       	ldd	r25, Y+8	; 0x08
    154a:	95 83       	std	Z+5, r25	; 0x05
    154c:	84 83       	std	Z+4, r24	; 0x04
    pxNewListItem->pxPrevious = pxIterator;
    154e:	ef 81       	ldd	r30, Y+7	; 0x07
    1550:	f8 85       	ldd	r31, Y+8	; 0x08
    1552:	8b 81       	ldd	r24, Y+3	; 0x03
    1554:	9c 81       	ldd	r25, Y+4	; 0x04
    1556:	95 83       	std	Z+5, r25	; 0x05
    1558:	84 83       	std	Z+4, r24	; 0x04
    pxIterator->pxNext = pxNewListItem;
    155a:	eb 81       	ldd	r30, Y+3	; 0x03
    155c:	fc 81       	ldd	r31, Y+4	; 0x04
    155e:	8f 81       	ldd	r24, Y+7	; 0x07
    1560:	98 85       	ldd	r25, Y+8	; 0x08
    1562:	93 83       	std	Z+3, r25	; 0x03
    1564:	82 83       	std	Z+2, r24	; 0x02

    /* Remember which list the item is in.  This allows fast removal of the
     * item later. */
    pxNewListItem->pxContainer = pxList;
    1566:	ef 81       	ldd	r30, Y+7	; 0x07
    1568:	f8 85       	ldd	r31, Y+8	; 0x08
    156a:	8d 81       	ldd	r24, Y+5	; 0x05
    156c:	9e 81       	ldd	r25, Y+6	; 0x06
    156e:	91 87       	std	Z+9, r25	; 0x09
    1570:	80 87       	std	Z+8, r24	; 0x08

    ( pxList->uxNumberOfItems )++;
    1572:	ed 81       	ldd	r30, Y+5	; 0x05
    1574:	fe 81       	ldd	r31, Y+6	; 0x06
    1576:	80 81       	ld	r24, Z
    1578:	8f 5f       	subi	r24, 0xFF	; 255
    157a:	ed 81       	ldd	r30, Y+5	; 0x05
    157c:	fe 81       	ldd	r31, Y+6	; 0x06
    157e:	80 83       	st	Z, r24
}
    1580:	28 96       	adiw	r28, 0x08	; 8
    1582:	0f b6       	in	r0, 0x3f	; 63
    1584:	f8 94       	cli
    1586:	de bf       	out	0x3e, r29	; 62
    1588:	0f be       	out	0x3f, r0	; 63
    158a:	cd bf       	out	0x3d, r28	; 61
    158c:	cf 91       	pop	r28
    158e:	df 91       	pop	r29
    1590:	08 95       	ret

00001592 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    1592:	df 93       	push	r29
    1594:	cf 93       	push	r28
    1596:	00 d0       	rcall	.+0      	; 0x1598 <uxListRemove+0x6>
    1598:	00 d0       	rcall	.+0      	; 0x159a <uxListRemove+0x8>
    159a:	cd b7       	in	r28, 0x3d	; 61
    159c:	de b7       	in	r29, 0x3e	; 62
    159e:	9c 83       	std	Y+4, r25	; 0x04
    15a0:	8b 83       	std	Y+3, r24	; 0x03
/* The list item knows which list it is in.  Obtain the list from the list
 * item. */
    List_t * const pxList = pxItemToRemove->pxContainer;
    15a2:	eb 81       	ldd	r30, Y+3	; 0x03
    15a4:	fc 81       	ldd	r31, Y+4	; 0x04
    15a6:	80 85       	ldd	r24, Z+8	; 0x08
    15a8:	91 85       	ldd	r25, Z+9	; 0x09
    15aa:	9a 83       	std	Y+2, r25	; 0x02
    15ac:	89 83       	std	Y+1, r24	; 0x01

    pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    15ae:	eb 81       	ldd	r30, Y+3	; 0x03
    15b0:	fc 81       	ldd	r31, Y+4	; 0x04
    15b2:	a2 81       	ldd	r26, Z+2	; 0x02
    15b4:	b3 81       	ldd	r27, Z+3	; 0x03
    15b6:	eb 81       	ldd	r30, Y+3	; 0x03
    15b8:	fc 81       	ldd	r31, Y+4	; 0x04
    15ba:	84 81       	ldd	r24, Z+4	; 0x04
    15bc:	95 81       	ldd	r25, Z+5	; 0x05
    15be:	15 96       	adiw	r26, 0x05	; 5
    15c0:	9c 93       	st	X, r25
    15c2:	8e 93       	st	-X, r24
    15c4:	14 97       	sbiw	r26, 0x04	; 4
    pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    15c6:	eb 81       	ldd	r30, Y+3	; 0x03
    15c8:	fc 81       	ldd	r31, Y+4	; 0x04
    15ca:	a4 81       	ldd	r26, Z+4	; 0x04
    15cc:	b5 81       	ldd	r27, Z+5	; 0x05
    15ce:	eb 81       	ldd	r30, Y+3	; 0x03
    15d0:	fc 81       	ldd	r31, Y+4	; 0x04
    15d2:	82 81       	ldd	r24, Z+2	; 0x02
    15d4:	93 81       	ldd	r25, Z+3	; 0x03
    15d6:	13 96       	adiw	r26, 0x03	; 3
    15d8:	9c 93       	st	X, r25
    15da:	8e 93       	st	-X, r24
    15dc:	12 97       	sbiw	r26, 0x02	; 2

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    /* Make sure the index is left pointing to a valid item. */
    if( pxList->pxIndex == pxItemToRemove )
    15de:	e9 81       	ldd	r30, Y+1	; 0x01
    15e0:	fa 81       	ldd	r31, Y+2	; 0x02
    15e2:	21 81       	ldd	r18, Z+1	; 0x01
    15e4:	32 81       	ldd	r19, Z+2	; 0x02
    15e6:	8b 81       	ldd	r24, Y+3	; 0x03
    15e8:	9c 81       	ldd	r25, Y+4	; 0x04
    15ea:	28 17       	cp	r18, r24
    15ec:	39 07       	cpc	r19, r25
    15ee:	41 f4       	brne	.+16     	; 0x1600 <uxListRemove+0x6e>
    {
        pxList->pxIndex = pxItemToRemove->pxPrevious;
    15f0:	eb 81       	ldd	r30, Y+3	; 0x03
    15f2:	fc 81       	ldd	r31, Y+4	; 0x04
    15f4:	84 81       	ldd	r24, Z+4	; 0x04
    15f6:	95 81       	ldd	r25, Z+5	; 0x05
    15f8:	e9 81       	ldd	r30, Y+1	; 0x01
    15fa:	fa 81       	ldd	r31, Y+2	; 0x02
    15fc:	92 83       	std	Z+2, r25	; 0x02
    15fe:	81 83       	std	Z+1, r24	; 0x01
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxItemToRemove->pxContainer = NULL;
    1600:	eb 81       	ldd	r30, Y+3	; 0x03
    1602:	fc 81       	ldd	r31, Y+4	; 0x04
    1604:	11 86       	std	Z+9, r1	; 0x09
    1606:	10 86       	std	Z+8, r1	; 0x08
    ( pxList->uxNumberOfItems )--;
    1608:	e9 81       	ldd	r30, Y+1	; 0x01
    160a:	fa 81       	ldd	r31, Y+2	; 0x02
    160c:	80 81       	ld	r24, Z
    160e:	81 50       	subi	r24, 0x01	; 1
    1610:	e9 81       	ldd	r30, Y+1	; 0x01
    1612:	fa 81       	ldd	r31, Y+2	; 0x02
    1614:	80 83       	st	Z, r24

    return pxList->uxNumberOfItems;
    1616:	e9 81       	ldd	r30, Y+1	; 0x01
    1618:	fa 81       	ldd	r31, Y+2	; 0x02
    161a:	80 81       	ld	r24, Z
}
    161c:	0f 90       	pop	r0
    161e:	0f 90       	pop	r0
    1620:	0f 90       	pop	r0
    1622:	0f 90       	pop	r0
    1624:	cf 91       	pop	r28
    1626:	df 91       	pop	r29
    1628:	08 95       	ret

0000162a <xQueueGenericReset>:
    taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue,
                               BaseType_t xNewQueue )
{
    162a:	df 93       	push	r29
    162c:	cf 93       	push	r28
    162e:	00 d0       	rcall	.+0      	; 0x1630 <xQueueGenericReset+0x6>
    1630:	00 d0       	rcall	.+0      	; 0x1632 <xQueueGenericReset+0x8>
    1632:	00 d0       	rcall	.+0      	; 0x1634 <xQueueGenericReset+0xa>
    1634:	cd b7       	in	r28, 0x3d	; 61
    1636:	de b7       	in	r29, 0x3e	; 62
    1638:	9d 83       	std	Y+5, r25	; 0x05
    163a:	8c 83       	std	Y+4, r24	; 0x04
    163c:	6e 83       	std	Y+6, r22	; 0x06
    BaseType_t xReturn = pdPASS;
    163e:	81 e0       	ldi	r24, 0x01	; 1
    1640:	8b 83       	std	Y+3, r24	; 0x03
    Queue_t * const pxQueue = xQueue;
    1642:	8c 81       	ldd	r24, Y+4	; 0x04
    1644:	9d 81       	ldd	r25, Y+5	; 0x05
    1646:	9a 83       	std	Y+2, r25	; 0x02
    1648:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );

    if( ( pxQueue != NULL ) &&
    164a:	89 81       	ldd	r24, Y+1	; 0x01
    164c:	9a 81       	ldd	r25, Y+2	; 0x02
    164e:	00 97       	sbiw	r24, 0x00	; 0
    1650:	09 f4       	brne	.+2      	; 0x1654 <xQueueGenericReset+0x2a>
    1652:	8b c0       	rjmp	.+278    	; 0x176a <xQueueGenericReset+0x140>
    1654:	e9 81       	ldd	r30, Y+1	; 0x01
    1656:	fa 81       	ldd	r31, Y+2	; 0x02
    1658:	83 8d       	ldd	r24, Z+27	; 0x1b
    165a:	88 23       	and	r24, r24
    165c:	09 f4       	brne	.+2      	; 0x1660 <xQueueGenericReset+0x36>
    165e:	85 c0       	rjmp	.+266    	; 0x176a <xQueueGenericReset+0x140>
    1660:	e9 81       	ldd	r30, Y+1	; 0x01
    1662:	fa 81       	ldd	r31, Y+2	; 0x02
    1664:	83 8d       	ldd	r24, Z+27	; 0x1b
    1666:	28 2f       	mov	r18, r24
    1668:	30 e0       	ldi	r19, 0x00	; 0
    166a:	8f ef       	ldi	r24, 0xFF	; 255
    166c:	9f e7       	ldi	r25, 0x7F	; 127
    166e:	b9 01       	movw	r22, r18
    1670:	0e 94 eb 27 	call	0x4fd6	; 0x4fd6 <__udivmodhi4>
    1674:	cb 01       	movw	r24, r22
    1676:	9c 01       	movw	r18, r24
    1678:	e9 81       	ldd	r30, Y+1	; 0x01
    167a:	fa 81       	ldd	r31, Y+2	; 0x02
    167c:	84 8d       	ldd	r24, Z+28	; 0x1c
    167e:	88 2f       	mov	r24, r24
    1680:	90 e0       	ldi	r25, 0x00	; 0
    1682:	28 17       	cp	r18, r24
    1684:	39 07       	cpc	r19, r25
    1686:	08 f4       	brcc	.+2      	; 0x168a <xQueueGenericReset+0x60>
    1688:	70 c0       	rjmp	.+224    	; 0x176a <xQueueGenericReset+0x140>
        ( pxQueue->uxLength >= 1U ) &&
        /* Check for multiplication overflow. */
        ( ( SIZE_MAX / pxQueue->uxLength ) >= pxQueue->uxItemSize ) )
    {
        taskENTER_CRITICAL();
    168a:	0f b6       	in	r0, 0x3f	; 63
    168c:	f8 94       	cli
    168e:	0f 92       	push	r0
        {
            pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    1690:	e9 81       	ldd	r30, Y+1	; 0x01
    1692:	fa 81       	ldd	r31, Y+2	; 0x02
    1694:	40 81       	ld	r20, Z
    1696:	51 81       	ldd	r21, Z+1	; 0x01
    1698:	e9 81       	ldd	r30, Y+1	; 0x01
    169a:	fa 81       	ldd	r31, Y+2	; 0x02
    169c:	83 8d       	ldd	r24, Z+27	; 0x1b
    169e:	28 2f       	mov	r18, r24
    16a0:	30 e0       	ldi	r19, 0x00	; 0
    16a2:	e9 81       	ldd	r30, Y+1	; 0x01
    16a4:	fa 81       	ldd	r31, Y+2	; 0x02
    16a6:	84 8d       	ldd	r24, Z+28	; 0x1c
    16a8:	88 2f       	mov	r24, r24
    16aa:	90 e0       	ldi	r25, 0x00	; 0
    16ac:	bc 01       	movw	r22, r24
    16ae:	26 9f       	mul	r18, r22
    16b0:	c0 01       	movw	r24, r0
    16b2:	27 9f       	mul	r18, r23
    16b4:	90 0d       	add	r25, r0
    16b6:	36 9f       	mul	r19, r22
    16b8:	90 0d       	add	r25, r0
    16ba:	11 24       	eor	r1, r1
    16bc:	84 0f       	add	r24, r20
    16be:	95 1f       	adc	r25, r21
    16c0:	e9 81       	ldd	r30, Y+1	; 0x01
    16c2:	fa 81       	ldd	r31, Y+2	; 0x02
    16c4:	95 83       	std	Z+5, r25	; 0x05
    16c6:	84 83       	std	Z+4, r24	; 0x04
            pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    16c8:	e9 81       	ldd	r30, Y+1	; 0x01
    16ca:	fa 81       	ldd	r31, Y+2	; 0x02
    16cc:	12 8e       	std	Z+26, r1	; 0x1a
            pxQueue->pcWriteTo = pxQueue->pcHead;
    16ce:	e9 81       	ldd	r30, Y+1	; 0x01
    16d0:	fa 81       	ldd	r31, Y+2	; 0x02
    16d2:	80 81       	ld	r24, Z
    16d4:	91 81       	ldd	r25, Z+1	; 0x01
    16d6:	e9 81       	ldd	r30, Y+1	; 0x01
    16d8:	fa 81       	ldd	r31, Y+2	; 0x02
    16da:	93 83       	std	Z+3, r25	; 0x03
    16dc:	82 83       	std	Z+2, r24	; 0x02
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    16de:	e9 81       	ldd	r30, Y+1	; 0x01
    16e0:	fa 81       	ldd	r31, Y+2	; 0x02
    16e2:	40 81       	ld	r20, Z
    16e4:	51 81       	ldd	r21, Z+1	; 0x01
    16e6:	e9 81       	ldd	r30, Y+1	; 0x01
    16e8:	fa 81       	ldd	r31, Y+2	; 0x02
    16ea:	83 8d       	ldd	r24, Z+27	; 0x1b
    16ec:	88 2f       	mov	r24, r24
    16ee:	90 e0       	ldi	r25, 0x00	; 0
    16f0:	9c 01       	movw	r18, r24
    16f2:	21 50       	subi	r18, 0x01	; 1
    16f4:	30 40       	sbci	r19, 0x00	; 0
    16f6:	e9 81       	ldd	r30, Y+1	; 0x01
    16f8:	fa 81       	ldd	r31, Y+2	; 0x02
    16fa:	84 8d       	ldd	r24, Z+28	; 0x1c
    16fc:	88 2f       	mov	r24, r24
    16fe:	90 e0       	ldi	r25, 0x00	; 0
    1700:	bc 01       	movw	r22, r24
    1702:	26 9f       	mul	r18, r22
    1704:	c0 01       	movw	r24, r0
    1706:	27 9f       	mul	r18, r23
    1708:	90 0d       	add	r25, r0
    170a:	36 9f       	mul	r19, r22
    170c:	90 0d       	add	r25, r0
    170e:	11 24       	eor	r1, r1
    1710:	84 0f       	add	r24, r20
    1712:	95 1f       	adc	r25, r21
    1714:	e9 81       	ldd	r30, Y+1	; 0x01
    1716:	fa 81       	ldd	r31, Y+2	; 0x02
    1718:	97 83       	std	Z+7, r25	; 0x07
    171a:	86 83       	std	Z+6, r24	; 0x06
            pxQueue->cRxLock = queueUNLOCKED;
    171c:	e9 81       	ldd	r30, Y+1	; 0x01
    171e:	fa 81       	ldd	r31, Y+2	; 0x02
    1720:	8f ef       	ldi	r24, 0xFF	; 255
    1722:	85 8f       	std	Z+29, r24	; 0x1d
            pxQueue->cTxLock = queueUNLOCKED;
    1724:	e9 81       	ldd	r30, Y+1	; 0x01
    1726:	fa 81       	ldd	r31, Y+2	; 0x02
    1728:	8f ef       	ldi	r24, 0xFF	; 255
    172a:	86 8f       	std	Z+30, r24	; 0x1e

            if( xNewQueue == pdFALSE )
    172c:	8e 81       	ldd	r24, Y+6	; 0x06
    172e:	88 23       	and	r24, r24
    1730:	79 f4       	brne	.+30     	; 0x1750 <xQueueGenericReset+0x126>
                /* If there are tasks blocked waiting to read from the queue, then
                 * the tasks will remain blocked as after this function exits the queue
                 * will still be empty.  If there are tasks blocked waiting to write to
                 * the queue, then one should be unblocked as after this function exits
                 * it will be possible to write to it. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1732:	e9 81       	ldd	r30, Y+1	; 0x01
    1734:	fa 81       	ldd	r31, Y+2	; 0x02
    1736:	80 85       	ldd	r24, Z+8	; 0x08
    1738:	88 23       	and	r24, r24
    173a:	a1 f0       	breq	.+40     	; 0x1764 <xQueueGenericReset+0x13a>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    173c:	89 81       	ldd	r24, Y+1	; 0x01
    173e:	9a 81       	ldd	r25, Y+2	; 0x02
    1740:	08 96       	adiw	r24, 0x08	; 8
    1742:	0e 94 d7 1b 	call	0x37ae	; 0x37ae <xTaskRemoveFromEventList>
    1746:	88 23       	and	r24, r24
    1748:	69 f0       	breq	.+26     	; 0x1764 <xQueueGenericReset+0x13a>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
    174a:	0e 94 a6 02 	call	0x54c	; 0x54c <vPortYield>
    174e:	0a c0       	rjmp	.+20     	; 0x1764 <xQueueGenericReset+0x13a>
                }
            }
            else
            {
                /* Ensure the event queues start in the correct state. */
                vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    1750:	89 81       	ldd	r24, Y+1	; 0x01
    1752:	9a 81       	ldd	r25, Y+2	; 0x02
    1754:	08 96       	adiw	r24, 0x08	; 8
    1756:	0e 94 df 09 	call	0x13be	; 0x13be <vListInitialise>
                vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    175a:	89 81       	ldd	r24, Y+1	; 0x01
    175c:	9a 81       	ldd	r25, Y+2	; 0x02
    175e:	41 96       	adiw	r24, 0x11	; 17
    1760:	0e 94 df 09 	call	0x13be	; 0x13be <vListInitialise>
            }
        }
        taskEXIT_CRITICAL();
    1764:	0f 90       	pop	r0
    1766:	0f be       	out	0x3f, r0	; 63
    1768:	01 c0       	rjmp	.+2      	; 0x176c <xQueueGenericReset+0x142>
    }
    else
    {
        xReturn = pdFAIL;
    176a:	1b 82       	std	Y+3, r1	; 0x03

    configASSERT( xReturn != pdFAIL );

    /* A value is returned for calling semantic consistency with previous
     * versions. */
    return xReturn;
    176c:	8b 81       	ldd	r24, Y+3	; 0x03
}
    176e:	26 96       	adiw	r28, 0x06	; 6
    1770:	0f b6       	in	r0, 0x3f	; 63
    1772:	f8 94       	cli
    1774:	de bf       	out	0x3e, r29	; 62
    1776:	0f be       	out	0x3f, r0	; 63
    1778:	cd bf       	out	0x3d, r28	; 61
    177a:	cf 91       	pop	r28
    177c:	df 91       	pop	r29
    177e:	08 95       	ret

00001780 <xQueueGenericCreate>:
#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

    QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength,
                                       const UBaseType_t uxItemSize,
                                       const uint8_t ucQueueType )
    {
    1780:	0f 93       	push	r16
    1782:	1f 93       	push	r17
    1784:	df 93       	push	r29
    1786:	cf 93       	push	r28
    1788:	cd b7       	in	r28, 0x3d	; 61
    178a:	de b7       	in	r29, 0x3e	; 62
    178c:	29 97       	sbiw	r28, 0x09	; 9
    178e:	0f b6       	in	r0, 0x3f	; 63
    1790:	f8 94       	cli
    1792:	de bf       	out	0x3e, r29	; 62
    1794:	0f be       	out	0x3f, r0	; 63
    1796:	cd bf       	out	0x3d, r28	; 61
    1798:	8f 83       	std	Y+7, r24	; 0x07
    179a:	68 87       	std	Y+8, r22	; 0x08
    179c:	49 87       	std	Y+9, r20	; 0x09
        Queue_t * pxNewQueue = NULL;
    179e:	1e 82       	std	Y+6, r1	; 0x06
    17a0:	1d 82       	std	Y+5, r1	; 0x05
        size_t xQueueSizeInBytes;
        uint8_t * pucQueueStorage;

        if( ( uxQueueLength > ( UBaseType_t ) 0 ) &&
    17a2:	8f 81       	ldd	r24, Y+7	; 0x07
    17a4:	88 23       	and	r24, r24
    17a6:	09 f4       	brne	.+2      	; 0x17aa <xQueueGenericCreate+0x2a>
    17a8:	52 c0       	rjmp	.+164    	; 0x184e <xQueueGenericCreate+0xce>
    17aa:	8f 81       	ldd	r24, Y+7	; 0x07
    17ac:	28 2f       	mov	r18, r24
    17ae:	30 e0       	ldi	r19, 0x00	; 0
    17b0:	8f ef       	ldi	r24, 0xFF	; 255
    17b2:	9f e7       	ldi	r25, 0x7F	; 127
    17b4:	b9 01       	movw	r22, r18
    17b6:	0e 94 eb 27 	call	0x4fd6	; 0x4fd6 <__udivmodhi4>
    17ba:	cb 01       	movw	r24, r22
    17bc:	9c 01       	movw	r18, r24
    17be:	88 85       	ldd	r24, Y+8	; 0x08
    17c0:	88 2f       	mov	r24, r24
    17c2:	90 e0       	ldi	r25, 0x00	; 0
    17c4:	28 17       	cp	r18, r24
    17c6:	39 07       	cpc	r19, r25
    17c8:	08 f4       	brcc	.+2      	; 0x17cc <xQueueGenericCreate+0x4c>
    17ca:	41 c0       	rjmp	.+130    	; 0x184e <xQueueGenericCreate+0xce>
    17cc:	8f 81       	ldd	r24, Y+7	; 0x07
    17ce:	28 2f       	mov	r18, r24
    17d0:	30 e0       	ldi	r19, 0x00	; 0
    17d2:	88 85       	ldd	r24, Y+8	; 0x08
    17d4:	88 2f       	mov	r24, r24
    17d6:	90 e0       	ldi	r25, 0x00	; 0
    17d8:	ac 01       	movw	r20, r24
    17da:	24 9f       	mul	r18, r20
    17dc:	c0 01       	movw	r24, r0
    17de:	25 9f       	mul	r18, r21
    17e0:	90 0d       	add	r25, r0
    17e2:	34 9f       	mul	r19, r20
    17e4:	90 0d       	add	r25, r0
    17e6:	11 24       	eor	r1, r1
    17e8:	5f e7       	ldi	r21, 0x7F	; 127
    17ea:	81 3e       	cpi	r24, 0xE1	; 225
    17ec:	95 07       	cpc	r25, r21
    17ee:	78 f5       	brcc	.+94     	; 0x184e <xQueueGenericCreate+0xce>
            ( ( SIZE_MAX - sizeof( Queue_t ) ) >= ( uxQueueLength * uxItemSize ) ) )
        {
            /* Allocate enough space to hold the maximum number of items that
             * can be in the queue at any time.  It is valid for uxItemSize to be
             * zero in the case the queue is used as a semaphore. */
            xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    17f0:	8f 81       	ldd	r24, Y+7	; 0x07
    17f2:	28 2f       	mov	r18, r24
    17f4:	30 e0       	ldi	r19, 0x00	; 0
    17f6:	88 85       	ldd	r24, Y+8	; 0x08
    17f8:	88 2f       	mov	r24, r24
    17fa:	90 e0       	ldi	r25, 0x00	; 0
    17fc:	ac 01       	movw	r20, r24
    17fe:	24 9f       	mul	r18, r20
    1800:	c0 01       	movw	r24, r0
    1802:	25 9f       	mul	r18, r21
    1804:	90 0d       	add	r25, r0
    1806:	34 9f       	mul	r19, r20
    1808:	90 0d       	add	r25, r0
    180a:	11 24       	eor	r1, r1
    180c:	9c 83       	std	Y+4, r25	; 0x04
    180e:	8b 83       	std	Y+3, r24	; 0x03
             * alignment requirements of the Queue_t structure - which in this case
             * is an int8_t *.  Therefore, whenever the stack alignment requirements
             * are greater than or equal to the pointer to char requirements the cast
             * is safe.  In other cases alignment requirements are not strict (one or
             * two bytes). */
            pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
    1810:	8b 81       	ldd	r24, Y+3	; 0x03
    1812:	9c 81       	ldd	r25, Y+4	; 0x04
    1814:	4f 96       	adiw	r24, 0x1f	; 31
    1816:	0e 94 67 00 	call	0xce	; 0xce <pvPortMalloc>
    181a:	9e 83       	std	Y+6, r25	; 0x06
    181c:	8d 83       	std	Y+5, r24	; 0x05

            if( pxNewQueue != NULL )
    181e:	8d 81       	ldd	r24, Y+5	; 0x05
    1820:	9e 81       	ldd	r25, Y+6	; 0x06
    1822:	00 97       	sbiw	r24, 0x00	; 0
    1824:	a1 f0       	breq	.+40     	; 0x184e <xQueueGenericCreate+0xce>
            {
                /* Jump past the queue structure to find the location of the queue
                 * storage area. */
                pucQueueStorage = ( uint8_t * ) pxNewQueue;
    1826:	8d 81       	ldd	r24, Y+5	; 0x05
    1828:	9e 81       	ldd	r25, Y+6	; 0x06
    182a:	9a 83       	std	Y+2, r25	; 0x02
    182c:	89 83       	std	Y+1, r24	; 0x01
                pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    182e:	89 81       	ldd	r24, Y+1	; 0x01
    1830:	9a 81       	ldd	r25, Y+2	; 0x02
    1832:	4f 96       	adiw	r24, 0x1f	; 31
    1834:	9a 83       	std	Y+2, r25	; 0x02
    1836:	89 83       	std	Y+1, r24	; 0x01
                         * deleted. */
                        pxNewQueue->ucStaticallyAllocated = pdFALSE;
                    }
                #endif /* configSUPPORT_STATIC_ALLOCATION */

                prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
    1838:	29 81       	ldd	r18, Y+1	; 0x01
    183a:	3a 81       	ldd	r19, Y+2	; 0x02
    183c:	ed 81       	ldd	r30, Y+5	; 0x05
    183e:	fe 81       	ldd	r31, Y+6	; 0x06
    1840:	8f 81       	ldd	r24, Y+7	; 0x07
    1842:	68 85       	ldd	r22, Y+8	; 0x08
    1844:	a9 01       	movw	r20, r18
    1846:	29 85       	ldd	r18, Y+9	; 0x09
    1848:	8f 01       	movw	r16, r30
    184a:	0e 94 34 0c 	call	0x1868	; 0x1868 <prvInitialiseNewQueue>
        {
            configASSERT( pxNewQueue );
            mtCOVERAGE_TEST_MARKER();
        }

        return pxNewQueue;
    184e:	8d 81       	ldd	r24, Y+5	; 0x05
    1850:	9e 81       	ldd	r25, Y+6	; 0x06
    }
    1852:	29 96       	adiw	r28, 0x09	; 9
    1854:	0f b6       	in	r0, 0x3f	; 63
    1856:	f8 94       	cli
    1858:	de bf       	out	0x3e, r29	; 62
    185a:	0f be       	out	0x3f, r0	; 63
    185c:	cd bf       	out	0x3d, r28	; 61
    185e:	cf 91       	pop	r28
    1860:	df 91       	pop	r29
    1862:	1f 91       	pop	r17
    1864:	0f 91       	pop	r16
    1866:	08 95       	ret

00001868 <prvInitialiseNewQueue>:
static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength,
                                   const UBaseType_t uxItemSize,
                                   uint8_t * pucQueueStorage,
                                   const uint8_t ucQueueType,
                                   Queue_t * pxNewQueue )
{
    1868:	0f 93       	push	r16
    186a:	1f 93       	push	r17
    186c:	df 93       	push	r29
    186e:	cf 93       	push	r28
    1870:	cd b7       	in	r28, 0x3d	; 61
    1872:	de b7       	in	r29, 0x3e	; 62
    1874:	27 97       	sbiw	r28, 0x07	; 7
    1876:	0f b6       	in	r0, 0x3f	; 63
    1878:	f8 94       	cli
    187a:	de bf       	out	0x3e, r29	; 62
    187c:	0f be       	out	0x3f, r0	; 63
    187e:	cd bf       	out	0x3d, r28	; 61
    1880:	89 83       	std	Y+1, r24	; 0x01
    1882:	6a 83       	std	Y+2, r22	; 0x02
    1884:	5c 83       	std	Y+4, r21	; 0x04
    1886:	4b 83       	std	Y+3, r20	; 0x03
    1888:	2d 83       	std	Y+5, r18	; 0x05
    188a:	1f 83       	std	Y+7, r17	; 0x07
    188c:	0e 83       	std	Y+6, r16	; 0x06
    /* Remove compiler warnings about unused parameters should
     * configUSE_TRACE_FACILITY not be set to 1. */
    ( void ) ucQueueType;

    if( uxItemSize == ( UBaseType_t ) 0 )
    188e:	8a 81       	ldd	r24, Y+2	; 0x02
    1890:	88 23       	and	r24, r24
    1892:	39 f4       	brne	.+14     	; 0x18a2 <prvInitialiseNewQueue+0x3a>
    {
        /* No RAM was allocated for the queue storage area, but PC head cannot
         * be set to NULL because NULL is used as a key to say the queue is used as
         * a mutex.  Therefore just set pcHead to point to the queue as a benign
         * value that is known to be within the memory map. */
        pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    1894:	8e 81       	ldd	r24, Y+6	; 0x06
    1896:	9f 81       	ldd	r25, Y+7	; 0x07
    1898:	ee 81       	ldd	r30, Y+6	; 0x06
    189a:	ff 81       	ldd	r31, Y+7	; 0x07
    189c:	91 83       	std	Z+1, r25	; 0x01
    189e:	80 83       	st	Z, r24
    18a0:	06 c0       	rjmp	.+12     	; 0x18ae <prvInitialiseNewQueue+0x46>
    }
    else
    {
        /* Set the head to the start of the queue storage area. */
        pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    18a2:	8b 81       	ldd	r24, Y+3	; 0x03
    18a4:	9c 81       	ldd	r25, Y+4	; 0x04
    18a6:	ee 81       	ldd	r30, Y+6	; 0x06
    18a8:	ff 81       	ldd	r31, Y+7	; 0x07
    18aa:	91 83       	std	Z+1, r25	; 0x01
    18ac:	80 83       	st	Z, r24
    }

    /* Initialise the queue members as described where the queue type is
     * defined. */
    pxNewQueue->uxLength = uxQueueLength;
    18ae:	ee 81       	ldd	r30, Y+6	; 0x06
    18b0:	ff 81       	ldd	r31, Y+7	; 0x07
    18b2:	89 81       	ldd	r24, Y+1	; 0x01
    18b4:	83 8f       	std	Z+27, r24	; 0x1b
    pxNewQueue->uxItemSize = uxItemSize;
    18b6:	ee 81       	ldd	r30, Y+6	; 0x06
    18b8:	ff 81       	ldd	r31, Y+7	; 0x07
    18ba:	8a 81       	ldd	r24, Y+2	; 0x02
    18bc:	84 8f       	std	Z+28, r24	; 0x1c
    ( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    18be:	8e 81       	ldd	r24, Y+6	; 0x06
    18c0:	9f 81       	ldd	r25, Y+7	; 0x07
    18c2:	61 e0       	ldi	r22, 0x01	; 1
    18c4:	0e 94 15 0b 	call	0x162a	; 0x162a <xQueueGenericReset>
            pxNewQueue->pxQueueSetContainer = NULL;
        }
    #endif /* configUSE_QUEUE_SETS */

    traceQUEUE_CREATE( pxNewQueue );
}
    18c8:	27 96       	adiw	r28, 0x07	; 7
    18ca:	0f b6       	in	r0, 0x3f	; 63
    18cc:	f8 94       	cli
    18ce:	de bf       	out	0x3e, r29	; 62
    18d0:	0f be       	out	0x3f, r0	; 63
    18d2:	cd bf       	out	0x3d, r28	; 61
    18d4:	cf 91       	pop	r28
    18d6:	df 91       	pop	r29
    18d8:	1f 91       	pop	r17
    18da:	0f 91       	pop	r16
    18dc:	08 95       	ret

000018de <xQueueGenericSend>:

BaseType_t xQueueGenericSend( QueueHandle_t xQueue,
                              const void * const pvItemToQueue,
                              TickType_t xTicksToWait,
                              const BaseType_t xCopyPosition )
{
    18de:	df 93       	push	r29
    18e0:	cf 93       	push	r28
    18e2:	cd b7       	in	r28, 0x3d	; 61
    18e4:	de b7       	in	r29, 0x3e	; 62
    18e6:	2f 97       	sbiw	r28, 0x0f	; 15
    18e8:	0f b6       	in	r0, 0x3f	; 63
    18ea:	f8 94       	cli
    18ec:	de bf       	out	0x3e, r29	; 62
    18ee:	0f be       	out	0x3f, r0	; 63
    18f0:	cd bf       	out	0x3d, r28	; 61
    18f2:	99 87       	std	Y+9, r25	; 0x09
    18f4:	88 87       	std	Y+8, r24	; 0x08
    18f6:	7b 87       	std	Y+11, r23	; 0x0b
    18f8:	6a 87       	std	Y+10, r22	; 0x0a
    18fa:	5d 87       	std	Y+13, r21	; 0x0d
    18fc:	4c 87       	std	Y+12, r20	; 0x0c
    18fe:	2e 87       	std	Y+14, r18	; 0x0e
    BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    1900:	1c 82       	std	Y+4, r1	; 0x04
    TimeOut_t xTimeOut;
    Queue_t * const pxQueue = xQueue;
    1902:	88 85       	ldd	r24, Y+8	; 0x08
    1904:	99 85       	ldd	r25, Y+9	; 0x09
    1906:	9a 83       	std	Y+2, r25	; 0x02
    1908:	89 83       	std	Y+1, r24	; 0x01
    /*lint -save -e904 This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    190a:	0f b6       	in	r0, 0x3f	; 63
    190c:	f8 94       	cli
    190e:	0f 92       	push	r0
        {
            /* Is there room on the queue now?  The running task must be the
             * highest priority task wanting to access the queue.  If the head item
             * in the queue is to be overwritten then it does not matter if the
             * queue is full. */
            if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1910:	e9 81       	ldd	r30, Y+1	; 0x01
    1912:	fa 81       	ldd	r31, Y+2	; 0x02
    1914:	92 8d       	ldd	r25, Z+26	; 0x1a
    1916:	e9 81       	ldd	r30, Y+1	; 0x01
    1918:	fa 81       	ldd	r31, Y+2	; 0x02
    191a:	83 8d       	ldd	r24, Z+27	; 0x1b
    191c:	98 17       	cp	r25, r24
    191e:	18 f0       	brcs	.+6      	; 0x1926 <xQueueGenericSend+0x48>
    1920:	8e 85       	ldd	r24, Y+14	; 0x0e
    1922:	82 30       	cpi	r24, 0x02	; 2
    1924:	11 f5       	brne	.+68     	; 0x196a <xQueueGenericSend+0x8c>
                            }
                        }
                    }
                #else /* configUSE_QUEUE_SETS */
                    {
                        xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1926:	89 81       	ldd	r24, Y+1	; 0x01
    1928:	9a 81       	ldd	r25, Y+2	; 0x02
    192a:	2a 85       	ldd	r18, Y+10	; 0x0a
    192c:	3b 85       	ldd	r19, Y+11	; 0x0b
    192e:	b9 01       	movw	r22, r18
    1930:	4e 85       	ldd	r20, Y+14	; 0x0e
    1932:	0e 94 c5 10 	call	0x218a	; 0x218a <prvCopyDataToQueue>
    1936:	8b 83       	std	Y+3, r24	; 0x03

                        /* If there was a task waiting for data to arrive on the
                         * queue then unblock it now. */
                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1938:	e9 81       	ldd	r30, Y+1	; 0x01
    193a:	fa 81       	ldd	r31, Y+2	; 0x02
    193c:	81 89       	ldd	r24, Z+17	; 0x11
    193e:	88 23       	and	r24, r24
    1940:	51 f0       	breq	.+20     	; 0x1956 <xQueueGenericSend+0x78>
                        {
                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1942:	89 81       	ldd	r24, Y+1	; 0x01
    1944:	9a 81       	ldd	r25, Y+2	; 0x02
    1946:	41 96       	adiw	r24, 0x11	; 17
    1948:	0e 94 d7 1b 	call	0x37ae	; 0x37ae <xTaskRemoveFromEventList>
    194c:	88 23       	and	r24, r24
    194e:	41 f0       	breq	.+16     	; 0x1960 <xQueueGenericSend+0x82>
                            {
                                /* The unblocked task has a priority higher than
                                 * our own so yield immediately.  Yes it is ok to do
                                 * this from within the critical section - the kernel
                                 * takes care of that. */
                                queueYIELD_IF_USING_PREEMPTION();
    1950:	0e 94 a6 02 	call	0x54c	; 0x54c <vPortYield>
    1954:	05 c0       	rjmp	.+10     	; 0x1960 <xQueueGenericSend+0x82>
                            else
                            {
                                mtCOVERAGE_TEST_MARKER();
                            }
                        }
                        else if( xYieldRequired != pdFALSE )
    1956:	8b 81       	ldd	r24, Y+3	; 0x03
    1958:	88 23       	and	r24, r24
    195a:	11 f0       	breq	.+4      	; 0x1960 <xQueueGenericSend+0x82>
                        {
                            /* This path is a special case that will only get
                             * executed if the task was holding multiple mutexes and
                             * the mutexes were given back in an order that is
                             * different to that in which they were taken. */
                            queueYIELD_IF_USING_PREEMPTION();
    195c:	0e 94 a6 02 	call	0x54c	; 0x54c <vPortYield>
                            mtCOVERAGE_TEST_MARKER();
                        }
                    }
                #endif /* configUSE_QUEUE_SETS */

                taskEXIT_CRITICAL();
    1960:	0f 90       	pop	r0
    1962:	0f be       	out	0x3f, r0	; 63
                return pdPASS;
    1964:	81 e0       	ldi	r24, 0x01	; 1
    1966:	8f 87       	std	Y+15, r24	; 0x0f
    1968:	5c c0       	rjmp	.+184    	; 0x1a22 <xQueueGenericSend+0x144>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    196a:	8c 85       	ldd	r24, Y+12	; 0x0c
    196c:	9d 85       	ldd	r25, Y+13	; 0x0d
    196e:	00 97       	sbiw	r24, 0x00	; 0
    1970:	21 f4       	brne	.+8      	; 0x197a <xQueueGenericSend+0x9c>
                {
                    /* The queue was full and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
    1972:	0f 90       	pop	r0
    1974:	0f be       	out	0x3f, r0	; 63

                    /* Return to the original privilege level before exiting
                     * the function. */
                    traceQUEUE_SEND_FAILED( pxQueue );
                    return errQUEUE_FULL;
    1976:	1f 86       	std	Y+15, r1	; 0x0f
    1978:	54 c0       	rjmp	.+168    	; 0x1a22 <xQueueGenericSend+0x144>
                }
                else if( xEntryTimeSet == pdFALSE )
    197a:	8c 81       	ldd	r24, Y+4	; 0x04
    197c:	88 23       	and	r24, r24
    197e:	31 f4       	brne	.+12     	; 0x198c <xQueueGenericSend+0xae>
                {
                    /* The queue was full and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    1980:	ce 01       	movw	r24, r28
    1982:	05 96       	adiw	r24, 0x05	; 5
    1984:	0e 94 47 1e 	call	0x3c8e	; 0x3c8e <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
    1988:	81 e0       	ldi	r24, 0x01	; 1
    198a:	8c 83       	std	Y+4, r24	; 0x04
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    198c:	0f 90       	pop	r0
    198e:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can send to and receive from the queue
         * now the critical section has been exited. */

        vTaskSuspendAll();
    1990:	0e 94 73 17 	call	0x2ee6	; 0x2ee6 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    1994:	0f b6       	in	r0, 0x3f	; 63
    1996:	f8 94       	cli
    1998:	0f 92       	push	r0
    199a:	e9 81       	ldd	r30, Y+1	; 0x01
    199c:	fa 81       	ldd	r31, Y+2	; 0x02
    199e:	85 8d       	ldd	r24, Z+29	; 0x1d
    19a0:	8f 3f       	cpi	r24, 0xFF	; 255
    19a2:	19 f4       	brne	.+6      	; 0x19aa <xQueueGenericSend+0xcc>
    19a4:	e9 81       	ldd	r30, Y+1	; 0x01
    19a6:	fa 81       	ldd	r31, Y+2	; 0x02
    19a8:	15 8e       	std	Z+29, r1	; 0x1d
    19aa:	e9 81       	ldd	r30, Y+1	; 0x01
    19ac:	fa 81       	ldd	r31, Y+2	; 0x02
    19ae:	86 8d       	ldd	r24, Z+30	; 0x1e
    19b0:	8f 3f       	cpi	r24, 0xFF	; 255
    19b2:	19 f4       	brne	.+6      	; 0x19ba <xQueueGenericSend+0xdc>
    19b4:	e9 81       	ldd	r30, Y+1	; 0x01
    19b6:	fa 81       	ldd	r31, Y+2	; 0x02
    19b8:	16 8e       	std	Z+30, r1	; 0x1e
    19ba:	0f 90       	pop	r0
    19bc:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    19be:	ce 01       	movw	r24, r28
    19c0:	05 96       	adiw	r24, 0x05	; 5
    19c2:	9e 01       	movw	r18, r28
    19c4:	24 5f       	subi	r18, 0xF4	; 244
    19c6:	3f 4f       	sbci	r19, 0xFF	; 255
    19c8:	b9 01       	movw	r22, r18
    19ca:	0e 94 60 1e 	call	0x3cc0	; 0x3cc0 <xTaskCheckForTimeOut>
    19ce:	88 23       	and	r24, r24
    19d0:	09 f5       	brne	.+66     	; 0x1a14 <xQueueGenericSend+0x136>
        {
            if( prvIsQueueFull( pxQueue ) != pdFALSE )
    19d2:	89 81       	ldd	r24, Y+1	; 0x01
    19d4:	9a 81       	ldd	r25, Y+2	; 0x02
    19d6:	0e 94 41 12 	call	0x2482	; 0x2482 <prvIsQueueFull>
    19da:	88 23       	and	r24, r24
    19dc:	a1 f0       	breq	.+40     	; 0x1a06 <xQueueGenericSend+0x128>
            {
                traceBLOCKING_ON_QUEUE_SEND( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    19de:	89 81       	ldd	r24, Y+1	; 0x01
    19e0:	9a 81       	ldd	r25, Y+2	; 0x02
    19e2:	08 96       	adiw	r24, 0x08	; 8
    19e4:	2c 85       	ldd	r18, Y+12	; 0x0c
    19e6:	3d 85       	ldd	r19, Y+13	; 0x0d
    19e8:	b9 01       	movw	r22, r18
    19ea:	0e 94 50 1b 	call	0x36a0	; 0x36a0 <vTaskPlaceOnEventList>
                /* Unlocking the queue means queue events can effect the
                 * event list. It is possible that interrupts occurring now
                 * remove this task from the event list again - but as the
                 * scheduler is suspended the task will go onto the pending
                 * ready list instead of the actual ready list. */
                prvUnlockQueue( pxQueue );
    19ee:	89 81       	ldd	r24, Y+1	; 0x01
    19f0:	9a 81       	ldd	r25, Y+2	; 0x02
    19f2:	0e 94 b2 11 	call	0x2364	; 0x2364 <prvUnlockQueue>
                /* Resuming the scheduler will move tasks from the pending
                 * ready list into the ready list - so it is feasible that this
                 * task is already in the ready list before it yields - in which
                 * case the yield will not cause a context switch unless there
                 * is also a higher priority task in the pending ready list. */
                if( xTaskResumeAll() == pdFALSE )
    19f6:	0e 94 7f 17 	call	0x2efe	; 0x2efe <xTaskResumeAll>
    19fa:	88 23       	and	r24, r24
    19fc:	09 f0       	breq	.+2      	; 0x1a00 <xQueueGenericSend+0x122>
    19fe:	85 cf       	rjmp	.-246    	; 0x190a <xQueueGenericSend+0x2c>
                {
                    portYIELD_WITHIN_API();
    1a00:	0e 94 a6 02 	call	0x54c	; 0x54c <vPortYield>
    1a04:	82 cf       	rjmp	.-252    	; 0x190a <xQueueGenericSend+0x2c>
                }
            }
            else
            {
                /* Try again. */
                prvUnlockQueue( pxQueue );
    1a06:	89 81       	ldd	r24, Y+1	; 0x01
    1a08:	9a 81       	ldd	r25, Y+2	; 0x02
    1a0a:	0e 94 b2 11 	call	0x2364	; 0x2364 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    1a0e:	0e 94 7f 17 	call	0x2efe	; 0x2efe <xTaskResumeAll>
    1a12:	7b cf       	rjmp	.-266    	; 0x190a <xQueueGenericSend+0x2c>
            }
        }
        else
        {
            /* The timeout has expired. */
            prvUnlockQueue( pxQueue );
    1a14:	89 81       	ldd	r24, Y+1	; 0x01
    1a16:	9a 81       	ldd	r25, Y+2	; 0x02
    1a18:	0e 94 b2 11 	call	0x2364	; 0x2364 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    1a1c:	0e 94 7f 17 	call	0x2efe	; 0x2efe <xTaskResumeAll>

            traceQUEUE_SEND_FAILED( pxQueue );
            return errQUEUE_FULL;
    1a20:	1f 86       	std	Y+15, r1	; 0x0f
    1a22:	8f 85       	ldd	r24, Y+15	; 0x0f
        }
    } /*lint -restore */
}
    1a24:	2f 96       	adiw	r28, 0x0f	; 15
    1a26:	0f b6       	in	r0, 0x3f	; 63
    1a28:	f8 94       	cli
    1a2a:	de bf       	out	0x3e, r29	; 62
    1a2c:	0f be       	out	0x3f, r0	; 63
    1a2e:	cd bf       	out	0x3d, r28	; 61
    1a30:	cf 91       	pop	r28
    1a32:	df 91       	pop	r29
    1a34:	08 95       	ret

00001a36 <xQueueGenericSendFromISR>:

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue,
                                     const void * const pvItemToQueue,
                                     BaseType_t * const pxHigherPriorityTaskWoken,
                                     const BaseType_t xCopyPosition )
{
    1a36:	df 93       	push	r29
    1a38:	cf 93       	push	r28
    1a3a:	cd b7       	in	r28, 0x3d	; 61
    1a3c:	de b7       	in	r29, 0x3e	; 62
    1a3e:	2d 97       	sbiw	r28, 0x0d	; 13
    1a40:	0f b6       	in	r0, 0x3f	; 63
    1a42:	f8 94       	cli
    1a44:	de bf       	out	0x3e, r29	; 62
    1a46:	0f be       	out	0x3f, r0	; 63
    1a48:	cd bf       	out	0x3d, r28	; 61
    1a4a:	98 87       	std	Y+8, r25	; 0x08
    1a4c:	8f 83       	std	Y+7, r24	; 0x07
    1a4e:	7a 87       	std	Y+10, r23	; 0x0a
    1a50:	69 87       	std	Y+9, r22	; 0x09
    1a52:	5c 87       	std	Y+12, r21	; 0x0c
    1a54:	4b 87       	std	Y+11, r20	; 0x0b
    1a56:	2d 87       	std	Y+13, r18	; 0x0d
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    Queue_t * const pxQueue = xQueue;
    1a58:	8f 81       	ldd	r24, Y+7	; 0x07
    1a5a:	98 85       	ldd	r25, Y+8	; 0x08
    1a5c:	9c 83       	std	Y+4, r25	; 0x04
    1a5e:	8b 83       	std	Y+3, r24	; 0x03
    /* Similar to xQueueGenericSend, except without blocking if there is no room
     * in the queue.  Also don't directly wake a task that was blocked on a queue
     * read, instead return a flag to say whether a context switch is required or
     * not (i.e. has a task with a higher priority than us been woken by this
     * post). */
    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1a60:	1d 82       	std	Y+5, r1	; 0x05
    {
        if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1a62:	eb 81       	ldd	r30, Y+3	; 0x03
    1a64:	fc 81       	ldd	r31, Y+4	; 0x04
    1a66:	92 8d       	ldd	r25, Z+26	; 0x1a
    1a68:	eb 81       	ldd	r30, Y+3	; 0x03
    1a6a:	fc 81       	ldd	r31, Y+4	; 0x04
    1a6c:	83 8d       	ldd	r24, Z+27	; 0x1b
    1a6e:	98 17       	cp	r25, r24
    1a70:	18 f0       	brcs	.+6      	; 0x1a78 <xQueueGenericSendFromISR+0x42>
    1a72:	8d 85       	ldd	r24, Y+13	; 0x0d
    1a74:	82 30       	cpi	r24, 0x02	; 2
    1a76:	81 f5       	brne	.+96     	; 0x1ad8 <xQueueGenericSendFromISR+0xa2>
        {
            const int8_t cTxLock = pxQueue->cTxLock;
    1a78:	eb 81       	ldd	r30, Y+3	; 0x03
    1a7a:	fc 81       	ldd	r31, Y+4	; 0x04
    1a7c:	86 8d       	ldd	r24, Z+30	; 0x1e
    1a7e:	8a 83       	std	Y+2, r24	; 0x02
            const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
    1a80:	eb 81       	ldd	r30, Y+3	; 0x03
    1a82:	fc 81       	ldd	r31, Y+4	; 0x04
    1a84:	82 8d       	ldd	r24, Z+26	; 0x1a
    1a86:	89 83       	std	Y+1, r24	; 0x01
            /* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
             *  semaphore or mutex.  That means prvCopyDataToQueue() cannot result
             *  in a task disinheriting a priority and prvCopyDataToQueue() can be
             *  called here even though the disinherit function does not check if
             *  the scheduler is suspended before accessing the ready lists. */
            ( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1a88:	8b 81       	ldd	r24, Y+3	; 0x03
    1a8a:	9c 81       	ldd	r25, Y+4	; 0x04
    1a8c:	29 85       	ldd	r18, Y+9	; 0x09
    1a8e:	3a 85       	ldd	r19, Y+10	; 0x0a
    1a90:	b9 01       	movw	r22, r18
    1a92:	4d 85       	ldd	r20, Y+13	; 0x0d
    1a94:	0e 94 c5 10 	call	0x218a	; 0x218a <prvCopyDataToQueue>

            /* The event list is not altered if the queue is locked.  This will
             * be done when the queue is unlocked later. */
            if( cTxLock == queueUNLOCKED )
    1a98:	8a 81       	ldd	r24, Y+2	; 0x02
    1a9a:	8f 3f       	cpi	r24, 0xFF	; 255
    1a9c:	a9 f4       	brne	.+42     	; 0x1ac8 <xQueueGenericSendFromISR+0x92>
                            }
                        }
                    }
                #else /* configUSE_QUEUE_SETS */
                    {
                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1a9e:	eb 81       	ldd	r30, Y+3	; 0x03
    1aa0:	fc 81       	ldd	r31, Y+4	; 0x04
    1aa2:	81 89       	ldd	r24, Z+17	; 0x11
    1aa4:	88 23       	and	r24, r24
    1aa6:	a9 f0       	breq	.+42     	; 0x1ad2 <xQueueGenericSendFromISR+0x9c>
                        {
                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1aa8:	8b 81       	ldd	r24, Y+3	; 0x03
    1aaa:	9c 81       	ldd	r25, Y+4	; 0x04
    1aac:	41 96       	adiw	r24, 0x11	; 17
    1aae:	0e 94 d7 1b 	call	0x37ae	; 0x37ae <xTaskRemoveFromEventList>
    1ab2:	88 23       	and	r24, r24
    1ab4:	71 f0       	breq	.+28     	; 0x1ad2 <xQueueGenericSendFromISR+0x9c>
                            {
                                /* The task waiting has a higher priority so record that a
                                 * context switch is required. */
                                if( pxHigherPriorityTaskWoken != NULL )
    1ab6:	8b 85       	ldd	r24, Y+11	; 0x0b
    1ab8:	9c 85       	ldd	r25, Y+12	; 0x0c
    1aba:	00 97       	sbiw	r24, 0x00	; 0
    1abc:	51 f0       	breq	.+20     	; 0x1ad2 <xQueueGenericSendFromISR+0x9c>
                                {
                                    *pxHigherPriorityTaskWoken = pdTRUE;
    1abe:	eb 85       	ldd	r30, Y+11	; 0x0b
    1ac0:	fc 85       	ldd	r31, Y+12	; 0x0c
    1ac2:	81 e0       	ldi	r24, 0x01	; 1
    1ac4:	80 83       	st	Z, r24
    1ac6:	05 c0       	rjmp	.+10     	; 0x1ad2 <xQueueGenericSendFromISR+0x9c>
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was posted while it was locked. */
                configASSERT( cTxLock != queueINT8_MAX );

                pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    1ac8:	8a 81       	ldd	r24, Y+2	; 0x02
    1aca:	8f 5f       	subi	r24, 0xFF	; 255
    1acc:	eb 81       	ldd	r30, Y+3	; 0x03
    1ace:	fc 81       	ldd	r31, Y+4	; 0x04
    1ad0:	86 8f       	std	Z+30, r24	; 0x1e
            }

            xReturn = pdPASS;
    1ad2:	81 e0       	ldi	r24, 0x01	; 1
    1ad4:	8e 83       	std	Y+6, r24	; 0x06
    1ad6:	01 c0       	rjmp	.+2      	; 0x1ada <xQueueGenericSendFromISR+0xa4>
        }
        else
        {
            traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
            xReturn = errQUEUE_FULL;
    1ad8:	1e 82       	std	Y+6, r1	; 0x06
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    1ada:	8e 81       	ldd	r24, Y+6	; 0x06
}
    1adc:	2d 96       	adiw	r28, 0x0d	; 13
    1ade:	0f b6       	in	r0, 0x3f	; 63
    1ae0:	f8 94       	cli
    1ae2:	de bf       	out	0x3e, r29	; 62
    1ae4:	0f be       	out	0x3f, r0	; 63
    1ae6:	cd bf       	out	0x3d, r28	; 61
    1ae8:	cf 91       	pop	r28
    1aea:	df 91       	pop	r29
    1aec:	08 95       	ret

00001aee <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue,
                              BaseType_t * const pxHigherPriorityTaskWoken )
{
    1aee:	df 93       	push	r29
    1af0:	cf 93       	push	r28
    1af2:	cd b7       	in	r28, 0x3d	; 61
    1af4:	de b7       	in	r29, 0x3e	; 62
    1af6:	2a 97       	sbiw	r28, 0x0a	; 10
    1af8:	0f b6       	in	r0, 0x3f	; 63
    1afa:	f8 94       	cli
    1afc:	de bf       	out	0x3e, r29	; 62
    1afe:	0f be       	out	0x3f, r0	; 63
    1b00:	cd bf       	out	0x3d, r28	; 61
    1b02:	98 87       	std	Y+8, r25	; 0x08
    1b04:	8f 83       	std	Y+7, r24	; 0x07
    1b06:	7a 87       	std	Y+10, r23	; 0x0a
    1b08:	69 87       	std	Y+9, r22	; 0x09
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    Queue_t * const pxQueue = xQueue;
    1b0a:	8f 81       	ldd	r24, Y+7	; 0x07
    1b0c:	98 85       	ldd	r25, Y+8	; 0x08
    1b0e:	9c 83       	std	Y+4, r25	; 0x04
    1b10:	8b 83       	std	Y+3, r24	; 0x03
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1b12:	1d 82       	std	Y+5, r1	; 0x05
    {
        const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1b14:	eb 81       	ldd	r30, Y+3	; 0x03
    1b16:	fc 81       	ldd	r31, Y+4	; 0x04
    1b18:	82 8d       	ldd	r24, Z+26	; 0x1a
    1b1a:	8a 83       	std	Y+2, r24	; 0x02

        /* When the queue is used to implement a semaphore no data is ever
         * moved through the queue but it is still valid to see if the queue 'has
         * space'. */
        if( uxMessagesWaiting < pxQueue->uxLength )
    1b1c:	eb 81       	ldd	r30, Y+3	; 0x03
    1b1e:	fc 81       	ldd	r31, Y+4	; 0x04
    1b20:	93 8d       	ldd	r25, Z+27	; 0x1b
    1b22:	8a 81       	ldd	r24, Y+2	; 0x02
    1b24:	89 17       	cp	r24, r25
    1b26:	48 f5       	brcc	.+82     	; 0x1b7a <xQueueGiveFromISR+0x8c>
        {
            const int8_t cTxLock = pxQueue->cTxLock;
    1b28:	eb 81       	ldd	r30, Y+3	; 0x03
    1b2a:	fc 81       	ldd	r31, Y+4	; 0x04
    1b2c:	86 8d       	ldd	r24, Z+30	; 0x1e
    1b2e:	89 83       	std	Y+1, r24	; 0x01
             * holder - and if there is a mutex holder then the mutex cannot be
             * given from an ISR.  As this is the ISR version of the function it
             * can be assumed there is no mutex holder and no need to determine if
             * priority disinheritance is needed.  Simply increase the count of
             * messages (semaphores) available. */
            pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    1b30:	8a 81       	ldd	r24, Y+2	; 0x02
    1b32:	8f 5f       	subi	r24, 0xFF	; 255
    1b34:	eb 81       	ldd	r30, Y+3	; 0x03
    1b36:	fc 81       	ldd	r31, Y+4	; 0x04
    1b38:	82 8f       	std	Z+26, r24	; 0x1a

            /* The event list is not altered if the queue is locked.  This will
             * be done when the queue is unlocked later. */
            if( cTxLock == queueUNLOCKED )
    1b3a:	89 81       	ldd	r24, Y+1	; 0x01
    1b3c:	8f 3f       	cpi	r24, 0xFF	; 255
    1b3e:	a9 f4       	brne	.+42     	; 0x1b6a <xQueueGiveFromISR+0x7c>
                            }
                        }
                    }
                #else /* configUSE_QUEUE_SETS */
                    {
                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1b40:	eb 81       	ldd	r30, Y+3	; 0x03
    1b42:	fc 81       	ldd	r31, Y+4	; 0x04
    1b44:	81 89       	ldd	r24, Z+17	; 0x11
    1b46:	88 23       	and	r24, r24
    1b48:	a9 f0       	breq	.+42     	; 0x1b74 <xQueueGiveFromISR+0x86>
                        {
                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1b4a:	8b 81       	ldd	r24, Y+3	; 0x03
    1b4c:	9c 81       	ldd	r25, Y+4	; 0x04
    1b4e:	41 96       	adiw	r24, 0x11	; 17
    1b50:	0e 94 d7 1b 	call	0x37ae	; 0x37ae <xTaskRemoveFromEventList>
    1b54:	88 23       	and	r24, r24
    1b56:	71 f0       	breq	.+28     	; 0x1b74 <xQueueGiveFromISR+0x86>
                            {
                                /* The task waiting has a higher priority so record that a
                                 * context switch is required. */
                                if( pxHigherPriorityTaskWoken != NULL )
    1b58:	89 85       	ldd	r24, Y+9	; 0x09
    1b5a:	9a 85       	ldd	r25, Y+10	; 0x0a
    1b5c:	00 97       	sbiw	r24, 0x00	; 0
    1b5e:	51 f0       	breq	.+20     	; 0x1b74 <xQueueGiveFromISR+0x86>
                                {
                                    *pxHigherPriorityTaskWoken = pdTRUE;
    1b60:	e9 85       	ldd	r30, Y+9	; 0x09
    1b62:	fa 85       	ldd	r31, Y+10	; 0x0a
    1b64:	81 e0       	ldi	r24, 0x01	; 1
    1b66:	80 83       	st	Z, r24
    1b68:	05 c0       	rjmp	.+10     	; 0x1b74 <xQueueGiveFromISR+0x86>
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was posted while it was locked. */
                configASSERT( cTxLock != queueINT8_MAX );

                pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    1b6a:	89 81       	ldd	r24, Y+1	; 0x01
    1b6c:	8f 5f       	subi	r24, 0xFF	; 255
    1b6e:	eb 81       	ldd	r30, Y+3	; 0x03
    1b70:	fc 81       	ldd	r31, Y+4	; 0x04
    1b72:	86 8f       	std	Z+30, r24	; 0x1e
            }

            xReturn = pdPASS;
    1b74:	81 e0       	ldi	r24, 0x01	; 1
    1b76:	8e 83       	std	Y+6, r24	; 0x06
    1b78:	01 c0       	rjmp	.+2      	; 0x1b7c <xQueueGiveFromISR+0x8e>
        }
        else
        {
            traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
            xReturn = errQUEUE_FULL;
    1b7a:	1e 82       	std	Y+6, r1	; 0x06
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    1b7c:	8e 81       	ldd	r24, Y+6	; 0x06
}
    1b7e:	2a 96       	adiw	r28, 0x0a	; 10
    1b80:	0f b6       	in	r0, 0x3f	; 63
    1b82:	f8 94       	cli
    1b84:	de bf       	out	0x3e, r29	; 62
    1b86:	0f be       	out	0x3f, r0	; 63
    1b88:	cd bf       	out	0x3d, r28	; 61
    1b8a:	cf 91       	pop	r28
    1b8c:	df 91       	pop	r29
    1b8e:	08 95       	ret

00001b90 <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue,
                          void * const pvBuffer,
                          TickType_t xTicksToWait )
{
    1b90:	df 93       	push	r29
    1b92:	cf 93       	push	r28
    1b94:	cd b7       	in	r28, 0x3d	; 61
    1b96:	de b7       	in	r29, 0x3e	; 62
    1b98:	2e 97       	sbiw	r28, 0x0e	; 14
    1b9a:	0f b6       	in	r0, 0x3f	; 63
    1b9c:	f8 94       	cli
    1b9e:	de bf       	out	0x3e, r29	; 62
    1ba0:	0f be       	out	0x3f, r0	; 63
    1ba2:	cd bf       	out	0x3d, r28	; 61
    1ba4:	99 87       	std	Y+9, r25	; 0x09
    1ba6:	88 87       	std	Y+8, r24	; 0x08
    1ba8:	7b 87       	std	Y+11, r23	; 0x0b
    1baa:	6a 87       	std	Y+10, r22	; 0x0a
    1bac:	5d 87       	std	Y+13, r21	; 0x0d
    1bae:	4c 87       	std	Y+12, r20	; 0x0c
    BaseType_t xEntryTimeSet = pdFALSE;
    1bb0:	1c 82       	std	Y+4, r1	; 0x04
    TimeOut_t xTimeOut;
    Queue_t * const pxQueue = xQueue;
    1bb2:	88 85       	ldd	r24, Y+8	; 0x08
    1bb4:	99 85       	ldd	r25, Y+9	; 0x09
    1bb6:	9b 83       	std	Y+3, r25	; 0x03
    1bb8:	8a 83       	std	Y+2, r24	; 0x02
    /*lint -save -e904  This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    1bba:	0f b6       	in	r0, 0x3f	; 63
    1bbc:	f8 94       	cli
    1bbe:	0f 92       	push	r0
        {
            const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1bc0:	ea 81       	ldd	r30, Y+2	; 0x02
    1bc2:	fb 81       	ldd	r31, Y+3	; 0x03
    1bc4:	82 8d       	ldd	r24, Z+26	; 0x1a
    1bc6:	89 83       	std	Y+1, r24	; 0x01

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1bc8:	89 81       	ldd	r24, Y+1	; 0x01
    1bca:	88 23       	and	r24, r24
    1bcc:	f9 f0       	breq	.+62     	; 0x1c0c <xQueueReceive+0x7c>
            {
                /* Data available, remove one item. */
                prvCopyDataFromQueue( pxQueue, pvBuffer );
    1bce:	8a 81       	ldd	r24, Y+2	; 0x02
    1bd0:	9b 81       	ldd	r25, Y+3	; 0x03
    1bd2:	2a 85       	ldd	r18, Y+10	; 0x0a
    1bd4:	3b 85       	ldd	r19, Y+11	; 0x0b
    1bd6:	b9 01       	movw	r22, r18
    1bd8:	0e 94 6b 11 	call	0x22d6	; 0x22d6 <prvCopyDataFromQueue>
                traceQUEUE_RECEIVE( pxQueue );
                pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    1bdc:	89 81       	ldd	r24, Y+1	; 0x01
    1bde:	81 50       	subi	r24, 0x01	; 1
    1be0:	ea 81       	ldd	r30, Y+2	; 0x02
    1be2:	fb 81       	ldd	r31, Y+3	; 0x03
    1be4:	82 8f       	std	Z+26, r24	; 0x1a

                /* There is now space in the queue, were any tasks waiting to
                 * post to the queue?  If so, unblock the highest priority waiting
                 * task. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1be6:	ea 81       	ldd	r30, Y+2	; 0x02
    1be8:	fb 81       	ldd	r31, Y+3	; 0x03
    1bea:	80 85       	ldd	r24, Z+8	; 0x08
    1bec:	88 23       	and	r24, r24
    1bee:	49 f0       	breq	.+18     	; 0x1c02 <xQueueReceive+0x72>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1bf0:	8a 81       	ldd	r24, Y+2	; 0x02
    1bf2:	9b 81       	ldd	r25, Y+3	; 0x03
    1bf4:	08 96       	adiw	r24, 0x08	; 8
    1bf6:	0e 94 d7 1b 	call	0x37ae	; 0x37ae <xTaskRemoveFromEventList>
    1bfa:	88 23       	and	r24, r24
    1bfc:	11 f0       	breq	.+4      	; 0x1c02 <xQueueReceive+0x72>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
    1bfe:	0e 94 a6 02 	call	0x54c	; 0x54c <vPortYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
    1c02:	0f 90       	pop	r0
    1c04:	0f be       	out	0x3f, r0	; 63
                return pdPASS;
    1c06:	81 e0       	ldi	r24, 0x01	; 1
    1c08:	8e 87       	std	Y+14, r24	; 0x0e
    1c0a:	63 c0       	rjmp	.+198    	; 0x1cd2 <xQueueReceive+0x142>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    1c0c:	8c 85       	ldd	r24, Y+12	; 0x0c
    1c0e:	9d 85       	ldd	r25, Y+13	; 0x0d
    1c10:	00 97       	sbiw	r24, 0x00	; 0
    1c12:	21 f4       	brne	.+8      	; 0x1c1c <xQueueReceive+0x8c>
                {
                    /* The queue was empty and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
    1c14:	0f 90       	pop	r0
    1c16:	0f be       	out	0x3f, r0	; 63
                    traceQUEUE_RECEIVE_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
    1c18:	1e 86       	std	Y+14, r1	; 0x0e
    1c1a:	5b c0       	rjmp	.+182    	; 0x1cd2 <xQueueReceive+0x142>
                }
                else if( xEntryTimeSet == pdFALSE )
    1c1c:	8c 81       	ldd	r24, Y+4	; 0x04
    1c1e:	88 23       	and	r24, r24
    1c20:	31 f4       	brne	.+12     	; 0x1c2e <xQueueReceive+0x9e>
                {
                    /* The queue was empty and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    1c22:	ce 01       	movw	r24, r28
    1c24:	05 96       	adiw	r24, 0x05	; 5
    1c26:	0e 94 47 1e 	call	0x3c8e	; 0x3c8e <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
    1c2a:	81 e0       	ldi	r24, 0x01	; 1
    1c2c:	8c 83       	std	Y+4, r24	; 0x04
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    1c2e:	0f 90       	pop	r0
    1c30:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can send to and receive from the queue
         * now the critical section has been exited. */

        vTaskSuspendAll();
    1c32:	0e 94 73 17 	call	0x2ee6	; 0x2ee6 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    1c36:	0f b6       	in	r0, 0x3f	; 63
    1c38:	f8 94       	cli
    1c3a:	0f 92       	push	r0
    1c3c:	ea 81       	ldd	r30, Y+2	; 0x02
    1c3e:	fb 81       	ldd	r31, Y+3	; 0x03
    1c40:	85 8d       	ldd	r24, Z+29	; 0x1d
    1c42:	8f 3f       	cpi	r24, 0xFF	; 255
    1c44:	19 f4       	brne	.+6      	; 0x1c4c <xQueueReceive+0xbc>
    1c46:	ea 81       	ldd	r30, Y+2	; 0x02
    1c48:	fb 81       	ldd	r31, Y+3	; 0x03
    1c4a:	15 8e       	std	Z+29, r1	; 0x1d
    1c4c:	ea 81       	ldd	r30, Y+2	; 0x02
    1c4e:	fb 81       	ldd	r31, Y+3	; 0x03
    1c50:	86 8d       	ldd	r24, Z+30	; 0x1e
    1c52:	8f 3f       	cpi	r24, 0xFF	; 255
    1c54:	19 f4       	brne	.+6      	; 0x1c5c <xQueueReceive+0xcc>
    1c56:	ea 81       	ldd	r30, Y+2	; 0x02
    1c58:	fb 81       	ldd	r31, Y+3	; 0x03
    1c5a:	16 8e       	std	Z+30, r1	; 0x1e
    1c5c:	0f 90       	pop	r0
    1c5e:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1c60:	ce 01       	movw	r24, r28
    1c62:	05 96       	adiw	r24, 0x05	; 5
    1c64:	9e 01       	movw	r18, r28
    1c66:	24 5f       	subi	r18, 0xF4	; 244
    1c68:	3f 4f       	sbci	r19, 0xFF	; 255
    1c6a:	b9 01       	movw	r22, r18
    1c6c:	0e 94 60 1e 	call	0x3cc0	; 0x3cc0 <xTaskCheckForTimeOut>
    1c70:	88 23       	and	r24, r24
    1c72:	09 f5       	brne	.+66     	; 0x1cb6 <xQueueReceive+0x126>
        {
            /* The timeout has not expired.  If the queue is still empty place
             * the task on the list of tasks waiting to receive from the queue. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1c74:	8a 81       	ldd	r24, Y+2	; 0x02
    1c76:	9b 81       	ldd	r25, Y+3	; 0x03
    1c78:	0e 94 05 12 	call	0x240a	; 0x240a <prvIsQueueEmpty>
    1c7c:	88 23       	and	r24, r24
    1c7e:	a1 f0       	breq	.+40     	; 0x1ca8 <xQueueReceive+0x118>
            {
                traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1c80:	8a 81       	ldd	r24, Y+2	; 0x02
    1c82:	9b 81       	ldd	r25, Y+3	; 0x03
    1c84:	41 96       	adiw	r24, 0x11	; 17
    1c86:	2c 85       	ldd	r18, Y+12	; 0x0c
    1c88:	3d 85       	ldd	r19, Y+13	; 0x0d
    1c8a:	b9 01       	movw	r22, r18
    1c8c:	0e 94 50 1b 	call	0x36a0	; 0x36a0 <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
    1c90:	8a 81       	ldd	r24, Y+2	; 0x02
    1c92:	9b 81       	ldd	r25, Y+3	; 0x03
    1c94:	0e 94 b2 11 	call	0x2364	; 0x2364 <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
    1c98:	0e 94 7f 17 	call	0x2efe	; 0x2efe <xTaskResumeAll>
    1c9c:	88 23       	and	r24, r24
    1c9e:	09 f0       	breq	.+2      	; 0x1ca2 <xQueueReceive+0x112>
    1ca0:	8c cf       	rjmp	.-232    	; 0x1bba <xQueueReceive+0x2a>
                {
                    portYIELD_WITHIN_API();
    1ca2:	0e 94 a6 02 	call	0x54c	; 0x54c <vPortYield>
    1ca6:	89 cf       	rjmp	.-238    	; 0x1bba <xQueueReceive+0x2a>
            }
            else
            {
                /* The queue contains data again.  Loop back to try and read the
                 * data. */
                prvUnlockQueue( pxQueue );
    1ca8:	8a 81       	ldd	r24, Y+2	; 0x02
    1caa:	9b 81       	ldd	r25, Y+3	; 0x03
    1cac:	0e 94 b2 11 	call	0x2364	; 0x2364 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    1cb0:	0e 94 7f 17 	call	0x2efe	; 0x2efe <xTaskResumeAll>
    1cb4:	82 cf       	rjmp	.-252    	; 0x1bba <xQueueReceive+0x2a>
        }
        else
        {
            /* Timed out.  If there is no data in the queue exit, otherwise loop
             * back and attempt to read the data. */
            prvUnlockQueue( pxQueue );
    1cb6:	8a 81       	ldd	r24, Y+2	; 0x02
    1cb8:	9b 81       	ldd	r25, Y+3	; 0x03
    1cba:	0e 94 b2 11 	call	0x2364	; 0x2364 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    1cbe:	0e 94 7f 17 	call	0x2efe	; 0x2efe <xTaskResumeAll>

            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1cc2:	8a 81       	ldd	r24, Y+2	; 0x02
    1cc4:	9b 81       	ldd	r25, Y+3	; 0x03
    1cc6:	0e 94 05 12 	call	0x240a	; 0x240a <prvIsQueueEmpty>
    1cca:	88 23       	and	r24, r24
    1ccc:	09 f4       	brne	.+2      	; 0x1cd0 <xQueueReceive+0x140>
    1cce:	75 cf       	rjmp	.-278    	; 0x1bba <xQueueReceive+0x2a>
            {
                traceQUEUE_RECEIVE_FAILED( pxQueue );
                return errQUEUE_EMPTY;
    1cd0:	1e 86       	std	Y+14, r1	; 0x0e
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
    1cd2:	8e 85       	ldd	r24, Y+14	; 0x0e
}
    1cd4:	2e 96       	adiw	r28, 0x0e	; 14
    1cd6:	0f b6       	in	r0, 0x3f	; 63
    1cd8:	f8 94       	cli
    1cda:	de bf       	out	0x3e, r29	; 62
    1cdc:	0f be       	out	0x3f, r0	; 63
    1cde:	cd bf       	out	0x3d, r28	; 61
    1ce0:	cf 91       	pop	r28
    1ce2:	df 91       	pop	r29
    1ce4:	08 95       	ret

00001ce6 <xQueueSemaphoreTake>:
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue,
                                TickType_t xTicksToWait )
{
    1ce6:	df 93       	push	r29
    1ce8:	cf 93       	push	r28
    1cea:	cd b7       	in	r28, 0x3d	; 61
    1cec:	de b7       	in	r29, 0x3e	; 62
    1cee:	2c 97       	sbiw	r28, 0x0c	; 12
    1cf0:	0f b6       	in	r0, 0x3f	; 63
    1cf2:	f8 94       	cli
    1cf4:	de bf       	out	0x3e, r29	; 62
    1cf6:	0f be       	out	0x3f, r0	; 63
    1cf8:	cd bf       	out	0x3d, r28	; 61
    1cfa:	99 87       	std	Y+9, r25	; 0x09
    1cfc:	88 87       	std	Y+8, r24	; 0x08
    1cfe:	7b 87       	std	Y+11, r23	; 0x0b
    1d00:	6a 87       	std	Y+10, r22	; 0x0a
    BaseType_t xEntryTimeSet = pdFALSE;
    1d02:	1c 82       	std	Y+4, r1	; 0x04
    TimeOut_t xTimeOut;
    Queue_t * const pxQueue = xQueue;
    1d04:	88 85       	ldd	r24, Y+8	; 0x08
    1d06:	99 85       	ldd	r25, Y+9	; 0x09
    1d08:	9b 83       	std	Y+3, r25	; 0x03
    1d0a:	8a 83       	std	Y+2, r24	; 0x02
    /*lint -save -e904 This function relaxes the coding standard somewhat to allow return
     * statements within the function itself.  This is done in the interest
     * of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    1d0c:	0f b6       	in	r0, 0x3f	; 63
    1d0e:	f8 94       	cli
    1d10:	0f 92       	push	r0
        {
            /* Semaphores are queues with an item size of 0, and where the
             * number of messages in the queue is the semaphore's count value. */
            const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
    1d12:	ea 81       	ldd	r30, Y+2	; 0x02
    1d14:	fb 81       	ldd	r31, Y+3	; 0x03
    1d16:	82 8d       	ldd	r24, Z+26	; 0x1a
    1d18:	89 83       	std	Y+1, r24	; 0x01

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxSemaphoreCount > ( UBaseType_t ) 0 )
    1d1a:	89 81       	ldd	r24, Y+1	; 0x01
    1d1c:	88 23       	and	r24, r24
    1d1e:	c1 f0       	breq	.+48     	; 0x1d50 <xQueueSemaphoreTake+0x6a>
            {
                traceQUEUE_RECEIVE( pxQueue );

                /* Semaphores are queues with a data size of zero and where the
                 * messages waiting is the semaphore's count.  Reduce the count. */
                pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
    1d20:	89 81       	ldd	r24, Y+1	; 0x01
    1d22:	81 50       	subi	r24, 0x01	; 1
    1d24:	ea 81       	ldd	r30, Y+2	; 0x02
    1d26:	fb 81       	ldd	r31, Y+3	; 0x03
    1d28:	82 8f       	std	Z+26, r24	; 0x1a
                    }
                #endif /* configUSE_MUTEXES */

                /* Check to see if other tasks are blocked waiting to give the
                 * semaphore, and if so, unblock the highest priority such task. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1d2a:	ea 81       	ldd	r30, Y+2	; 0x02
    1d2c:	fb 81       	ldd	r31, Y+3	; 0x03
    1d2e:	80 85       	ldd	r24, Z+8	; 0x08
    1d30:	88 23       	and	r24, r24
    1d32:	49 f0       	breq	.+18     	; 0x1d46 <xQueueSemaphoreTake+0x60>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1d34:	8a 81       	ldd	r24, Y+2	; 0x02
    1d36:	9b 81       	ldd	r25, Y+3	; 0x03
    1d38:	08 96       	adiw	r24, 0x08	; 8
    1d3a:	0e 94 d7 1b 	call	0x37ae	; 0x37ae <xTaskRemoveFromEventList>
    1d3e:	88 23       	and	r24, r24
    1d40:	11 f0       	breq	.+4      	; 0x1d46 <xQueueSemaphoreTake+0x60>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
    1d42:	0e 94 a6 02 	call	0x54c	; 0x54c <vPortYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
    1d46:	0f 90       	pop	r0
    1d48:	0f be       	out	0x3f, r0	; 63
                return pdPASS;
    1d4a:	81 e0       	ldi	r24, 0x01	; 1
    1d4c:	8c 87       	std	Y+12, r24	; 0x0c
    1d4e:	63 c0       	rjmp	.+198    	; 0x1e16 <xQueueSemaphoreTake+0x130>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    1d50:	8a 85       	ldd	r24, Y+10	; 0x0a
    1d52:	9b 85       	ldd	r25, Y+11	; 0x0b
    1d54:	00 97       	sbiw	r24, 0x00	; 0
    1d56:	21 f4       	brne	.+8      	; 0x1d60 <xQueueSemaphoreTake+0x7a>
                        }
                    #endif /* configUSE_MUTEXES */

                    /* The semaphore count was 0 and no block time is specified
                     * (or the block time has expired) so exit now. */
                    taskEXIT_CRITICAL();
    1d58:	0f 90       	pop	r0
    1d5a:	0f be       	out	0x3f, r0	; 63
                    traceQUEUE_RECEIVE_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
    1d5c:	1c 86       	std	Y+12, r1	; 0x0c
    1d5e:	5b c0       	rjmp	.+182    	; 0x1e16 <xQueueSemaphoreTake+0x130>
                }
                else if( xEntryTimeSet == pdFALSE )
    1d60:	8c 81       	ldd	r24, Y+4	; 0x04
    1d62:	88 23       	and	r24, r24
    1d64:	31 f4       	brne	.+12     	; 0x1d72 <xQueueSemaphoreTake+0x8c>
                {
                    /* The semaphore count was 0 and a block time was specified
                     * so configure the timeout structure ready to block. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    1d66:	ce 01       	movw	r24, r28
    1d68:	05 96       	adiw	r24, 0x05	; 5
    1d6a:	0e 94 47 1e 	call	0x3c8e	; 0x3c8e <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
    1d6e:	81 e0       	ldi	r24, 0x01	; 1
    1d70:	8c 83       	std	Y+4, r24	; 0x04
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    1d72:	0f 90       	pop	r0
    1d74:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can give to and take from the semaphore
         * now the critical section has been exited. */

        vTaskSuspendAll();
    1d76:	0e 94 73 17 	call	0x2ee6	; 0x2ee6 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    1d7a:	0f b6       	in	r0, 0x3f	; 63
    1d7c:	f8 94       	cli
    1d7e:	0f 92       	push	r0
    1d80:	ea 81       	ldd	r30, Y+2	; 0x02
    1d82:	fb 81       	ldd	r31, Y+3	; 0x03
    1d84:	85 8d       	ldd	r24, Z+29	; 0x1d
    1d86:	8f 3f       	cpi	r24, 0xFF	; 255
    1d88:	19 f4       	brne	.+6      	; 0x1d90 <xQueueSemaphoreTake+0xaa>
    1d8a:	ea 81       	ldd	r30, Y+2	; 0x02
    1d8c:	fb 81       	ldd	r31, Y+3	; 0x03
    1d8e:	15 8e       	std	Z+29, r1	; 0x1d
    1d90:	ea 81       	ldd	r30, Y+2	; 0x02
    1d92:	fb 81       	ldd	r31, Y+3	; 0x03
    1d94:	86 8d       	ldd	r24, Z+30	; 0x1e
    1d96:	8f 3f       	cpi	r24, 0xFF	; 255
    1d98:	19 f4       	brne	.+6      	; 0x1da0 <xQueueSemaphoreTake+0xba>
    1d9a:	ea 81       	ldd	r30, Y+2	; 0x02
    1d9c:	fb 81       	ldd	r31, Y+3	; 0x03
    1d9e:	16 8e       	std	Z+30, r1	; 0x1e
    1da0:	0f 90       	pop	r0
    1da2:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1da4:	ce 01       	movw	r24, r28
    1da6:	05 96       	adiw	r24, 0x05	; 5
    1da8:	9e 01       	movw	r18, r28
    1daa:	26 5f       	subi	r18, 0xF6	; 246
    1dac:	3f 4f       	sbci	r19, 0xFF	; 255
    1dae:	b9 01       	movw	r22, r18
    1db0:	0e 94 60 1e 	call	0x3cc0	; 0x3cc0 <xTaskCheckForTimeOut>
    1db4:	88 23       	and	r24, r24
    1db6:	09 f5       	brne	.+66     	; 0x1dfa <xQueueSemaphoreTake+0x114>
        {
            /* A block time is specified and not expired.  If the semaphore
             * count is 0 then enter the Blocked state to wait for a semaphore to
             * become available.  As semaphores are implemented with queues the
             * queue being empty is equivalent to the semaphore count being 0. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1db8:	8a 81       	ldd	r24, Y+2	; 0x02
    1dba:	9b 81       	ldd	r25, Y+3	; 0x03
    1dbc:	0e 94 05 12 	call	0x240a	; 0x240a <prvIsQueueEmpty>
    1dc0:	88 23       	and	r24, r24
    1dc2:	a1 f0       	breq	.+40     	; 0x1dec <xQueueSemaphoreTake+0x106>
                            mtCOVERAGE_TEST_MARKER();
                        }
                    }
                #endif /* if ( configUSE_MUTEXES == 1 ) */

                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1dc4:	8a 81       	ldd	r24, Y+2	; 0x02
    1dc6:	9b 81       	ldd	r25, Y+3	; 0x03
    1dc8:	41 96       	adiw	r24, 0x11	; 17
    1dca:	2a 85       	ldd	r18, Y+10	; 0x0a
    1dcc:	3b 85       	ldd	r19, Y+11	; 0x0b
    1dce:	b9 01       	movw	r22, r18
    1dd0:	0e 94 50 1b 	call	0x36a0	; 0x36a0 <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
    1dd4:	8a 81       	ldd	r24, Y+2	; 0x02
    1dd6:	9b 81       	ldd	r25, Y+3	; 0x03
    1dd8:	0e 94 b2 11 	call	0x2364	; 0x2364 <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
    1ddc:	0e 94 7f 17 	call	0x2efe	; 0x2efe <xTaskResumeAll>
    1de0:	88 23       	and	r24, r24
    1de2:	09 f0       	breq	.+2      	; 0x1de6 <xQueueSemaphoreTake+0x100>
    1de4:	93 cf       	rjmp	.-218    	; 0x1d0c <xQueueSemaphoreTake+0x26>
                {
                    portYIELD_WITHIN_API();
    1de6:	0e 94 a6 02 	call	0x54c	; 0x54c <vPortYield>
    1dea:	90 cf       	rjmp	.-224    	; 0x1d0c <xQueueSemaphoreTake+0x26>
            }
            else
            {
                /* There was no timeout and the semaphore count was not 0, so
                 * attempt to take the semaphore again. */
                prvUnlockQueue( pxQueue );
    1dec:	8a 81       	ldd	r24, Y+2	; 0x02
    1dee:	9b 81       	ldd	r25, Y+3	; 0x03
    1df0:	0e 94 b2 11 	call	0x2364	; 0x2364 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    1df4:	0e 94 7f 17 	call	0x2efe	; 0x2efe <xTaskResumeAll>
    1df8:	89 cf       	rjmp	.-238    	; 0x1d0c <xQueueSemaphoreTake+0x26>
            }
        }
        else
        {
            /* Timed out. */
            prvUnlockQueue( pxQueue );
    1dfa:	8a 81       	ldd	r24, Y+2	; 0x02
    1dfc:	9b 81       	ldd	r25, Y+3	; 0x03
    1dfe:	0e 94 b2 11 	call	0x2364	; 0x2364 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    1e02:	0e 94 7f 17 	call	0x2efe	; 0x2efe <xTaskResumeAll>

            /* If the semaphore count is 0 exit now as the timeout has
             * expired.  Otherwise return to attempt to take the semaphore that is
             * known to be available.  As semaphores are implemented by queues the
             * queue being empty is equivalent to the semaphore count being 0. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1e06:	8a 81       	ldd	r24, Y+2	; 0x02
    1e08:	9b 81       	ldd	r25, Y+3	; 0x03
    1e0a:	0e 94 05 12 	call	0x240a	; 0x240a <prvIsQueueEmpty>
    1e0e:	88 23       	and	r24, r24
    1e10:	09 f4       	brne	.+2      	; 0x1e14 <xQueueSemaphoreTake+0x12e>
    1e12:	7c cf       	rjmp	.-264    	; 0x1d0c <xQueueSemaphoreTake+0x26>
                        }
                    }
                #endif /* configUSE_MUTEXES */

                traceQUEUE_RECEIVE_FAILED( pxQueue );
                return errQUEUE_EMPTY;
    1e14:	1c 86       	std	Y+12, r1	; 0x0c
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
    1e16:	8c 85       	ldd	r24, Y+12	; 0x0c
}
    1e18:	2c 96       	adiw	r28, 0x0c	; 12
    1e1a:	0f b6       	in	r0, 0x3f	; 63
    1e1c:	f8 94       	cli
    1e1e:	de bf       	out	0x3e, r29	; 62
    1e20:	0f be       	out	0x3f, r0	; 63
    1e22:	cd bf       	out	0x3d, r28	; 61
    1e24:	cf 91       	pop	r28
    1e26:	df 91       	pop	r29
    1e28:	08 95       	ret

00001e2a <xQueuePeek>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeek( QueueHandle_t xQueue,
                       void * const pvBuffer,
                       TickType_t xTicksToWait )
{
    1e2a:	df 93       	push	r29
    1e2c:	cf 93       	push	r28
    1e2e:	cd b7       	in	r28, 0x3d	; 61
    1e30:	de b7       	in	r29, 0x3e	; 62
    1e32:	60 97       	sbiw	r28, 0x10	; 16
    1e34:	0f b6       	in	r0, 0x3f	; 63
    1e36:	f8 94       	cli
    1e38:	de bf       	out	0x3e, r29	; 62
    1e3a:	0f be       	out	0x3f, r0	; 63
    1e3c:	cd bf       	out	0x3d, r28	; 61
    1e3e:	9b 87       	std	Y+11, r25	; 0x0b
    1e40:	8a 87       	std	Y+10, r24	; 0x0a
    1e42:	7d 87       	std	Y+13, r23	; 0x0d
    1e44:	6c 87       	std	Y+12, r22	; 0x0c
    1e46:	5f 87       	std	Y+15, r21	; 0x0f
    1e48:	4e 87       	std	Y+14, r20	; 0x0e
    BaseType_t xEntryTimeSet = pdFALSE;
    1e4a:	1e 82       	std	Y+6, r1	; 0x06
    TimeOut_t xTimeOut;
    int8_t * pcOriginalReadPosition;
    Queue_t * const pxQueue = xQueue;
    1e4c:	8a 85       	ldd	r24, Y+10	; 0x0a
    1e4e:	9b 85       	ldd	r25, Y+11	; 0x0b
    1e50:	9b 83       	std	Y+3, r25	; 0x03
    1e52:	8a 83       	std	Y+2, r24	; 0x02
    /*lint -save -e904  This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    1e54:	0f b6       	in	r0, 0x3f	; 63
    1e56:	f8 94       	cli
    1e58:	0f 92       	push	r0
        {
            const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1e5a:	ea 81       	ldd	r30, Y+2	; 0x02
    1e5c:	fb 81       	ldd	r31, Y+3	; 0x03
    1e5e:	82 8d       	ldd	r24, Z+26	; 0x1a
    1e60:	89 83       	std	Y+1, r24	; 0x01

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1e62:	89 81       	ldd	r24, Y+1	; 0x01
    1e64:	88 23       	and	r24, r24
    1e66:	31 f1       	breq	.+76     	; 0x1eb4 <xQueuePeek+0x8a>
            {
                /* Remember the read position so it can be reset after the data
                 * is read from the queue as this function is only peeking the
                 * data, not removing it. */
                pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    1e68:	ea 81       	ldd	r30, Y+2	; 0x02
    1e6a:	fb 81       	ldd	r31, Y+3	; 0x03
    1e6c:	86 81       	ldd	r24, Z+6	; 0x06
    1e6e:	97 81       	ldd	r25, Z+7	; 0x07
    1e70:	9d 83       	std	Y+5, r25	; 0x05
    1e72:	8c 83       	std	Y+4, r24	; 0x04

                prvCopyDataFromQueue( pxQueue, pvBuffer );
    1e74:	8a 81       	ldd	r24, Y+2	; 0x02
    1e76:	9b 81       	ldd	r25, Y+3	; 0x03
    1e78:	2c 85       	ldd	r18, Y+12	; 0x0c
    1e7a:	3d 85       	ldd	r19, Y+13	; 0x0d
    1e7c:	b9 01       	movw	r22, r18
    1e7e:	0e 94 6b 11 	call	0x22d6	; 0x22d6 <prvCopyDataFromQueue>
                traceQUEUE_PEEK( pxQueue );

                /* The data is not being removed, so reset the read pointer. */
                pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    1e82:	ea 81       	ldd	r30, Y+2	; 0x02
    1e84:	fb 81       	ldd	r31, Y+3	; 0x03
    1e86:	8c 81       	ldd	r24, Y+4	; 0x04
    1e88:	9d 81       	ldd	r25, Y+5	; 0x05
    1e8a:	97 83       	std	Z+7, r25	; 0x07
    1e8c:	86 83       	std	Z+6, r24	; 0x06

                /* The data is being left in the queue, so see if there are
                 * any other tasks waiting for the data. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1e8e:	ea 81       	ldd	r30, Y+2	; 0x02
    1e90:	fb 81       	ldd	r31, Y+3	; 0x03
    1e92:	81 89       	ldd	r24, Z+17	; 0x11
    1e94:	88 23       	and	r24, r24
    1e96:	49 f0       	breq	.+18     	; 0x1eaa <xQueuePeek+0x80>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1e98:	8a 81       	ldd	r24, Y+2	; 0x02
    1e9a:	9b 81       	ldd	r25, Y+3	; 0x03
    1e9c:	41 96       	adiw	r24, 0x11	; 17
    1e9e:	0e 94 d7 1b 	call	0x37ae	; 0x37ae <xTaskRemoveFromEventList>
    1ea2:	88 23       	and	r24, r24
    1ea4:	11 f0       	breq	.+4      	; 0x1eaa <xQueuePeek+0x80>
                    {
                        /* The task waiting has a higher priority than this task. */
                        queueYIELD_IF_USING_PREEMPTION();
    1ea6:	0e 94 a6 02 	call	0x54c	; 0x54c <vPortYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
    1eaa:	0f 90       	pop	r0
    1eac:	0f be       	out	0x3f, r0	; 63
                return pdPASS;
    1eae:	81 e0       	ldi	r24, 0x01	; 1
    1eb0:	88 8b       	std	Y+16, r24	; 0x10
    1eb2:	63 c0       	rjmp	.+198    	; 0x1f7a <xQueuePeek+0x150>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    1eb4:	8e 85       	ldd	r24, Y+14	; 0x0e
    1eb6:	9f 85       	ldd	r25, Y+15	; 0x0f
    1eb8:	00 97       	sbiw	r24, 0x00	; 0
    1eba:	21 f4       	brne	.+8      	; 0x1ec4 <xQueuePeek+0x9a>
                {
                    /* The queue was empty and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
    1ebc:	0f 90       	pop	r0
    1ebe:	0f be       	out	0x3f, r0	; 63
                    traceQUEUE_PEEK_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
    1ec0:	18 8a       	std	Y+16, r1	; 0x10
    1ec2:	5b c0       	rjmp	.+182    	; 0x1f7a <xQueuePeek+0x150>
                }
                else if( xEntryTimeSet == pdFALSE )
    1ec4:	8e 81       	ldd	r24, Y+6	; 0x06
    1ec6:	88 23       	and	r24, r24
    1ec8:	31 f4       	brne	.+12     	; 0x1ed6 <xQueuePeek+0xac>
                {
                    /* The queue was empty and a block time was specified so
                     * configure the timeout structure ready to enter the blocked
                     * state. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    1eca:	ce 01       	movw	r24, r28
    1ecc:	07 96       	adiw	r24, 0x07	; 7
    1ece:	0e 94 47 1e 	call	0x3c8e	; 0x3c8e <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
    1ed2:	81 e0       	ldi	r24, 0x01	; 1
    1ed4:	8e 83       	std	Y+6, r24	; 0x06
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    1ed6:	0f 90       	pop	r0
    1ed8:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can send to and receive from the queue
         * now that the critical section has been exited. */

        vTaskSuspendAll();
    1eda:	0e 94 73 17 	call	0x2ee6	; 0x2ee6 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    1ede:	0f b6       	in	r0, 0x3f	; 63
    1ee0:	f8 94       	cli
    1ee2:	0f 92       	push	r0
    1ee4:	ea 81       	ldd	r30, Y+2	; 0x02
    1ee6:	fb 81       	ldd	r31, Y+3	; 0x03
    1ee8:	85 8d       	ldd	r24, Z+29	; 0x1d
    1eea:	8f 3f       	cpi	r24, 0xFF	; 255
    1eec:	19 f4       	brne	.+6      	; 0x1ef4 <xQueuePeek+0xca>
    1eee:	ea 81       	ldd	r30, Y+2	; 0x02
    1ef0:	fb 81       	ldd	r31, Y+3	; 0x03
    1ef2:	15 8e       	std	Z+29, r1	; 0x1d
    1ef4:	ea 81       	ldd	r30, Y+2	; 0x02
    1ef6:	fb 81       	ldd	r31, Y+3	; 0x03
    1ef8:	86 8d       	ldd	r24, Z+30	; 0x1e
    1efa:	8f 3f       	cpi	r24, 0xFF	; 255
    1efc:	19 f4       	brne	.+6      	; 0x1f04 <xQueuePeek+0xda>
    1efe:	ea 81       	ldd	r30, Y+2	; 0x02
    1f00:	fb 81       	ldd	r31, Y+3	; 0x03
    1f02:	16 8e       	std	Z+30, r1	; 0x1e
    1f04:	0f 90       	pop	r0
    1f06:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1f08:	ce 01       	movw	r24, r28
    1f0a:	07 96       	adiw	r24, 0x07	; 7
    1f0c:	9e 01       	movw	r18, r28
    1f0e:	22 5f       	subi	r18, 0xF2	; 242
    1f10:	3f 4f       	sbci	r19, 0xFF	; 255
    1f12:	b9 01       	movw	r22, r18
    1f14:	0e 94 60 1e 	call	0x3cc0	; 0x3cc0 <xTaskCheckForTimeOut>
    1f18:	88 23       	and	r24, r24
    1f1a:	09 f5       	brne	.+66     	; 0x1f5e <xQueuePeek+0x134>
        {
            /* Timeout has not expired yet, check to see if there is data in the
            * queue now, and if not enter the Blocked state to wait for data. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1f1c:	8a 81       	ldd	r24, Y+2	; 0x02
    1f1e:	9b 81       	ldd	r25, Y+3	; 0x03
    1f20:	0e 94 05 12 	call	0x240a	; 0x240a <prvIsQueueEmpty>
    1f24:	88 23       	and	r24, r24
    1f26:	a1 f0       	breq	.+40     	; 0x1f50 <xQueuePeek+0x126>
            {
                traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1f28:	8a 81       	ldd	r24, Y+2	; 0x02
    1f2a:	9b 81       	ldd	r25, Y+3	; 0x03
    1f2c:	41 96       	adiw	r24, 0x11	; 17
    1f2e:	2e 85       	ldd	r18, Y+14	; 0x0e
    1f30:	3f 85       	ldd	r19, Y+15	; 0x0f
    1f32:	b9 01       	movw	r22, r18
    1f34:	0e 94 50 1b 	call	0x36a0	; 0x36a0 <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
    1f38:	8a 81       	ldd	r24, Y+2	; 0x02
    1f3a:	9b 81       	ldd	r25, Y+3	; 0x03
    1f3c:	0e 94 b2 11 	call	0x2364	; 0x2364 <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
    1f40:	0e 94 7f 17 	call	0x2efe	; 0x2efe <xTaskResumeAll>
    1f44:	88 23       	and	r24, r24
    1f46:	09 f0       	breq	.+2      	; 0x1f4a <xQueuePeek+0x120>
    1f48:	85 cf       	rjmp	.-246    	; 0x1e54 <xQueuePeek+0x2a>
                {
                    portYIELD_WITHIN_API();
    1f4a:	0e 94 a6 02 	call	0x54c	; 0x54c <vPortYield>
    1f4e:	82 cf       	rjmp	.-252    	; 0x1e54 <xQueuePeek+0x2a>
            }
            else
            {
                /* There is data in the queue now, so don't enter the blocked
                 * state, instead return to try and obtain the data. */
                prvUnlockQueue( pxQueue );
    1f50:	8a 81       	ldd	r24, Y+2	; 0x02
    1f52:	9b 81       	ldd	r25, Y+3	; 0x03
    1f54:	0e 94 b2 11 	call	0x2364	; 0x2364 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    1f58:	0e 94 7f 17 	call	0x2efe	; 0x2efe <xTaskResumeAll>
    1f5c:	7b cf       	rjmp	.-266    	; 0x1e54 <xQueuePeek+0x2a>
        }
        else
        {
            /* The timeout has expired.  If there is still no data in the queue
             * exit, otherwise go back and try to read the data again. */
            prvUnlockQueue( pxQueue );
    1f5e:	8a 81       	ldd	r24, Y+2	; 0x02
    1f60:	9b 81       	ldd	r25, Y+3	; 0x03
    1f62:	0e 94 b2 11 	call	0x2364	; 0x2364 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    1f66:	0e 94 7f 17 	call	0x2efe	; 0x2efe <xTaskResumeAll>

            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1f6a:	8a 81       	ldd	r24, Y+2	; 0x02
    1f6c:	9b 81       	ldd	r25, Y+3	; 0x03
    1f6e:	0e 94 05 12 	call	0x240a	; 0x240a <prvIsQueueEmpty>
    1f72:	88 23       	and	r24, r24
    1f74:	09 f4       	brne	.+2      	; 0x1f78 <xQueuePeek+0x14e>
    1f76:	6e cf       	rjmp	.-292    	; 0x1e54 <xQueuePeek+0x2a>
            {
                traceQUEUE_PEEK_FAILED( pxQueue );
                return errQUEUE_EMPTY;
    1f78:	18 8a       	std	Y+16, r1	; 0x10
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
    1f7a:	88 89       	ldd	r24, Y+16	; 0x10
}
    1f7c:	60 96       	adiw	r28, 0x10	; 16
    1f7e:	0f b6       	in	r0, 0x3f	; 63
    1f80:	f8 94       	cli
    1f82:	de bf       	out	0x3e, r29	; 62
    1f84:	0f be       	out	0x3f, r0	; 63
    1f86:	cd bf       	out	0x3d, r28	; 61
    1f88:	cf 91       	pop	r28
    1f8a:	df 91       	pop	r29
    1f8c:	08 95       	ret

00001f8e <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue,
                                 void * const pvBuffer,
                                 BaseType_t * const pxHigherPriorityTaskWoken )
{
    1f8e:	df 93       	push	r29
    1f90:	cf 93       	push	r28
    1f92:	cd b7       	in	r28, 0x3d	; 61
    1f94:	de b7       	in	r29, 0x3e	; 62
    1f96:	2c 97       	sbiw	r28, 0x0c	; 12
    1f98:	0f b6       	in	r0, 0x3f	; 63
    1f9a:	f8 94       	cli
    1f9c:	de bf       	out	0x3e, r29	; 62
    1f9e:	0f be       	out	0x3f, r0	; 63
    1fa0:	cd bf       	out	0x3d, r28	; 61
    1fa2:	98 87       	std	Y+8, r25	; 0x08
    1fa4:	8f 83       	std	Y+7, r24	; 0x07
    1fa6:	7a 87       	std	Y+10, r23	; 0x0a
    1fa8:	69 87       	std	Y+9, r22	; 0x09
    1faa:	5c 87       	std	Y+12, r21	; 0x0c
    1fac:	4b 87       	std	Y+11, r20	; 0x0b
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    Queue_t * const pxQueue = xQueue;
    1fae:	8f 81       	ldd	r24, Y+7	; 0x07
    1fb0:	98 85       	ldd	r25, Y+8	; 0x08
    1fb2:	9c 83       	std	Y+4, r25	; 0x04
    1fb4:	8b 83       	std	Y+3, r24	; 0x03
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1fb6:	1d 82       	std	Y+5, r1	; 0x05
    {
        const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1fb8:	eb 81       	ldd	r30, Y+3	; 0x03
    1fba:	fc 81       	ldd	r31, Y+4	; 0x04
    1fbc:	82 8d       	ldd	r24, Z+26	; 0x1a
    1fbe:	8a 83       	std	Y+2, r24	; 0x02

        /* Cannot block in an ISR, so check there is data available. */
        if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1fc0:	8a 81       	ldd	r24, Y+2	; 0x02
    1fc2:	88 23       	and	r24, r24
    1fc4:	81 f1       	breq	.+96     	; 0x2026 <xQueueReceiveFromISR+0x98>
        {
            const int8_t cRxLock = pxQueue->cRxLock;
    1fc6:	eb 81       	ldd	r30, Y+3	; 0x03
    1fc8:	fc 81       	ldd	r31, Y+4	; 0x04
    1fca:	85 8d       	ldd	r24, Z+29	; 0x1d
    1fcc:	89 83       	std	Y+1, r24	; 0x01

            traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

            prvCopyDataFromQueue( pxQueue, pvBuffer );
    1fce:	8b 81       	ldd	r24, Y+3	; 0x03
    1fd0:	9c 81       	ldd	r25, Y+4	; 0x04
    1fd2:	29 85       	ldd	r18, Y+9	; 0x09
    1fd4:	3a 85       	ldd	r19, Y+10	; 0x0a
    1fd6:	b9 01       	movw	r22, r18
    1fd8:	0e 94 6b 11 	call	0x22d6	; 0x22d6 <prvCopyDataFromQueue>
            pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    1fdc:	8a 81       	ldd	r24, Y+2	; 0x02
    1fde:	81 50       	subi	r24, 0x01	; 1
    1fe0:	eb 81       	ldd	r30, Y+3	; 0x03
    1fe2:	fc 81       	ldd	r31, Y+4	; 0x04
    1fe4:	82 8f       	std	Z+26, r24	; 0x1a

            /* If the queue is locked the event list will not be modified.
             * Instead update the lock count so the task that unlocks the queue
             * will know that an ISR has removed data while the queue was
             * locked. */
            if( cRxLock == queueUNLOCKED )
    1fe6:	89 81       	ldd	r24, Y+1	; 0x01
    1fe8:	8f 3f       	cpi	r24, 0xFF	; 255
    1fea:	a9 f4       	brne	.+42     	; 0x2016 <xQueueReceiveFromISR+0x88>
            {
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1fec:	eb 81       	ldd	r30, Y+3	; 0x03
    1fee:	fc 81       	ldd	r31, Y+4	; 0x04
    1ff0:	80 85       	ldd	r24, Z+8	; 0x08
    1ff2:	88 23       	and	r24, r24
    1ff4:	a9 f0       	breq	.+42     	; 0x2020 <xQueueReceiveFromISR+0x92>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1ff6:	8b 81       	ldd	r24, Y+3	; 0x03
    1ff8:	9c 81       	ldd	r25, Y+4	; 0x04
    1ffa:	08 96       	adiw	r24, 0x08	; 8
    1ffc:	0e 94 d7 1b 	call	0x37ae	; 0x37ae <xTaskRemoveFromEventList>
    2000:	88 23       	and	r24, r24
    2002:	71 f0       	breq	.+28     	; 0x2020 <xQueueReceiveFromISR+0x92>
                    {
                        /* The task waiting has a higher priority than us so
                         * force a context switch. */
                        if( pxHigherPriorityTaskWoken != NULL )
    2004:	8b 85       	ldd	r24, Y+11	; 0x0b
    2006:	9c 85       	ldd	r25, Y+12	; 0x0c
    2008:	00 97       	sbiw	r24, 0x00	; 0
    200a:	51 f0       	breq	.+20     	; 0x2020 <xQueueReceiveFromISR+0x92>
                        {
                            *pxHigherPriorityTaskWoken = pdTRUE;
    200c:	eb 85       	ldd	r30, Y+11	; 0x0b
    200e:	fc 85       	ldd	r31, Y+12	; 0x0c
    2010:	81 e0       	ldi	r24, 0x01	; 1
    2012:	80 83       	st	Z, r24
    2014:	05 c0       	rjmp	.+10     	; 0x2020 <xQueueReceiveFromISR+0x92>
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was removed while it was locked. */
                configASSERT( cRxLock != queueINT8_MAX );

                pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
    2016:	89 81       	ldd	r24, Y+1	; 0x01
    2018:	8f 5f       	subi	r24, 0xFF	; 255
    201a:	eb 81       	ldd	r30, Y+3	; 0x03
    201c:	fc 81       	ldd	r31, Y+4	; 0x04
    201e:	85 8f       	std	Z+29, r24	; 0x1d
            }

            xReturn = pdPASS;
    2020:	81 e0       	ldi	r24, 0x01	; 1
    2022:	8e 83       	std	Y+6, r24	; 0x06
    2024:	01 c0       	rjmp	.+2      	; 0x2028 <xQueueReceiveFromISR+0x9a>
        }
        else
        {
            xReturn = pdFAIL;
    2026:	1e 82       	std	Y+6, r1	; 0x06
            traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    2028:	8e 81       	ldd	r24, Y+6	; 0x06
}
    202a:	2c 96       	adiw	r28, 0x0c	; 12
    202c:	0f b6       	in	r0, 0x3f	; 63
    202e:	f8 94       	cli
    2030:	de bf       	out	0x3e, r29	; 62
    2032:	0f be       	out	0x3f, r0	; 63
    2034:	cd bf       	out	0x3d, r28	; 61
    2036:	cf 91       	pop	r28
    2038:	df 91       	pop	r29
    203a:	08 95       	ret

0000203c <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,
                              void * const pvBuffer )
{
    203c:	df 93       	push	r29
    203e:	cf 93       	push	r28
    2040:	cd b7       	in	r28, 0x3d	; 61
    2042:	de b7       	in	r29, 0x3e	; 62
    2044:	2a 97       	sbiw	r28, 0x0a	; 10
    2046:	0f b6       	in	r0, 0x3f	; 63
    2048:	f8 94       	cli
    204a:	de bf       	out	0x3e, r29	; 62
    204c:	0f be       	out	0x3f, r0	; 63
    204e:	cd bf       	out	0x3d, r28	; 61
    2050:	98 87       	std	Y+8, r25	; 0x08
    2052:	8f 83       	std	Y+7, r24	; 0x07
    2054:	7a 87       	std	Y+10, r23	; 0x0a
    2056:	69 87       	std	Y+9, r22	; 0x09
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    int8_t * pcOriginalReadPosition;
    Queue_t * const pxQueue = xQueue;
    2058:	8f 81       	ldd	r24, Y+7	; 0x07
    205a:	98 85       	ldd	r25, Y+8	; 0x08
    205c:	9a 83       	std	Y+2, r25	; 0x02
    205e:	89 83       	std	Y+1, r24	; 0x01
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2060:	1d 82       	std	Y+5, r1	; 0x05
    {
        /* Cannot block in an ISR, so check there is data available. */
        if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    2062:	e9 81       	ldd	r30, Y+1	; 0x01
    2064:	fa 81       	ldd	r31, Y+2	; 0x02
    2066:	82 8d       	ldd	r24, Z+26	; 0x1a
    2068:	88 23       	and	r24, r24
    206a:	b1 f0       	breq	.+44     	; 0x2098 <xQueuePeekFromISR+0x5c>
        {
            traceQUEUE_PEEK_FROM_ISR( pxQueue );

            /* Remember the read position so it can be reset as nothing is
             * actually being removed from the queue. */
            pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    206c:	e9 81       	ldd	r30, Y+1	; 0x01
    206e:	fa 81       	ldd	r31, Y+2	; 0x02
    2070:	86 81       	ldd	r24, Z+6	; 0x06
    2072:	97 81       	ldd	r25, Z+7	; 0x07
    2074:	9c 83       	std	Y+4, r25	; 0x04
    2076:	8b 83       	std	Y+3, r24	; 0x03
            prvCopyDataFromQueue( pxQueue, pvBuffer );
    2078:	89 81       	ldd	r24, Y+1	; 0x01
    207a:	9a 81       	ldd	r25, Y+2	; 0x02
    207c:	29 85       	ldd	r18, Y+9	; 0x09
    207e:	3a 85       	ldd	r19, Y+10	; 0x0a
    2080:	b9 01       	movw	r22, r18
    2082:	0e 94 6b 11 	call	0x22d6	; 0x22d6 <prvCopyDataFromQueue>
            pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    2086:	e9 81       	ldd	r30, Y+1	; 0x01
    2088:	fa 81       	ldd	r31, Y+2	; 0x02
    208a:	8b 81       	ldd	r24, Y+3	; 0x03
    208c:	9c 81       	ldd	r25, Y+4	; 0x04
    208e:	97 83       	std	Z+7, r25	; 0x07
    2090:	86 83       	std	Z+6, r24	; 0x06

            xReturn = pdPASS;
    2092:	81 e0       	ldi	r24, 0x01	; 1
    2094:	8e 83       	std	Y+6, r24	; 0x06
    2096:	01 c0       	rjmp	.+2      	; 0x209a <xQueuePeekFromISR+0x5e>
        }
        else
        {
            xReturn = pdFAIL;
    2098:	1e 82       	std	Y+6, r1	; 0x06
            traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    209a:	8e 81       	ldd	r24, Y+6	; 0x06
}
    209c:	2a 96       	adiw	r28, 0x0a	; 10
    209e:	0f b6       	in	r0, 0x3f	; 63
    20a0:	f8 94       	cli
    20a2:	de bf       	out	0x3e, r29	; 62
    20a4:	0f be       	out	0x3f, r0	; 63
    20a6:	cd bf       	out	0x3d, r28	; 61
    20a8:	cf 91       	pop	r28
    20aa:	df 91       	pop	r29
    20ac:	08 95       	ret

000020ae <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
    20ae:	df 93       	push	r29
    20b0:	cf 93       	push	r28
    20b2:	00 d0       	rcall	.+0      	; 0x20b4 <uxQueueMessagesWaiting+0x6>
    20b4:	0f 92       	push	r0
    20b6:	cd b7       	in	r28, 0x3d	; 61
    20b8:	de b7       	in	r29, 0x3e	; 62
    20ba:	9b 83       	std	Y+3, r25	; 0x03
    20bc:	8a 83       	std	Y+2, r24	; 0x02
    UBaseType_t uxReturn;

    configASSERT( xQueue );

    taskENTER_CRITICAL();
    20be:	0f b6       	in	r0, 0x3f	; 63
    20c0:	f8 94       	cli
    20c2:	0f 92       	push	r0
    {
        uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    20c4:	ea 81       	ldd	r30, Y+2	; 0x02
    20c6:	fb 81       	ldd	r31, Y+3	; 0x03
    20c8:	82 8d       	ldd	r24, Z+26	; 0x1a
    20ca:	89 83       	std	Y+1, r24	; 0x01
    }
    taskEXIT_CRITICAL();
    20cc:	0f 90       	pop	r0
    20ce:	0f be       	out	0x3f, r0	; 63

    return uxReturn;
    20d0:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    20d2:	0f 90       	pop	r0
    20d4:	0f 90       	pop	r0
    20d6:	0f 90       	pop	r0
    20d8:	cf 91       	pop	r28
    20da:	df 91       	pop	r29
    20dc:	08 95       	ret

000020de <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
    20de:	df 93       	push	r29
    20e0:	cf 93       	push	r28
    20e2:	00 d0       	rcall	.+0      	; 0x20e4 <uxQueueSpacesAvailable+0x6>
    20e4:	00 d0       	rcall	.+0      	; 0x20e6 <uxQueueSpacesAvailable+0x8>
    20e6:	0f 92       	push	r0
    20e8:	cd b7       	in	r28, 0x3d	; 61
    20ea:	de b7       	in	r29, 0x3e	; 62
    20ec:	9d 83       	std	Y+5, r25	; 0x05
    20ee:	8c 83       	std	Y+4, r24	; 0x04
    UBaseType_t uxReturn;
    Queue_t * const pxQueue = xQueue;
    20f0:	8c 81       	ldd	r24, Y+4	; 0x04
    20f2:	9d 81       	ldd	r25, Y+5	; 0x05
    20f4:	9a 83       	std	Y+2, r25	; 0x02
    20f6:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );

    taskENTER_CRITICAL();
    20f8:	0f b6       	in	r0, 0x3f	; 63
    20fa:	f8 94       	cli
    20fc:	0f 92       	push	r0
    {
        uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    20fe:	e9 81       	ldd	r30, Y+1	; 0x01
    2100:	fa 81       	ldd	r31, Y+2	; 0x02
    2102:	93 8d       	ldd	r25, Z+27	; 0x1b
    2104:	e9 81       	ldd	r30, Y+1	; 0x01
    2106:	fa 81       	ldd	r31, Y+2	; 0x02
    2108:	82 8d       	ldd	r24, Z+26	; 0x1a
    210a:	29 2f       	mov	r18, r25
    210c:	28 1b       	sub	r18, r24
    210e:	82 2f       	mov	r24, r18
    2110:	8b 83       	std	Y+3, r24	; 0x03
    }
    taskEXIT_CRITICAL();
    2112:	0f 90       	pop	r0
    2114:	0f be       	out	0x3f, r0	; 63

    return uxReturn;
    2116:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    2118:	0f 90       	pop	r0
    211a:	0f 90       	pop	r0
    211c:	0f 90       	pop	r0
    211e:	0f 90       	pop	r0
    2120:	0f 90       	pop	r0
    2122:	cf 91       	pop	r28
    2124:	df 91       	pop	r29
    2126:	08 95       	ret

00002128 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
    2128:	df 93       	push	r29
    212a:	cf 93       	push	r28
    212c:	00 d0       	rcall	.+0      	; 0x212e <uxQueueMessagesWaitingFromISR+0x6>
    212e:	00 d0       	rcall	.+0      	; 0x2130 <uxQueueMessagesWaitingFromISR+0x8>
    2130:	0f 92       	push	r0
    2132:	cd b7       	in	r28, 0x3d	; 61
    2134:	de b7       	in	r29, 0x3e	; 62
    2136:	9d 83       	std	Y+5, r25	; 0x05
    2138:	8c 83       	std	Y+4, r24	; 0x04
    UBaseType_t uxReturn;
    Queue_t * const pxQueue = xQueue;
    213a:	8c 81       	ldd	r24, Y+4	; 0x04
    213c:	9d 81       	ldd	r25, Y+5	; 0x05
    213e:	9a 83       	std	Y+2, r25	; 0x02
    2140:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );
    uxReturn = pxQueue->uxMessagesWaiting;
    2142:	e9 81       	ldd	r30, Y+1	; 0x01
    2144:	fa 81       	ldd	r31, Y+2	; 0x02
    2146:	82 8d       	ldd	r24, Z+26	; 0x1a
    2148:	8b 83       	std	Y+3, r24	; 0x03

    return uxReturn;
    214a:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    214c:	0f 90       	pop	r0
    214e:	0f 90       	pop	r0
    2150:	0f 90       	pop	r0
    2152:	0f 90       	pop	r0
    2154:	0f 90       	pop	r0
    2156:	cf 91       	pop	r28
    2158:	df 91       	pop	r29
    215a:	08 95       	ret

0000215c <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
    215c:	df 93       	push	r29
    215e:	cf 93       	push	r28
    2160:	00 d0       	rcall	.+0      	; 0x2162 <vQueueDelete+0x6>
    2162:	00 d0       	rcall	.+0      	; 0x2164 <vQueueDelete+0x8>
    2164:	cd b7       	in	r28, 0x3d	; 61
    2166:	de b7       	in	r29, 0x3e	; 62
    2168:	9c 83       	std	Y+4, r25	; 0x04
    216a:	8b 83       	std	Y+3, r24	; 0x03
    Queue_t * const pxQueue = xQueue;
    216c:	8b 81       	ldd	r24, Y+3	; 0x03
    216e:	9c 81       	ldd	r25, Y+4	; 0x04
    2170:	9a 83       	std	Y+2, r25	; 0x02
    2172:	89 83       	std	Y+1, r24	; 0x01

    #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
        {
            /* The queue can only have been allocated dynamically - free it
             * again. */
            vPortFree( pxQueue );
    2174:	89 81       	ldd	r24, Y+1	; 0x01
    2176:	9a 81       	ldd	r25, Y+2	; 0x02
    2178:	0e 94 c1 00 	call	0x182	; 0x182 <vPortFree>
            /* The queue must have been statically allocated, so is not going to be
             * deleted.  Avoid compiler warnings about the unused parameter. */
            ( void ) pxQueue;
        }
    #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
    217c:	0f 90       	pop	r0
    217e:	0f 90       	pop	r0
    2180:	0f 90       	pop	r0
    2182:	0f 90       	pop	r0
    2184:	cf 91       	pop	r28
    2186:	df 91       	pop	r29
    2188:	08 95       	ret

0000218a <prvCopyDataToQueue>:
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue,
                                      const void * pvItemToQueue,
                                      const BaseType_t xPosition )
{
    218a:	df 93       	push	r29
    218c:	cf 93       	push	r28
    218e:	cd b7       	in	r28, 0x3d	; 61
    2190:	de b7       	in	r29, 0x3e	; 62
    2192:	27 97       	sbiw	r28, 0x07	; 7
    2194:	0f b6       	in	r0, 0x3f	; 63
    2196:	f8 94       	cli
    2198:	de bf       	out	0x3e, r29	; 62
    219a:	0f be       	out	0x3f, r0	; 63
    219c:	cd bf       	out	0x3d, r28	; 61
    219e:	9c 83       	std	Y+4, r25	; 0x04
    21a0:	8b 83       	std	Y+3, r24	; 0x03
    21a2:	7e 83       	std	Y+6, r23	; 0x06
    21a4:	6d 83       	std	Y+5, r22	; 0x05
    21a6:	4f 83       	std	Y+7, r20	; 0x07
    BaseType_t xReturn = pdFALSE;
    21a8:	1a 82       	std	Y+2, r1	; 0x02
    UBaseType_t uxMessagesWaiting;

    /* This function is called from a critical section. */

    uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    21aa:	eb 81       	ldd	r30, Y+3	; 0x03
    21ac:	fc 81       	ldd	r31, Y+4	; 0x04
    21ae:	82 8d       	ldd	r24, Z+26	; 0x1a
    21b0:	89 83       	std	Y+1, r24	; 0x01

    if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    21b2:	eb 81       	ldd	r30, Y+3	; 0x03
    21b4:	fc 81       	ldd	r31, Y+4	; 0x04
    21b6:	84 8d       	ldd	r24, Z+28	; 0x1c
    21b8:	88 23       	and	r24, r24
    21ba:	09 f4       	brne	.+2      	; 0x21be <prvCopyDataToQueue+0x34>
    21bc:	7d c0       	rjmp	.+250    	; 0x22b8 <prvCopyDataToQueue+0x12e>
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        #endif /* configUSE_MUTEXES */
    }
    else if( xPosition == queueSEND_TO_BACK )
    21be:	8f 81       	ldd	r24, Y+7	; 0x07
    21c0:	88 23       	and	r24, r24
    21c2:	99 f5       	brne	.+102    	; 0x222a <prvCopyDataToQueue+0xa0>
    {
        ( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    21c4:	eb 81       	ldd	r30, Y+3	; 0x03
    21c6:	fc 81       	ldd	r31, Y+4	; 0x04
    21c8:	62 81       	ldd	r22, Z+2	; 0x02
    21ca:	73 81       	ldd	r23, Z+3	; 0x03
    21cc:	eb 81       	ldd	r30, Y+3	; 0x03
    21ce:	fc 81       	ldd	r31, Y+4	; 0x04
    21d0:	84 8d       	ldd	r24, Z+28	; 0x1c
    21d2:	48 2f       	mov	r20, r24
    21d4:	50 e0       	ldi	r21, 0x00	; 0
    21d6:	2d 81       	ldd	r18, Y+5	; 0x05
    21d8:	3e 81       	ldd	r19, Y+6	; 0x06
    21da:	cb 01       	movw	r24, r22
    21dc:	b9 01       	movw	r22, r18
    21de:	0e 94 ff 27 	call	0x4ffe	; 0x4ffe <memcpy>
        pxQueue->pcWriteTo += pxQueue->uxItemSize;                                                       /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    21e2:	eb 81       	ldd	r30, Y+3	; 0x03
    21e4:	fc 81       	ldd	r31, Y+4	; 0x04
    21e6:	22 81       	ldd	r18, Z+2	; 0x02
    21e8:	33 81       	ldd	r19, Z+3	; 0x03
    21ea:	eb 81       	ldd	r30, Y+3	; 0x03
    21ec:	fc 81       	ldd	r31, Y+4	; 0x04
    21ee:	84 8d       	ldd	r24, Z+28	; 0x1c
    21f0:	88 2f       	mov	r24, r24
    21f2:	90 e0       	ldi	r25, 0x00	; 0
    21f4:	82 0f       	add	r24, r18
    21f6:	93 1f       	adc	r25, r19
    21f8:	eb 81       	ldd	r30, Y+3	; 0x03
    21fa:	fc 81       	ldd	r31, Y+4	; 0x04
    21fc:	93 83       	std	Z+3, r25	; 0x03
    21fe:	82 83       	std	Z+2, r24	; 0x02

        if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail )                                             /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    2200:	eb 81       	ldd	r30, Y+3	; 0x03
    2202:	fc 81       	ldd	r31, Y+4	; 0x04
    2204:	22 81       	ldd	r18, Z+2	; 0x02
    2206:	33 81       	ldd	r19, Z+3	; 0x03
    2208:	eb 81       	ldd	r30, Y+3	; 0x03
    220a:	fc 81       	ldd	r31, Y+4	; 0x04
    220c:	84 81       	ldd	r24, Z+4	; 0x04
    220e:	95 81       	ldd	r25, Z+5	; 0x05
    2210:	28 17       	cp	r18, r24
    2212:	39 07       	cpc	r19, r25
    2214:	08 f4       	brcc	.+2      	; 0x2218 <prvCopyDataToQueue+0x8e>
    2216:	50 c0       	rjmp	.+160    	; 0x22b8 <prvCopyDataToQueue+0x12e>
        {
            pxQueue->pcWriteTo = pxQueue->pcHead;
    2218:	eb 81       	ldd	r30, Y+3	; 0x03
    221a:	fc 81       	ldd	r31, Y+4	; 0x04
    221c:	80 81       	ld	r24, Z
    221e:	91 81       	ldd	r25, Z+1	; 0x01
    2220:	eb 81       	ldd	r30, Y+3	; 0x03
    2222:	fc 81       	ldd	r31, Y+4	; 0x04
    2224:	93 83       	std	Z+3, r25	; 0x03
    2226:	82 83       	std	Z+2, r24	; 0x02
    2228:	47 c0       	rjmp	.+142    	; 0x22b8 <prvCopyDataToQueue+0x12e>
            mtCOVERAGE_TEST_MARKER();
        }
    }
    else
    {
        ( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
    222a:	eb 81       	ldd	r30, Y+3	; 0x03
    222c:	fc 81       	ldd	r31, Y+4	; 0x04
    222e:	66 81       	ldd	r22, Z+6	; 0x06
    2230:	77 81       	ldd	r23, Z+7	; 0x07
    2232:	eb 81       	ldd	r30, Y+3	; 0x03
    2234:	fc 81       	ldd	r31, Y+4	; 0x04
    2236:	84 8d       	ldd	r24, Z+28	; 0x1c
    2238:	48 2f       	mov	r20, r24
    223a:	50 e0       	ldi	r21, 0x00	; 0
    223c:	2d 81       	ldd	r18, Y+5	; 0x05
    223e:	3e 81       	ldd	r19, Y+6	; 0x06
    2240:	cb 01       	movw	r24, r22
    2242:	b9 01       	movw	r22, r18
    2244:	0e 94 ff 27 	call	0x4ffe	; 0x4ffe <memcpy>
        pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
    2248:	eb 81       	ldd	r30, Y+3	; 0x03
    224a:	fc 81       	ldd	r31, Y+4	; 0x04
    224c:	26 81       	ldd	r18, Z+6	; 0x06
    224e:	37 81       	ldd	r19, Z+7	; 0x07
    2250:	eb 81       	ldd	r30, Y+3	; 0x03
    2252:	fc 81       	ldd	r31, Y+4	; 0x04
    2254:	84 8d       	ldd	r24, Z+28	; 0x1c
    2256:	88 2f       	mov	r24, r24
    2258:	90 e0       	ldi	r25, 0x00	; 0
    225a:	90 95       	com	r25
    225c:	81 95       	neg	r24
    225e:	9f 4f       	sbci	r25, 0xFF	; 255
    2260:	82 0f       	add	r24, r18
    2262:	93 1f       	adc	r25, r19
    2264:	eb 81       	ldd	r30, Y+3	; 0x03
    2266:	fc 81       	ldd	r31, Y+4	; 0x04
    2268:	97 83       	std	Z+7, r25	; 0x07
    226a:	86 83       	std	Z+6, r24	; 0x06

        if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    226c:	eb 81       	ldd	r30, Y+3	; 0x03
    226e:	fc 81       	ldd	r31, Y+4	; 0x04
    2270:	26 81       	ldd	r18, Z+6	; 0x06
    2272:	37 81       	ldd	r19, Z+7	; 0x07
    2274:	eb 81       	ldd	r30, Y+3	; 0x03
    2276:	fc 81       	ldd	r31, Y+4	; 0x04
    2278:	80 81       	ld	r24, Z
    227a:	91 81       	ldd	r25, Z+1	; 0x01
    227c:	28 17       	cp	r18, r24
    227e:	39 07       	cpc	r19, r25
    2280:	90 f4       	brcc	.+36     	; 0x22a6 <prvCopyDataToQueue+0x11c>
        {
            pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
    2282:	eb 81       	ldd	r30, Y+3	; 0x03
    2284:	fc 81       	ldd	r31, Y+4	; 0x04
    2286:	24 81       	ldd	r18, Z+4	; 0x04
    2288:	35 81       	ldd	r19, Z+5	; 0x05
    228a:	eb 81       	ldd	r30, Y+3	; 0x03
    228c:	fc 81       	ldd	r31, Y+4	; 0x04
    228e:	84 8d       	ldd	r24, Z+28	; 0x1c
    2290:	88 2f       	mov	r24, r24
    2292:	90 e0       	ldi	r25, 0x00	; 0
    2294:	90 95       	com	r25
    2296:	81 95       	neg	r24
    2298:	9f 4f       	sbci	r25, 0xFF	; 255
    229a:	82 0f       	add	r24, r18
    229c:	93 1f       	adc	r25, r19
    229e:	eb 81       	ldd	r30, Y+3	; 0x03
    22a0:	fc 81       	ldd	r31, Y+4	; 0x04
    22a2:	97 83       	std	Z+7, r25	; 0x07
    22a4:	86 83       	std	Z+6, r24	; 0x06
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        if( xPosition == queueOVERWRITE )
    22a6:	8f 81       	ldd	r24, Y+7	; 0x07
    22a8:	82 30       	cpi	r24, 0x02	; 2
    22aa:	31 f4       	brne	.+12     	; 0x22b8 <prvCopyDataToQueue+0x12e>
        {
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    22ac:	89 81       	ldd	r24, Y+1	; 0x01
    22ae:	88 23       	and	r24, r24
    22b0:	19 f0       	breq	.+6      	; 0x22b8 <prvCopyDataToQueue+0x12e>
            {
                /* An item is not being added but overwritten, so subtract
                 * one from the recorded number of items in the queue so when
                 * one is added again below the number of recorded items remains
                 * correct. */
                --uxMessagesWaiting;
    22b2:	89 81       	ldd	r24, Y+1	; 0x01
    22b4:	81 50       	subi	r24, 0x01	; 1
    22b6:	89 83       	std	Y+1, r24	; 0x01
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }

    pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    22b8:	89 81       	ldd	r24, Y+1	; 0x01
    22ba:	8f 5f       	subi	r24, 0xFF	; 255
    22bc:	eb 81       	ldd	r30, Y+3	; 0x03
    22be:	fc 81       	ldd	r31, Y+4	; 0x04
    22c0:	82 8f       	std	Z+26, r24	; 0x1a

    return xReturn;
    22c2:	8a 81       	ldd	r24, Y+2	; 0x02
}
    22c4:	27 96       	adiw	r28, 0x07	; 7
    22c6:	0f b6       	in	r0, 0x3f	; 63
    22c8:	f8 94       	cli
    22ca:	de bf       	out	0x3e, r29	; 62
    22cc:	0f be       	out	0x3f, r0	; 63
    22ce:	cd bf       	out	0x3d, r28	; 61
    22d0:	cf 91       	pop	r28
    22d2:	df 91       	pop	r29
    22d4:	08 95       	ret

000022d6 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue,
                                  void * const pvBuffer )
{
    22d6:	df 93       	push	r29
    22d8:	cf 93       	push	r28
    22da:	00 d0       	rcall	.+0      	; 0x22dc <prvCopyDataFromQueue+0x6>
    22dc:	00 d0       	rcall	.+0      	; 0x22de <prvCopyDataFromQueue+0x8>
    22de:	cd b7       	in	r28, 0x3d	; 61
    22e0:	de b7       	in	r29, 0x3e	; 62
    22e2:	9a 83       	std	Y+2, r25	; 0x02
    22e4:	89 83       	std	Y+1, r24	; 0x01
    22e6:	7c 83       	std	Y+4, r23	; 0x04
    22e8:	6b 83       	std	Y+3, r22	; 0x03
    if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    22ea:	e9 81       	ldd	r30, Y+1	; 0x01
    22ec:	fa 81       	ldd	r31, Y+2	; 0x02
    22ee:	84 8d       	ldd	r24, Z+28	; 0x1c
    22f0:	88 23       	and	r24, r24
    22f2:	89 f1       	breq	.+98     	; 0x2356 <prvCopyDataFromQueue+0x80>
    {
        pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;           /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    22f4:	e9 81       	ldd	r30, Y+1	; 0x01
    22f6:	fa 81       	ldd	r31, Y+2	; 0x02
    22f8:	26 81       	ldd	r18, Z+6	; 0x06
    22fa:	37 81       	ldd	r19, Z+7	; 0x07
    22fc:	e9 81       	ldd	r30, Y+1	; 0x01
    22fe:	fa 81       	ldd	r31, Y+2	; 0x02
    2300:	84 8d       	ldd	r24, Z+28	; 0x1c
    2302:	88 2f       	mov	r24, r24
    2304:	90 e0       	ldi	r25, 0x00	; 0
    2306:	82 0f       	add	r24, r18
    2308:	93 1f       	adc	r25, r19
    230a:	e9 81       	ldd	r30, Y+1	; 0x01
    230c:	fa 81       	ldd	r31, Y+2	; 0x02
    230e:	97 83       	std	Z+7, r25	; 0x07
    2310:	86 83       	std	Z+6, r24	; 0x06

        if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    2312:	e9 81       	ldd	r30, Y+1	; 0x01
    2314:	fa 81       	ldd	r31, Y+2	; 0x02
    2316:	26 81       	ldd	r18, Z+6	; 0x06
    2318:	37 81       	ldd	r19, Z+7	; 0x07
    231a:	e9 81       	ldd	r30, Y+1	; 0x01
    231c:	fa 81       	ldd	r31, Y+2	; 0x02
    231e:	84 81       	ldd	r24, Z+4	; 0x04
    2320:	95 81       	ldd	r25, Z+5	; 0x05
    2322:	28 17       	cp	r18, r24
    2324:	39 07       	cpc	r19, r25
    2326:	40 f0       	brcs	.+16     	; 0x2338 <prvCopyDataFromQueue+0x62>
        {
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    2328:	e9 81       	ldd	r30, Y+1	; 0x01
    232a:	fa 81       	ldd	r31, Y+2	; 0x02
    232c:	80 81       	ld	r24, Z
    232e:	91 81       	ldd	r25, Z+1	; 0x01
    2330:	e9 81       	ldd	r30, Y+1	; 0x01
    2332:	fa 81       	ldd	r31, Y+2	; 0x02
    2334:	97 83       	std	Z+7, r25	; 0x07
    2336:	86 83       	std	Z+6, r24	; 0x06
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    2338:	e9 81       	ldd	r30, Y+1	; 0x01
    233a:	fa 81       	ldd	r31, Y+2	; 0x02
    233c:	46 81       	ldd	r20, Z+6	; 0x06
    233e:	57 81       	ldd	r21, Z+7	; 0x07
    2340:	e9 81       	ldd	r30, Y+1	; 0x01
    2342:	fa 81       	ldd	r31, Y+2	; 0x02
    2344:	84 8d       	ldd	r24, Z+28	; 0x1c
    2346:	28 2f       	mov	r18, r24
    2348:	30 e0       	ldi	r19, 0x00	; 0
    234a:	8b 81       	ldd	r24, Y+3	; 0x03
    234c:	9c 81       	ldd	r25, Y+4	; 0x04
    234e:	ba 01       	movw	r22, r20
    2350:	a9 01       	movw	r20, r18
    2352:	0e 94 ff 27 	call	0x4ffe	; 0x4ffe <memcpy>
    }
}
    2356:	0f 90       	pop	r0
    2358:	0f 90       	pop	r0
    235a:	0f 90       	pop	r0
    235c:	0f 90       	pop	r0
    235e:	cf 91       	pop	r28
    2360:	df 91       	pop	r29
    2362:	08 95       	ret

00002364 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    2364:	df 93       	push	r29
    2366:	cf 93       	push	r28
    2368:	00 d0       	rcall	.+0      	; 0x236a <prvUnlockQueue+0x6>
    236a:	00 d0       	rcall	.+0      	; 0x236c <prvUnlockQueue+0x8>
    236c:	cd b7       	in	r28, 0x3d	; 61
    236e:	de b7       	in	r29, 0x3e	; 62
    2370:	9c 83       	std	Y+4, r25	; 0x04
    2372:	8b 83       	std	Y+3, r24	; 0x03

    /* The lock counts contains the number of extra data items placed or
     * removed from the queue while the queue was locked.  When a queue is
     * locked items can be added or removed, but the event lists cannot be
     * updated. */
    taskENTER_CRITICAL();
    2374:	0f b6       	in	r0, 0x3f	; 63
    2376:	f8 94       	cli
    2378:	0f 92       	push	r0
    {
        int8_t cTxLock = pxQueue->cTxLock;
    237a:	eb 81       	ldd	r30, Y+3	; 0x03
    237c:	fc 81       	ldd	r31, Y+4	; 0x04
    237e:	86 8d       	ldd	r24, Z+30	; 0x1e
    2380:	8a 83       	std	Y+2, r24	; 0x02
    2382:	11 c0       	rjmp	.+34     	; 0x23a6 <prvUnlockQueue+0x42>
                }
            #else /* configUSE_QUEUE_SETS */
                {
                    /* Tasks that are removed from the event list will get added to
                     * the pending ready list as the scheduler is still suspended. */
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2384:	eb 81       	ldd	r30, Y+3	; 0x03
    2386:	fc 81       	ldd	r31, Y+4	; 0x04
    2388:	81 89       	ldd	r24, Z+17	; 0x11
    238a:	88 23       	and	r24, r24
    238c:	79 f0       	breq	.+30     	; 0x23ac <prvUnlockQueue+0x48>
                    {
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    238e:	8b 81       	ldd	r24, Y+3	; 0x03
    2390:	9c 81       	ldd	r25, Y+4	; 0x04
    2392:	41 96       	adiw	r24, 0x11	; 17
    2394:	0e 94 d7 1b 	call	0x37ae	; 0x37ae <xTaskRemoveFromEventList>
    2398:	88 23       	and	r24, r24
    239a:	11 f0       	breq	.+4      	; 0x23a0 <prvUnlockQueue+0x3c>
                        {
                            /* The task waiting has a higher priority so record that
                             * a context switch is required. */
                            vTaskMissedYield();
    239c:	0e 94 c7 1e 	call	0x3d8e	; 0x3d8e <vTaskMissedYield>
                        break;
                    }
                }
            #endif /* configUSE_QUEUE_SETS */

            --cTxLock;
    23a0:	8a 81       	ldd	r24, Y+2	; 0x02
    23a2:	81 50       	subi	r24, 0x01	; 1
    23a4:	8a 83       	std	Y+2, r24	; 0x02
    taskENTER_CRITICAL();
    {
        int8_t cTxLock = pxQueue->cTxLock;

        /* See if data was added to the queue while it was locked. */
        while( cTxLock > queueLOCKED_UNMODIFIED )
    23a6:	8a 81       	ldd	r24, Y+2	; 0x02
    23a8:	18 16       	cp	r1, r24
    23aa:	64 f3       	brlt	.-40     	; 0x2384 <prvUnlockQueue+0x20>
            #endif /* configUSE_QUEUE_SETS */

            --cTxLock;
        }

        pxQueue->cTxLock = queueUNLOCKED;
    23ac:	eb 81       	ldd	r30, Y+3	; 0x03
    23ae:	fc 81       	ldd	r31, Y+4	; 0x04
    23b0:	8f ef       	ldi	r24, 0xFF	; 255
    23b2:	86 8f       	std	Z+30, r24	; 0x1e
    }
    taskEXIT_CRITICAL();
    23b4:	0f 90       	pop	r0
    23b6:	0f be       	out	0x3f, r0	; 63

    /* Do the same for the Rx lock. */
    taskENTER_CRITICAL();
    23b8:	0f b6       	in	r0, 0x3f	; 63
    23ba:	f8 94       	cli
    23bc:	0f 92       	push	r0
    {
        int8_t cRxLock = pxQueue->cRxLock;
    23be:	eb 81       	ldd	r30, Y+3	; 0x03
    23c0:	fc 81       	ldd	r31, Y+4	; 0x04
    23c2:	85 8d       	ldd	r24, Z+29	; 0x1d
    23c4:	89 83       	std	Y+1, r24	; 0x01
    23c6:	11 c0       	rjmp	.+34     	; 0x23ea <prvUnlockQueue+0x86>

        while( cRxLock > queueLOCKED_UNMODIFIED )
        {
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    23c8:	eb 81       	ldd	r30, Y+3	; 0x03
    23ca:	fc 81       	ldd	r31, Y+4	; 0x04
    23cc:	80 85       	ldd	r24, Z+8	; 0x08
    23ce:	88 23       	and	r24, r24
    23d0:	79 f0       	breq	.+30     	; 0x23f0 <prvUnlockQueue+0x8c>
            {
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    23d2:	8b 81       	ldd	r24, Y+3	; 0x03
    23d4:	9c 81       	ldd	r25, Y+4	; 0x04
    23d6:	08 96       	adiw	r24, 0x08	; 8
    23d8:	0e 94 d7 1b 	call	0x37ae	; 0x37ae <xTaskRemoveFromEventList>
    23dc:	88 23       	and	r24, r24
    23de:	11 f0       	breq	.+4      	; 0x23e4 <prvUnlockQueue+0x80>
                {
                    vTaskMissedYield();
    23e0:	0e 94 c7 1e 	call	0x3d8e	; 0x3d8e <vTaskMissedYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                --cRxLock;
    23e4:	89 81       	ldd	r24, Y+1	; 0x01
    23e6:	81 50       	subi	r24, 0x01	; 1
    23e8:	89 83       	std	Y+1, r24	; 0x01
    /* Do the same for the Rx lock. */
    taskENTER_CRITICAL();
    {
        int8_t cRxLock = pxQueue->cRxLock;

        while( cRxLock > queueLOCKED_UNMODIFIED )
    23ea:	89 81       	ldd	r24, Y+1	; 0x01
    23ec:	18 16       	cp	r1, r24
    23ee:	64 f3       	brlt	.-40     	; 0x23c8 <prvUnlockQueue+0x64>
            {
                break;
            }
        }

        pxQueue->cRxLock = queueUNLOCKED;
    23f0:	eb 81       	ldd	r30, Y+3	; 0x03
    23f2:	fc 81       	ldd	r31, Y+4	; 0x04
    23f4:	8f ef       	ldi	r24, 0xFF	; 255
    23f6:	85 8f       	std	Z+29, r24	; 0x1d
    }
    taskEXIT_CRITICAL();
    23f8:	0f 90       	pop	r0
    23fa:	0f be       	out	0x3f, r0	; 63
}
    23fc:	0f 90       	pop	r0
    23fe:	0f 90       	pop	r0
    2400:	0f 90       	pop	r0
    2402:	0f 90       	pop	r0
    2404:	cf 91       	pop	r28
    2406:	df 91       	pop	r29
    2408:	08 95       	ret

0000240a <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t * pxQueue )
{
    240a:	df 93       	push	r29
    240c:	cf 93       	push	r28
    240e:	00 d0       	rcall	.+0      	; 0x2410 <prvIsQueueEmpty+0x6>
    2410:	0f 92       	push	r0
    2412:	cd b7       	in	r28, 0x3d	; 61
    2414:	de b7       	in	r29, 0x3e	; 62
    2416:	9b 83       	std	Y+3, r25	; 0x03
    2418:	8a 83       	std	Y+2, r24	; 0x02
    BaseType_t xReturn;

    taskENTER_CRITICAL();
    241a:	0f b6       	in	r0, 0x3f	; 63
    241c:	f8 94       	cli
    241e:	0f 92       	push	r0
    {
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    2420:	ea 81       	ldd	r30, Y+2	; 0x02
    2422:	fb 81       	ldd	r31, Y+3	; 0x03
    2424:	82 8d       	ldd	r24, Z+26	; 0x1a
    2426:	88 23       	and	r24, r24
    2428:	19 f4       	brne	.+6      	; 0x2430 <prvIsQueueEmpty+0x26>
        {
            xReturn = pdTRUE;
    242a:	81 e0       	ldi	r24, 0x01	; 1
    242c:	89 83       	std	Y+1, r24	; 0x01
    242e:	01 c0       	rjmp	.+2      	; 0x2432 <prvIsQueueEmpty+0x28>
        }
        else
        {
            xReturn = pdFALSE;
    2430:	19 82       	std	Y+1, r1	; 0x01
        }
    }
    taskEXIT_CRITICAL();
    2432:	0f 90       	pop	r0
    2434:	0f be       	out	0x3f, r0	; 63

    return xReturn;
    2436:	89 81       	ldd	r24, Y+1	; 0x01
}
    2438:	0f 90       	pop	r0
    243a:	0f 90       	pop	r0
    243c:	0f 90       	pop	r0
    243e:	cf 91       	pop	r28
    2440:	df 91       	pop	r29
    2442:	08 95       	ret

00002444 <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
    2444:	df 93       	push	r29
    2446:	cf 93       	push	r28
    2448:	00 d0       	rcall	.+0      	; 0x244a <xQueueIsQueueEmptyFromISR+0x6>
    244a:	00 d0       	rcall	.+0      	; 0x244c <xQueueIsQueueEmptyFromISR+0x8>
    244c:	0f 92       	push	r0
    244e:	cd b7       	in	r28, 0x3d	; 61
    2450:	de b7       	in	r29, 0x3e	; 62
    2452:	9d 83       	std	Y+5, r25	; 0x05
    2454:	8c 83       	std	Y+4, r24	; 0x04
    BaseType_t xReturn;
    Queue_t * const pxQueue = xQueue;
    2456:	8c 81       	ldd	r24, Y+4	; 0x04
    2458:	9d 81       	ldd	r25, Y+5	; 0x05
    245a:	9a 83       	std	Y+2, r25	; 0x02
    245c:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );

    if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    245e:	e9 81       	ldd	r30, Y+1	; 0x01
    2460:	fa 81       	ldd	r31, Y+2	; 0x02
    2462:	82 8d       	ldd	r24, Z+26	; 0x1a
    2464:	88 23       	and	r24, r24
    2466:	19 f4       	brne	.+6      	; 0x246e <xQueueIsQueueEmptyFromISR+0x2a>
    {
        xReturn = pdTRUE;
    2468:	81 e0       	ldi	r24, 0x01	; 1
    246a:	8b 83       	std	Y+3, r24	; 0x03
    246c:	01 c0       	rjmp	.+2      	; 0x2470 <xQueueIsQueueEmptyFromISR+0x2c>
    }
    else
    {
        xReturn = pdFALSE;
    246e:	1b 82       	std	Y+3, r1	; 0x03
    }

    return xReturn;
    2470:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    2472:	0f 90       	pop	r0
    2474:	0f 90       	pop	r0
    2476:	0f 90       	pop	r0
    2478:	0f 90       	pop	r0
    247a:	0f 90       	pop	r0
    247c:	cf 91       	pop	r28
    247e:	df 91       	pop	r29
    2480:	08 95       	ret

00002482 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t * pxQueue )
{
    2482:	df 93       	push	r29
    2484:	cf 93       	push	r28
    2486:	00 d0       	rcall	.+0      	; 0x2488 <prvIsQueueFull+0x6>
    2488:	0f 92       	push	r0
    248a:	cd b7       	in	r28, 0x3d	; 61
    248c:	de b7       	in	r29, 0x3e	; 62
    248e:	9b 83       	std	Y+3, r25	; 0x03
    2490:	8a 83       	std	Y+2, r24	; 0x02
    BaseType_t xReturn;

    taskENTER_CRITICAL();
    2492:	0f b6       	in	r0, 0x3f	; 63
    2494:	f8 94       	cli
    2496:	0f 92       	push	r0
    {
        if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    2498:	ea 81       	ldd	r30, Y+2	; 0x02
    249a:	fb 81       	ldd	r31, Y+3	; 0x03
    249c:	92 8d       	ldd	r25, Z+26	; 0x1a
    249e:	ea 81       	ldd	r30, Y+2	; 0x02
    24a0:	fb 81       	ldd	r31, Y+3	; 0x03
    24a2:	83 8d       	ldd	r24, Z+27	; 0x1b
    24a4:	98 17       	cp	r25, r24
    24a6:	19 f4       	brne	.+6      	; 0x24ae <prvIsQueueFull+0x2c>
        {
            xReturn = pdTRUE;
    24a8:	81 e0       	ldi	r24, 0x01	; 1
    24aa:	89 83       	std	Y+1, r24	; 0x01
    24ac:	01 c0       	rjmp	.+2      	; 0x24b0 <prvIsQueueFull+0x2e>
        }
        else
        {
            xReturn = pdFALSE;
    24ae:	19 82       	std	Y+1, r1	; 0x01
        }
    }
    taskEXIT_CRITICAL();
    24b0:	0f 90       	pop	r0
    24b2:	0f be       	out	0x3f, r0	; 63

    return xReturn;
    24b4:	89 81       	ldd	r24, Y+1	; 0x01
}
    24b6:	0f 90       	pop	r0
    24b8:	0f 90       	pop	r0
    24ba:	0f 90       	pop	r0
    24bc:	cf 91       	pop	r28
    24be:	df 91       	pop	r29
    24c0:	08 95       	ret

000024c2 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    24c2:	df 93       	push	r29
    24c4:	cf 93       	push	r28
    24c6:	00 d0       	rcall	.+0      	; 0x24c8 <xQueueIsQueueFullFromISR+0x6>
    24c8:	00 d0       	rcall	.+0      	; 0x24ca <xQueueIsQueueFullFromISR+0x8>
    24ca:	0f 92       	push	r0
    24cc:	cd b7       	in	r28, 0x3d	; 61
    24ce:	de b7       	in	r29, 0x3e	; 62
    24d0:	9d 83       	std	Y+5, r25	; 0x05
    24d2:	8c 83       	std	Y+4, r24	; 0x04
    BaseType_t xReturn;
    Queue_t * const pxQueue = xQueue;
    24d4:	8c 81       	ldd	r24, Y+4	; 0x04
    24d6:	9d 81       	ldd	r25, Y+5	; 0x05
    24d8:	9a 83       	std	Y+2, r25	; 0x02
    24da:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );

    if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    24dc:	e9 81       	ldd	r30, Y+1	; 0x01
    24de:	fa 81       	ldd	r31, Y+2	; 0x02
    24e0:	92 8d       	ldd	r25, Z+26	; 0x1a
    24e2:	e9 81       	ldd	r30, Y+1	; 0x01
    24e4:	fa 81       	ldd	r31, Y+2	; 0x02
    24e6:	83 8d       	ldd	r24, Z+27	; 0x1b
    24e8:	98 17       	cp	r25, r24
    24ea:	19 f4       	brne	.+6      	; 0x24f2 <xQueueIsQueueFullFromISR+0x30>
    {
        xReturn = pdTRUE;
    24ec:	81 e0       	ldi	r24, 0x01	; 1
    24ee:	8b 83       	std	Y+3, r24	; 0x03
    24f0:	01 c0       	rjmp	.+2      	; 0x24f4 <xQueueIsQueueFullFromISR+0x32>
    }
    else
    {
        xReturn = pdFALSE;
    24f2:	1b 82       	std	Y+3, r1	; 0x03
    }

    return xReturn;
    24f4:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    24f6:	0f 90       	pop	r0
    24f8:	0f 90       	pop	r0
    24fa:	0f 90       	pop	r0
    24fc:	0f 90       	pop	r0
    24fe:	0f 90       	pop	r0
    2500:	cf 91       	pop	r28
    2502:	df 91       	pop	r29
    2504:	08 95       	ret

00002506 <xQueueCRSend>:
#if ( configUSE_CO_ROUTINES == 1 )

    BaseType_t xQueueCRSend( QueueHandle_t xQueue,
                             const void * pvItemToQueue,
                             TickType_t xTicksToWait )
    {
    2506:	df 93       	push	r29
    2508:	cf 93       	push	r28
    250a:	cd b7       	in	r28, 0x3d	; 61
    250c:	de b7       	in	r29, 0x3e	; 62
    250e:	2a 97       	sbiw	r28, 0x0a	; 10
    2510:	0f b6       	in	r0, 0x3f	; 63
    2512:	f8 94       	cli
    2514:	de bf       	out	0x3e, r29	; 62
    2516:	0f be       	out	0x3f, r0	; 63
    2518:	cd bf       	out	0x3d, r28	; 61
    251a:	9d 83       	std	Y+5, r25	; 0x05
    251c:	8c 83       	std	Y+4, r24	; 0x04
    251e:	7f 83       	std	Y+7, r23	; 0x07
    2520:	6e 83       	std	Y+6, r22	; 0x06
    2522:	59 87       	std	Y+9, r21	; 0x09
    2524:	48 87       	std	Y+8, r20	; 0x08
        BaseType_t xReturn;
        Queue_t * const pxQueue = xQueue;
    2526:	8c 81       	ldd	r24, Y+4	; 0x04
    2528:	9d 81       	ldd	r25, Y+5	; 0x05
    252a:	9a 83       	std	Y+2, r25	; 0x02
    252c:	89 83       	std	Y+1, r24	; 0x01

        /* If the queue is already full we may have to block.  A critical section
         * is required to prevent an interrupt removing something from the queue
         * between the check to see if the queue is full and blocking on the queue. */
        portDISABLE_INTERRUPTS();
    252e:	f8 94       	cli
        {
            if( prvIsQueueFull( pxQueue ) != pdFALSE )
    2530:	89 81       	ldd	r24, Y+1	; 0x01
    2532:	9a 81       	ldd	r25, Y+2	; 0x02
    2534:	0e 94 41 12 	call	0x2482	; 0x2482 <prvIsQueueFull>
    2538:	88 23       	and	r24, r24
    253a:	a9 f0       	breq	.+42     	; 0x2566 <xQueueCRSend+0x60>
            {
                /* The queue is full - do we want to block or just leave without
                 * posting? */
                if( xTicksToWait > ( TickType_t ) 0 )
    253c:	88 85       	ldd	r24, Y+8	; 0x08
    253e:	99 85       	ldd	r25, Y+9	; 0x09
    2540:	00 97       	sbiw	r24, 0x00	; 0
    2542:	71 f0       	breq	.+28     	; 0x2560 <xQueueCRSend+0x5a>
                {
                    /* As this is called from a coroutine we cannot block directly, but
                     * return indicating that we need to block. */
                    vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
    2544:	89 81       	ldd	r24, Y+1	; 0x01
    2546:	9a 81       	ldd	r25, Y+2	; 0x02
    2548:	9c 01       	movw	r18, r24
    254a:	28 5f       	subi	r18, 0xF8	; 248
    254c:	3f 4f       	sbci	r19, 0xFF	; 255
    254e:	88 85       	ldd	r24, Y+8	; 0x08
    2550:	99 85       	ldd	r25, Y+9	; 0x09
    2552:	b9 01       	movw	r22, r18
    2554:	0e 94 4f 04 	call	0x89e	; 0x89e <vCoRoutineAddToDelayedList>
                    portENABLE_INTERRUPTS();
    2558:	78 94       	sei
                    return errQUEUE_BLOCKED;
    255a:	8c ef       	ldi	r24, 0xFC	; 252
    255c:	8a 87       	std	Y+10, r24	; 0x0a
    255e:	2a c0       	rjmp	.+84     	; 0x25b4 <xQueueCRSend+0xae>
                }
                else
                {
                    portENABLE_INTERRUPTS();
    2560:	78 94       	sei
                    return errQUEUE_FULL;
    2562:	1a 86       	std	Y+10, r1	; 0x0a
    2564:	27 c0       	rjmp	.+78     	; 0x25b4 <xQueueCRSend+0xae>
                }
            }
        }
        portENABLE_INTERRUPTS();
    2566:	78 94       	sei

        portDISABLE_INTERRUPTS();
    2568:	f8 94       	cli
        {
            if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    256a:	e9 81       	ldd	r30, Y+1	; 0x01
    256c:	fa 81       	ldd	r31, Y+2	; 0x02
    256e:	92 8d       	ldd	r25, Z+26	; 0x1a
    2570:	e9 81       	ldd	r30, Y+1	; 0x01
    2572:	fa 81       	ldd	r31, Y+2	; 0x02
    2574:	83 8d       	ldd	r24, Z+27	; 0x1b
    2576:	98 17       	cp	r25, r24
    2578:	c8 f4       	brcc	.+50     	; 0x25ac <xQueueCRSend+0xa6>
            {
                /* There is room in the queue, copy the data into the queue. */
                prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    257a:	89 81       	ldd	r24, Y+1	; 0x01
    257c:	9a 81       	ldd	r25, Y+2	; 0x02
    257e:	2e 81       	ldd	r18, Y+6	; 0x06
    2580:	3f 81       	ldd	r19, Y+7	; 0x07
    2582:	b9 01       	movw	r22, r18
    2584:	40 e0       	ldi	r20, 0x00	; 0
    2586:	0e 94 c5 10 	call	0x218a	; 0x218a <prvCopyDataToQueue>
                xReturn = pdPASS;
    258a:	81 e0       	ldi	r24, 0x01	; 1
    258c:	8b 83       	std	Y+3, r24	; 0x03

                /* Were any co-routines waiting for data to become available? */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    258e:	e9 81       	ldd	r30, Y+1	; 0x01
    2590:	fa 81       	ldd	r31, Y+2	; 0x02
    2592:	81 89       	ldd	r24, Z+17	; 0x11
    2594:	88 23       	and	r24, r24
    2596:	59 f0       	breq	.+22     	; 0x25ae <xQueueCRSend+0xa8>
                {
                    /* In this instance the co-routine could be placed directly
                     * into the ready list as we are within a critical section.
                     * Instead the same pending ready list mechanism is used as if
                     * the event were caused from within an interrupt. */
                    if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2598:	89 81       	ldd	r24, Y+1	; 0x01
    259a:	9a 81       	ldd	r25, Y+2	; 0x02
    259c:	41 96       	adiw	r24, 0x11	; 17
    259e:	0e 94 62 06 	call	0xcc4	; 0xcc4 <xCoRoutineRemoveFromEventList>
    25a2:	88 23       	and	r24, r24
    25a4:	21 f0       	breq	.+8      	; 0x25ae <xQueueCRSend+0xa8>
                    {
                        /* The co-routine waiting has a higher priority so record
                         * that a yield might be appropriate. */
                        xReturn = errQUEUE_YIELD;
    25a6:	8b ef       	ldi	r24, 0xFB	; 251
    25a8:	8b 83       	std	Y+3, r24	; 0x03
    25aa:	01 c0       	rjmp	.+2      	; 0x25ae <xQueueCRSend+0xa8>
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            else
            {
                xReturn = errQUEUE_FULL;
    25ac:	1b 82       	std	Y+3, r1	; 0x03
            }
        }
        portENABLE_INTERRUPTS();
    25ae:	78 94       	sei

        return xReturn;
    25b0:	8b 81       	ldd	r24, Y+3	; 0x03
    25b2:	8a 87       	std	Y+10, r24	; 0x0a
    25b4:	8a 85       	ldd	r24, Y+10	; 0x0a
    }
    25b6:	2a 96       	adiw	r28, 0x0a	; 10
    25b8:	0f b6       	in	r0, 0x3f	; 63
    25ba:	f8 94       	cli
    25bc:	de bf       	out	0x3e, r29	; 62
    25be:	0f be       	out	0x3f, r0	; 63
    25c0:	cd bf       	out	0x3d, r28	; 61
    25c2:	cf 91       	pop	r28
    25c4:	df 91       	pop	r29
    25c6:	08 95       	ret

000025c8 <xQueueCRReceive>:
#if ( configUSE_CO_ROUTINES == 1 )

    BaseType_t xQueueCRReceive( QueueHandle_t xQueue,
                                void * pvBuffer,
                                TickType_t xTicksToWait )
    {
    25c8:	df 93       	push	r29
    25ca:	cf 93       	push	r28
    25cc:	cd b7       	in	r28, 0x3d	; 61
    25ce:	de b7       	in	r29, 0x3e	; 62
    25d0:	2a 97       	sbiw	r28, 0x0a	; 10
    25d2:	0f b6       	in	r0, 0x3f	; 63
    25d4:	f8 94       	cli
    25d6:	de bf       	out	0x3e, r29	; 62
    25d8:	0f be       	out	0x3f, r0	; 63
    25da:	cd bf       	out	0x3d, r28	; 61
    25dc:	9d 83       	std	Y+5, r25	; 0x05
    25de:	8c 83       	std	Y+4, r24	; 0x04
    25e0:	7f 83       	std	Y+7, r23	; 0x07
    25e2:	6e 83       	std	Y+6, r22	; 0x06
    25e4:	59 87       	std	Y+9, r21	; 0x09
    25e6:	48 87       	std	Y+8, r20	; 0x08
        BaseType_t xReturn;
        Queue_t * const pxQueue = xQueue;
    25e8:	8c 81       	ldd	r24, Y+4	; 0x04
    25ea:	9d 81       	ldd	r25, Y+5	; 0x05
    25ec:	9a 83       	std	Y+2, r25	; 0x02
    25ee:	89 83       	std	Y+1, r24	; 0x01

        /* If the queue is already empty we may have to block.  A critical section
         * is required to prevent an interrupt adding something to the queue
         * between the check to see if the queue is empty and blocking on the queue. */
        portDISABLE_INTERRUPTS();
    25f0:	f8 94       	cli
        {
            if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    25f2:	e9 81       	ldd	r30, Y+1	; 0x01
    25f4:	fa 81       	ldd	r31, Y+2	; 0x02
    25f6:	82 8d       	ldd	r24, Z+26	; 0x1a
    25f8:	88 23       	and	r24, r24
    25fa:	a9 f4       	brne	.+42     	; 0x2626 <xQueueCRReceive+0x5e>
            {
                /* There are no messages in the queue, do we want to block or just
                 * leave with nothing? */
                if( xTicksToWait > ( TickType_t ) 0 )
    25fc:	88 85       	ldd	r24, Y+8	; 0x08
    25fe:	99 85       	ldd	r25, Y+9	; 0x09
    2600:	00 97       	sbiw	r24, 0x00	; 0
    2602:	71 f0       	breq	.+28     	; 0x2620 <xQueueCRReceive+0x58>
                {
                    /* As this is a co-routine we cannot block directly, but return
                     * indicating that we need to block. */
                    vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
    2604:	89 81       	ldd	r24, Y+1	; 0x01
    2606:	9a 81       	ldd	r25, Y+2	; 0x02
    2608:	9c 01       	movw	r18, r24
    260a:	2f 5e       	subi	r18, 0xEF	; 239
    260c:	3f 4f       	sbci	r19, 0xFF	; 255
    260e:	88 85       	ldd	r24, Y+8	; 0x08
    2610:	99 85       	ldd	r25, Y+9	; 0x09
    2612:	b9 01       	movw	r22, r18
    2614:	0e 94 4f 04 	call	0x89e	; 0x89e <vCoRoutineAddToDelayedList>
                    portENABLE_INTERRUPTS();
    2618:	78 94       	sei
                    return errQUEUE_BLOCKED;
    261a:	8c ef       	ldi	r24, 0xFC	; 252
    261c:	8a 87       	std	Y+10, r24	; 0x0a
    261e:	58 c0       	rjmp	.+176    	; 0x26d0 <xQueueCRReceive+0x108>
                }
                else
                {
                    portENABLE_INTERRUPTS();
    2620:	78 94       	sei
                    return errQUEUE_FULL;
    2622:	1a 86       	std	Y+10, r1	; 0x0a
    2624:	55 c0       	rjmp	.+170    	; 0x26d0 <xQueueCRReceive+0x108>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        portENABLE_INTERRUPTS();
    2626:	78 94       	sei

        portDISABLE_INTERRUPTS();
    2628:	f8 94       	cli
        {
            if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    262a:	e9 81       	ldd	r30, Y+1	; 0x01
    262c:	fa 81       	ldd	r31, Y+2	; 0x02
    262e:	82 8d       	ldd	r24, Z+26	; 0x1a
    2630:	88 23       	and	r24, r24
    2632:	09 f4       	brne	.+2      	; 0x2636 <xQueueCRReceive+0x6e>
    2634:	49 c0       	rjmp	.+146    	; 0x26c8 <xQueueCRReceive+0x100>
            {
                /* Data is available from the queue. */
                pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
    2636:	e9 81       	ldd	r30, Y+1	; 0x01
    2638:	fa 81       	ldd	r31, Y+2	; 0x02
    263a:	26 81       	ldd	r18, Z+6	; 0x06
    263c:	37 81       	ldd	r19, Z+7	; 0x07
    263e:	e9 81       	ldd	r30, Y+1	; 0x01
    2640:	fa 81       	ldd	r31, Y+2	; 0x02
    2642:	84 8d       	ldd	r24, Z+28	; 0x1c
    2644:	88 2f       	mov	r24, r24
    2646:	90 e0       	ldi	r25, 0x00	; 0
    2648:	82 0f       	add	r24, r18
    264a:	93 1f       	adc	r25, r19
    264c:	e9 81       	ldd	r30, Y+1	; 0x01
    264e:	fa 81       	ldd	r31, Y+2	; 0x02
    2650:	97 83       	std	Z+7, r25	; 0x07
    2652:	86 83       	std	Z+6, r24	; 0x06

                if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
    2654:	e9 81       	ldd	r30, Y+1	; 0x01
    2656:	fa 81       	ldd	r31, Y+2	; 0x02
    2658:	26 81       	ldd	r18, Z+6	; 0x06
    265a:	37 81       	ldd	r19, Z+7	; 0x07
    265c:	e9 81       	ldd	r30, Y+1	; 0x01
    265e:	fa 81       	ldd	r31, Y+2	; 0x02
    2660:	84 81       	ldd	r24, Z+4	; 0x04
    2662:	95 81       	ldd	r25, Z+5	; 0x05
    2664:	28 17       	cp	r18, r24
    2666:	39 07       	cpc	r19, r25
    2668:	40 f0       	brcs	.+16     	; 0x267a <xQueueCRReceive+0xb2>
                {
                    pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    266a:	e9 81       	ldd	r30, Y+1	; 0x01
    266c:	fa 81       	ldd	r31, Y+2	; 0x02
    266e:	80 81       	ld	r24, Z
    2670:	91 81       	ldd	r25, Z+1	; 0x01
    2672:	e9 81       	ldd	r30, Y+1	; 0x01
    2674:	fa 81       	ldd	r31, Y+2	; 0x02
    2676:	97 83       	std	Z+7, r25	; 0x07
    2678:	86 83       	std	Z+6, r24	; 0x06
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                --( pxQueue->uxMessagesWaiting );
    267a:	e9 81       	ldd	r30, Y+1	; 0x01
    267c:	fa 81       	ldd	r31, Y+2	; 0x02
    267e:	82 8d       	ldd	r24, Z+26	; 0x1a
    2680:	81 50       	subi	r24, 0x01	; 1
    2682:	e9 81       	ldd	r30, Y+1	; 0x01
    2684:	fa 81       	ldd	r31, Y+2	; 0x02
    2686:	82 8f       	std	Z+26, r24	; 0x1a
                ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    2688:	e9 81       	ldd	r30, Y+1	; 0x01
    268a:	fa 81       	ldd	r31, Y+2	; 0x02
    268c:	46 81       	ldd	r20, Z+6	; 0x06
    268e:	57 81       	ldd	r21, Z+7	; 0x07
    2690:	e9 81       	ldd	r30, Y+1	; 0x01
    2692:	fa 81       	ldd	r31, Y+2	; 0x02
    2694:	84 8d       	ldd	r24, Z+28	; 0x1c
    2696:	28 2f       	mov	r18, r24
    2698:	30 e0       	ldi	r19, 0x00	; 0
    269a:	8e 81       	ldd	r24, Y+6	; 0x06
    269c:	9f 81       	ldd	r25, Y+7	; 0x07
    269e:	ba 01       	movw	r22, r20
    26a0:	a9 01       	movw	r20, r18
    26a2:	0e 94 ff 27 	call	0x4ffe	; 0x4ffe <memcpy>

                xReturn = pdPASS;
    26a6:	81 e0       	ldi	r24, 0x01	; 1
    26a8:	8b 83       	std	Y+3, r24	; 0x03

                /* Were any co-routines waiting for space to become available? */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    26aa:	e9 81       	ldd	r30, Y+1	; 0x01
    26ac:	fa 81       	ldd	r31, Y+2	; 0x02
    26ae:	80 85       	ldd	r24, Z+8	; 0x08
    26b0:	88 23       	and	r24, r24
    26b2:	59 f0       	breq	.+22     	; 0x26ca <xQueueCRReceive+0x102>
                {
                    /* In this instance the co-routine could be placed directly
                     * into the ready list as we are within a critical section.
                     * Instead the same pending ready list mechanism is used as if
                     * the event were caused from within an interrupt. */
                    if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    26b4:	89 81       	ldd	r24, Y+1	; 0x01
    26b6:	9a 81       	ldd	r25, Y+2	; 0x02
    26b8:	08 96       	adiw	r24, 0x08	; 8
    26ba:	0e 94 62 06 	call	0xcc4	; 0xcc4 <xCoRoutineRemoveFromEventList>
    26be:	88 23       	and	r24, r24
    26c0:	21 f0       	breq	.+8      	; 0x26ca <xQueueCRReceive+0x102>
                    {
                        xReturn = errQUEUE_YIELD;
    26c2:	8b ef       	ldi	r24, 0xFB	; 251
    26c4:	8b 83       	std	Y+3, r24	; 0x03
    26c6:	01 c0       	rjmp	.+2      	; 0x26ca <xQueueCRReceive+0x102>
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            else
            {
                xReturn = pdFAIL;
    26c8:	1b 82       	std	Y+3, r1	; 0x03
            }
        }
        portENABLE_INTERRUPTS();
    26ca:	78 94       	sei

        return xReturn;
    26cc:	8b 81       	ldd	r24, Y+3	; 0x03
    26ce:	8a 87       	std	Y+10, r24	; 0x0a
    26d0:	8a 85       	ldd	r24, Y+10	; 0x0a
    }
    26d2:	2a 96       	adiw	r28, 0x0a	; 10
    26d4:	0f b6       	in	r0, 0x3f	; 63
    26d6:	f8 94       	cli
    26d8:	de bf       	out	0x3e, r29	; 62
    26da:	0f be       	out	0x3f, r0	; 63
    26dc:	cd bf       	out	0x3d, r28	; 61
    26de:	cf 91       	pop	r28
    26e0:	df 91       	pop	r29
    26e2:	08 95       	ret

000026e4 <xQueueCRSendFromISR>:
#if ( configUSE_CO_ROUTINES == 1 )

    BaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue,
                                    const void * pvItemToQueue,
                                    BaseType_t xCoRoutinePreviouslyWoken )
    {
    26e4:	df 93       	push	r29
    26e6:	cf 93       	push	r28
    26e8:	cd b7       	in	r28, 0x3d	; 61
    26ea:	de b7       	in	r29, 0x3e	; 62
    26ec:	28 97       	sbiw	r28, 0x08	; 8
    26ee:	0f b6       	in	r0, 0x3f	; 63
    26f0:	f8 94       	cli
    26f2:	de bf       	out	0x3e, r29	; 62
    26f4:	0f be       	out	0x3f, r0	; 63
    26f6:	cd bf       	out	0x3d, r28	; 61
    26f8:	9c 83       	std	Y+4, r25	; 0x04
    26fa:	8b 83       	std	Y+3, r24	; 0x03
    26fc:	7e 83       	std	Y+6, r23	; 0x06
    26fe:	6d 83       	std	Y+5, r22	; 0x05
    2700:	4f 83       	std	Y+7, r20	; 0x07
        Queue_t * const pxQueue = xQueue;
    2702:	8b 81       	ldd	r24, Y+3	; 0x03
    2704:	9c 81       	ldd	r25, Y+4	; 0x04
    2706:	9a 83       	std	Y+2, r25	; 0x02
    2708:	89 83       	std	Y+1, r24	; 0x01

        /* Cannot block within an ISR so if there is no space on the queue then
         * exit without doing anything. */
        if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    270a:	e9 81       	ldd	r30, Y+1	; 0x01
    270c:	fa 81       	ldd	r31, Y+2	; 0x02
    270e:	92 8d       	ldd	r25, Z+26	; 0x1a
    2710:	e9 81       	ldd	r30, Y+1	; 0x01
    2712:	fa 81       	ldd	r31, Y+2	; 0x02
    2714:	83 8d       	ldd	r24, Z+27	; 0x1b
    2716:	98 17       	cp	r25, r24
    2718:	d0 f4       	brcc	.+52     	; 0x274e <xQueueCRSendFromISR+0x6a>
        {
            prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    271a:	89 81       	ldd	r24, Y+1	; 0x01
    271c:	9a 81       	ldd	r25, Y+2	; 0x02
    271e:	2d 81       	ldd	r18, Y+5	; 0x05
    2720:	3e 81       	ldd	r19, Y+6	; 0x06
    2722:	b9 01       	movw	r22, r18
    2724:	40 e0       	ldi	r20, 0x00	; 0
    2726:	0e 94 c5 10 	call	0x218a	; 0x218a <prvCopyDataToQueue>

            /* We only want to wake one co-routine per ISR, so check that a
             * co-routine has not already been woken. */
            if( xCoRoutinePreviouslyWoken == pdFALSE )
    272a:	8f 81       	ldd	r24, Y+7	; 0x07
    272c:	88 23       	and	r24, r24
    272e:	79 f4       	brne	.+30     	; 0x274e <xQueueCRSendFromISR+0x6a>
            {
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2730:	e9 81       	ldd	r30, Y+1	; 0x01
    2732:	fa 81       	ldd	r31, Y+2	; 0x02
    2734:	81 89       	ldd	r24, Z+17	; 0x11
    2736:	88 23       	and	r24, r24
    2738:	51 f0       	breq	.+20     	; 0x274e <xQueueCRSendFromISR+0x6a>
                {
                    if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    273a:	89 81       	ldd	r24, Y+1	; 0x01
    273c:	9a 81       	ldd	r25, Y+2	; 0x02
    273e:	41 96       	adiw	r24, 0x11	; 17
    2740:	0e 94 62 06 	call	0xcc4	; 0xcc4 <xCoRoutineRemoveFromEventList>
    2744:	88 23       	and	r24, r24
    2746:	19 f0       	breq	.+6      	; 0x274e <xQueueCRSendFromISR+0x6a>
                    {
                        return pdTRUE;
    2748:	81 e0       	ldi	r24, 0x01	; 1
    274a:	88 87       	std	Y+8, r24	; 0x08
    274c:	02 c0       	rjmp	.+4      	; 0x2752 <xQueueCRSendFromISR+0x6e>
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xCoRoutinePreviouslyWoken;
    274e:	8f 81       	ldd	r24, Y+7	; 0x07
    2750:	88 87       	std	Y+8, r24	; 0x08
    2752:	88 85       	ldd	r24, Y+8	; 0x08
    }
    2754:	28 96       	adiw	r28, 0x08	; 8
    2756:	0f b6       	in	r0, 0x3f	; 63
    2758:	f8 94       	cli
    275a:	de bf       	out	0x3e, r29	; 62
    275c:	0f be       	out	0x3f, r0	; 63
    275e:	cd bf       	out	0x3d, r28	; 61
    2760:	cf 91       	pop	r28
    2762:	df 91       	pop	r29
    2764:	08 95       	ret

00002766 <xQueueCRReceiveFromISR>:
#if ( configUSE_CO_ROUTINES == 1 )

    BaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue,
                                       void * pvBuffer,
                                       BaseType_t * pxCoRoutineWoken )
    {
    2766:	df 93       	push	r29
    2768:	cf 93       	push	r28
    276a:	cd b7       	in	r28, 0x3d	; 61
    276c:	de b7       	in	r29, 0x3e	; 62
    276e:	29 97       	sbiw	r28, 0x09	; 9
    2770:	0f b6       	in	r0, 0x3f	; 63
    2772:	f8 94       	cli
    2774:	de bf       	out	0x3e, r29	; 62
    2776:	0f be       	out	0x3f, r0	; 63
    2778:	cd bf       	out	0x3d, r28	; 61
    277a:	9d 83       	std	Y+5, r25	; 0x05
    277c:	8c 83       	std	Y+4, r24	; 0x04
    277e:	7f 83       	std	Y+7, r23	; 0x07
    2780:	6e 83       	std	Y+6, r22	; 0x06
    2782:	59 87       	std	Y+9, r21	; 0x09
    2784:	48 87       	std	Y+8, r20	; 0x08
        BaseType_t xReturn;
        Queue_t * const pxQueue = xQueue;
    2786:	8c 81       	ldd	r24, Y+4	; 0x04
    2788:	9d 81       	ldd	r25, Y+5	; 0x05
    278a:	9a 83       	std	Y+2, r25	; 0x02
    278c:	89 83       	std	Y+1, r24	; 0x01

        /* We cannot block from an ISR, so check there is data available. If
         * not then just leave without doing anything. */
        if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    278e:	e9 81       	ldd	r30, Y+1	; 0x01
    2790:	fa 81       	ldd	r31, Y+2	; 0x02
    2792:	82 8d       	ldd	r24, Z+26	; 0x1a
    2794:	88 23       	and	r24, r24
    2796:	09 f4       	brne	.+2      	; 0x279a <xQueueCRReceiveFromISR+0x34>
    2798:	50 c0       	rjmp	.+160    	; 0x283a <xQueueCRReceiveFromISR+0xd4>
        {
            /* Copy the data from the queue. */
            pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
    279a:	e9 81       	ldd	r30, Y+1	; 0x01
    279c:	fa 81       	ldd	r31, Y+2	; 0x02
    279e:	26 81       	ldd	r18, Z+6	; 0x06
    27a0:	37 81       	ldd	r19, Z+7	; 0x07
    27a2:	e9 81       	ldd	r30, Y+1	; 0x01
    27a4:	fa 81       	ldd	r31, Y+2	; 0x02
    27a6:	84 8d       	ldd	r24, Z+28	; 0x1c
    27a8:	88 2f       	mov	r24, r24
    27aa:	90 e0       	ldi	r25, 0x00	; 0
    27ac:	82 0f       	add	r24, r18
    27ae:	93 1f       	adc	r25, r19
    27b0:	e9 81       	ldd	r30, Y+1	; 0x01
    27b2:	fa 81       	ldd	r31, Y+2	; 0x02
    27b4:	97 83       	std	Z+7, r25	; 0x07
    27b6:	86 83       	std	Z+6, r24	; 0x06

            if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
    27b8:	e9 81       	ldd	r30, Y+1	; 0x01
    27ba:	fa 81       	ldd	r31, Y+2	; 0x02
    27bc:	26 81       	ldd	r18, Z+6	; 0x06
    27be:	37 81       	ldd	r19, Z+7	; 0x07
    27c0:	e9 81       	ldd	r30, Y+1	; 0x01
    27c2:	fa 81       	ldd	r31, Y+2	; 0x02
    27c4:	84 81       	ldd	r24, Z+4	; 0x04
    27c6:	95 81       	ldd	r25, Z+5	; 0x05
    27c8:	28 17       	cp	r18, r24
    27ca:	39 07       	cpc	r19, r25
    27cc:	40 f0       	brcs	.+16     	; 0x27de <xQueueCRReceiveFromISR+0x78>
            {
                pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    27ce:	e9 81       	ldd	r30, Y+1	; 0x01
    27d0:	fa 81       	ldd	r31, Y+2	; 0x02
    27d2:	80 81       	ld	r24, Z
    27d4:	91 81       	ldd	r25, Z+1	; 0x01
    27d6:	e9 81       	ldd	r30, Y+1	; 0x01
    27d8:	fa 81       	ldd	r31, Y+2	; 0x02
    27da:	97 83       	std	Z+7, r25	; 0x07
    27dc:	86 83       	std	Z+6, r24	; 0x06
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            --( pxQueue->uxMessagesWaiting );
    27de:	e9 81       	ldd	r30, Y+1	; 0x01
    27e0:	fa 81       	ldd	r31, Y+2	; 0x02
    27e2:	82 8d       	ldd	r24, Z+26	; 0x1a
    27e4:	81 50       	subi	r24, 0x01	; 1
    27e6:	e9 81       	ldd	r30, Y+1	; 0x01
    27e8:	fa 81       	ldd	r31, Y+2	; 0x02
    27ea:	82 8f       	std	Z+26, r24	; 0x1a
            ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    27ec:	e9 81       	ldd	r30, Y+1	; 0x01
    27ee:	fa 81       	ldd	r31, Y+2	; 0x02
    27f0:	46 81       	ldd	r20, Z+6	; 0x06
    27f2:	57 81       	ldd	r21, Z+7	; 0x07
    27f4:	e9 81       	ldd	r30, Y+1	; 0x01
    27f6:	fa 81       	ldd	r31, Y+2	; 0x02
    27f8:	84 8d       	ldd	r24, Z+28	; 0x1c
    27fa:	28 2f       	mov	r18, r24
    27fc:	30 e0       	ldi	r19, 0x00	; 0
    27fe:	8e 81       	ldd	r24, Y+6	; 0x06
    2800:	9f 81       	ldd	r25, Y+7	; 0x07
    2802:	ba 01       	movw	r22, r20
    2804:	a9 01       	movw	r20, r18
    2806:	0e 94 ff 27 	call	0x4ffe	; 0x4ffe <memcpy>

            if( ( *pxCoRoutineWoken ) == pdFALSE )
    280a:	e8 85       	ldd	r30, Y+8	; 0x08
    280c:	f9 85       	ldd	r31, Y+9	; 0x09
    280e:	80 81       	ld	r24, Z
    2810:	88 23       	and	r24, r24
    2812:	81 f4       	brne	.+32     	; 0x2834 <xQueueCRReceiveFromISR+0xce>
            {
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2814:	e9 81       	ldd	r30, Y+1	; 0x01
    2816:	fa 81       	ldd	r31, Y+2	; 0x02
    2818:	80 85       	ldd	r24, Z+8	; 0x08
    281a:	88 23       	and	r24, r24
    281c:	59 f0       	breq	.+22     	; 0x2834 <xQueueCRReceiveFromISR+0xce>
                {
                    if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    281e:	89 81       	ldd	r24, Y+1	; 0x01
    2820:	9a 81       	ldd	r25, Y+2	; 0x02
    2822:	08 96       	adiw	r24, 0x08	; 8
    2824:	0e 94 62 06 	call	0xcc4	; 0xcc4 <xCoRoutineRemoveFromEventList>
    2828:	88 23       	and	r24, r24
    282a:	21 f0       	breq	.+8      	; 0x2834 <xQueueCRReceiveFromISR+0xce>
                    {
                        *pxCoRoutineWoken = pdTRUE;
    282c:	e8 85       	ldd	r30, Y+8	; 0x08
    282e:	f9 85       	ldd	r31, Y+9	; 0x09
    2830:	81 e0       	ldi	r24, 0x01	; 1
    2832:	80 83       	st	Z, r24
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            xReturn = pdPASS;
    2834:	81 e0       	ldi	r24, 0x01	; 1
    2836:	8b 83       	std	Y+3, r24	; 0x03
    2838:	01 c0       	rjmp	.+2      	; 0x283c <xQueueCRReceiveFromISR+0xd6>
        }
        else
        {
            xReturn = pdFAIL;
    283a:	1b 82       	std	Y+3, r1	; 0x03
        }

        return xReturn;
    283c:	8b 81       	ldd	r24, Y+3	; 0x03
    }
    283e:	29 96       	adiw	r28, 0x09	; 9
    2840:	0f b6       	in	r0, 0x3f	; 63
    2842:	f8 94       	cli
    2844:	de bf       	out	0x3e, r29	; 62
    2846:	0f be       	out	0x3f, r0	; 63
    2848:	cd bf       	out	0x3d, r28	; 61
    284a:	cf 91       	pop	r28
    284c:	df 91       	pop	r29
    284e:	08 95       	ret

00002850 <xTaskCreate>:
                            const char * const pcName, /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
                            const configSTACK_DEPTH_TYPE usStackDepth,
                            void * const pvParameters,
                            UBaseType_t uxPriority,
                            TaskHandle_t * const pxCreatedTask )
    {
    2850:	8f 92       	push	r8
    2852:	9f 92       	push	r9
    2854:	af 92       	push	r10
    2856:	bf 92       	push	r11
    2858:	cf 92       	push	r12
    285a:	df 92       	push	r13
    285c:	ef 92       	push	r14
    285e:	ff 92       	push	r15
    2860:	0f 93       	push	r16
    2862:	1f 93       	push	r17
    2864:	df 93       	push	r29
    2866:	cf 93       	push	r28
    2868:	cd b7       	in	r28, 0x3d	; 61
    286a:	de b7       	in	r29, 0x3e	; 62
    286c:	60 97       	sbiw	r28, 0x10	; 16
    286e:	0f b6       	in	r0, 0x3f	; 63
    2870:	f8 94       	cli
    2872:	de bf       	out	0x3e, r29	; 62
    2874:	0f be       	out	0x3f, r0	; 63
    2876:	cd bf       	out	0x3d, r28	; 61
    2878:	9f 83       	std	Y+7, r25	; 0x07
    287a:	8e 83       	std	Y+6, r24	; 0x06
    287c:	79 87       	std	Y+9, r23	; 0x09
    287e:	68 87       	std	Y+8, r22	; 0x08
    2880:	5b 87       	std	Y+11, r21	; 0x0b
    2882:	4a 87       	std	Y+10, r20	; 0x0a
    2884:	3d 87       	std	Y+13, r19	; 0x0d
    2886:	2c 87       	std	Y+12, r18	; 0x0c
    2888:	0e 87       	std	Y+14, r16	; 0x0e
    288a:	f8 8a       	std	Y+16, r15	; 0x10
    288c:	ef 86       	std	Y+15, r14	; 0x0f
        #else /* portSTACK_GROWTH */
            {
                StackType_t * pxStack;

                /* Allocate space for the stack used by the task being created. */
                pxStack = pvPortMallocStack( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
    288e:	8a 85       	ldd	r24, Y+10	; 0x0a
    2890:	9b 85       	ldd	r25, Y+11	; 0x0b
    2892:	0e 94 67 00 	call	0xce	; 0xce <pvPortMalloc>
    2896:	9a 83       	std	Y+2, r25	; 0x02
    2898:	89 83       	std	Y+1, r24	; 0x01

                if( pxStack != NULL )
    289a:	89 81       	ldd	r24, Y+1	; 0x01
    289c:	9a 81       	ldd	r25, Y+2	; 0x02
    289e:	00 97       	sbiw	r24, 0x00	; 0
    28a0:	b1 f0       	breq	.+44     	; 0x28ce <xTaskCreate+0x7e>
                {
                    /* Allocate space for the TCB. */
                    pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
    28a2:	86 e2       	ldi	r24, 0x26	; 38
    28a4:	90 e0       	ldi	r25, 0x00	; 0
    28a6:	0e 94 67 00 	call	0xce	; 0xce <pvPortMalloc>
    28aa:	9d 83       	std	Y+5, r25	; 0x05
    28ac:	8c 83       	std	Y+4, r24	; 0x04

                    if( pxNewTCB != NULL )
    28ae:	8c 81       	ldd	r24, Y+4	; 0x04
    28b0:	9d 81       	ldd	r25, Y+5	; 0x05
    28b2:	00 97       	sbiw	r24, 0x00	; 0
    28b4:	39 f0       	breq	.+14     	; 0x28c4 <xTaskCreate+0x74>
                    {
                        /* Store the stack location in the TCB. */
                        pxNewTCB->pxStack = pxStack;
    28b6:	ec 81       	ldd	r30, Y+4	; 0x04
    28b8:	fd 81       	ldd	r31, Y+5	; 0x05
    28ba:	89 81       	ldd	r24, Y+1	; 0x01
    28bc:	9a 81       	ldd	r25, Y+2	; 0x02
    28be:	90 8f       	std	Z+24, r25	; 0x18
    28c0:	87 8b       	std	Z+23, r24	; 0x17
    28c2:	07 c0       	rjmp	.+14     	; 0x28d2 <xTaskCreate+0x82>
                    }
                    else
                    {
                        /* The stack cannot be used as the TCB was not created.  Free
                         * it again. */
                        vPortFreeStack( pxStack );
    28c4:	89 81       	ldd	r24, Y+1	; 0x01
    28c6:	9a 81       	ldd	r25, Y+2	; 0x02
    28c8:	0e 94 c1 00 	call	0x182	; 0x182 <vPortFree>
    28cc:	02 c0       	rjmp	.+4      	; 0x28d2 <xTaskCreate+0x82>
                    }
                }
                else
                {
                    pxNewTCB = NULL;
    28ce:	1d 82       	std	Y+5, r1	; 0x05
    28d0:	1c 82       	std	Y+4, r1	; 0x04
                }
            }
        #endif /* portSTACK_GROWTH */

        if( pxNewTCB != NULL )
    28d2:	8c 81       	ldd	r24, Y+4	; 0x04
    28d4:	9d 81       	ldd	r25, Y+5	; 0x05
    28d6:	00 97       	sbiw	r24, 0x00	; 0
    28d8:	e9 f0       	breq	.+58     	; 0x2914 <xTaskCreate+0xc4>
                     * task was created dynamically in case it is later deleted. */
                    pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
                }
            #endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

            prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
    28da:	8a 85       	ldd	r24, Y+10	; 0x0a
    28dc:	9b 85       	ldd	r25, Y+11	; 0x0b
    28de:	9c 01       	movw	r18, r24
    28e0:	40 e0       	ldi	r20, 0x00	; 0
    28e2:	50 e0       	ldi	r21, 0x00	; 0
    28e4:	8e 81       	ldd	r24, Y+6	; 0x06
    28e6:	9f 81       	ldd	r25, Y+7	; 0x07
    28e8:	68 85       	ldd	r22, Y+8	; 0x08
    28ea:	79 85       	ldd	r23, Y+9	; 0x09
    28ec:	ec 85       	ldd	r30, Y+12	; 0x0c
    28ee:	fd 85       	ldd	r31, Y+13	; 0x0d
    28f0:	af 85       	ldd	r26, Y+15	; 0x0f
    28f2:	b8 89       	ldd	r27, Y+16	; 0x10
    28f4:	ac 80       	ldd	r10, Y+4	; 0x04
    28f6:	bd 80       	ldd	r11, Y+5	; 0x05
    28f8:	8f 01       	movw	r16, r30
    28fa:	ee 84       	ldd	r14, Y+14	; 0x0e
    28fc:	6d 01       	movw	r12, r26
    28fe:	88 24       	eor	r8, r8
    2900:	99 24       	eor	r9, r9
    2902:	0e 94 a0 14 	call	0x2940	; 0x2940 <prvInitialiseNewTask>
            prvAddNewTaskToReadyList( pxNewTCB );
    2906:	8c 81       	ldd	r24, Y+4	; 0x04
    2908:	9d 81       	ldd	r25, Y+5	; 0x05
    290a:	0e 94 65 15 	call	0x2aca	; 0x2aca <prvAddNewTaskToReadyList>
            xReturn = pdPASS;
    290e:	81 e0       	ldi	r24, 0x01	; 1
    2910:	8b 83       	std	Y+3, r24	; 0x03
    2912:	02 c0       	rjmp	.+4      	; 0x2918 <xTaskCreate+0xc8>
        }
        else
        {
            xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    2914:	8f ef       	ldi	r24, 0xFF	; 255
    2916:	8b 83       	std	Y+3, r24	; 0x03
        }

        return xReturn;
    2918:	8b 81       	ldd	r24, Y+3	; 0x03
    }
    291a:	60 96       	adiw	r28, 0x10	; 16
    291c:	0f b6       	in	r0, 0x3f	; 63
    291e:	f8 94       	cli
    2920:	de bf       	out	0x3e, r29	; 62
    2922:	0f be       	out	0x3f, r0	; 63
    2924:	cd bf       	out	0x3d, r28	; 61
    2926:	cf 91       	pop	r28
    2928:	df 91       	pop	r29
    292a:	1f 91       	pop	r17
    292c:	0f 91       	pop	r16
    292e:	ff 90       	pop	r15
    2930:	ef 90       	pop	r14
    2932:	df 90       	pop	r13
    2934:	cf 90       	pop	r12
    2936:	bf 90       	pop	r11
    2938:	af 90       	pop	r10
    293a:	9f 90       	pop	r9
    293c:	8f 90       	pop	r8
    293e:	08 95       	ret

00002940 <prvInitialiseNewTask>:
                                  void * const pvParameters,
                                  UBaseType_t uxPriority,
                                  TaskHandle_t * const pxCreatedTask,
                                  TCB_t * pxNewTCB,
                                  const MemoryRegion_t * const xRegions )
{
    2940:	8f 92       	push	r8
    2942:	9f 92       	push	r9
    2944:	af 92       	push	r10
    2946:	bf 92       	push	r11
    2948:	cf 92       	push	r12
    294a:	df 92       	push	r13
    294c:	ef 92       	push	r14
    294e:	0f 93       	push	r16
    2950:	1f 93       	push	r17
    2952:	df 93       	push	r29
    2954:	cf 93       	push	r28
    2956:	cd b7       	in	r28, 0x3d	; 61
    2958:	de b7       	in	r29, 0x3e	; 62
    295a:	64 97       	sbiw	r28, 0x14	; 20
    295c:	0f b6       	in	r0, 0x3f	; 63
    295e:	f8 94       	cli
    2960:	de bf       	out	0x3e, r29	; 62
    2962:	0f be       	out	0x3f, r0	; 63
    2964:	cd bf       	out	0x3d, r28	; 61
    2966:	9d 83       	std	Y+5, r25	; 0x05
    2968:	8c 83       	std	Y+4, r24	; 0x04
    296a:	7f 83       	std	Y+7, r23	; 0x07
    296c:	6e 83       	std	Y+6, r22	; 0x06
    296e:	28 87       	std	Y+8, r18	; 0x08
    2970:	39 87       	std	Y+9, r19	; 0x09
    2972:	4a 87       	std	Y+10, r20	; 0x0a
    2974:	5b 87       	std	Y+11, r21	; 0x0b
    2976:	1d 87       	std	Y+13, r17	; 0x0d
    2978:	0c 87       	std	Y+12, r16	; 0x0c
    297a:	ee 86       	std	Y+14, r14	; 0x0e
    297c:	d8 8a       	std	Y+16, r13	; 0x10
    297e:	cf 86       	std	Y+15, r12	; 0x0f
    2980:	ba 8a       	std	Y+18, r11	; 0x12
    2982:	a9 8a       	std	Y+17, r10	; 0x11
    2984:	9c 8a       	std	Y+20, r9	; 0x14
    2986:	8b 8a       	std	Y+19, r8	; 0x13
     * grows from high memory to low (as per the 80x86) or vice versa.
     * portSTACK_GROWTH is used to make the result positive or negative as required
     * by the port. */
    #if ( portSTACK_GROWTH < 0 )
        {
            pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
    2988:	e9 89       	ldd	r30, Y+17	; 0x11
    298a:	fa 89       	ldd	r31, Y+18	; 0x12
    298c:	27 89       	ldd	r18, Z+23	; 0x17
    298e:	30 8d       	ldd	r19, Z+24	; 0x18
    2990:	88 85       	ldd	r24, Y+8	; 0x08
    2992:	99 85       	ldd	r25, Y+9	; 0x09
    2994:	01 97       	sbiw	r24, 0x01	; 1
    2996:	82 0f       	add	r24, r18
    2998:	93 1f       	adc	r25, r19
    299a:	9b 83       	std	Y+3, r25	; 0x03
    299c:	8a 83       	std	Y+2, r24	; 0x02
            pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
        }
    #endif /* portSTACK_GROWTH */

    /* Store the task name in the TCB. */
    if( pcName != NULL )
    299e:	8e 81       	ldd	r24, Y+6	; 0x06
    29a0:	9f 81       	ldd	r25, Y+7	; 0x07
    29a2:	00 97       	sbiw	r24, 0x00	; 0
    29a4:	51 f1       	breq	.+84     	; 0x29fa <prvInitialiseNewTask+0xba>
    {
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    29a6:	19 82       	std	Y+1, r1	; 0x01
    29a8:	21 c0       	rjmp	.+66     	; 0x29ec <prvInitialiseNewTask+0xac>
        {
            pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    29aa:	89 81       	ldd	r24, Y+1	; 0x01
    29ac:	48 2f       	mov	r20, r24
    29ae:	50 e0       	ldi	r21, 0x00	; 0
    29b0:	89 81       	ldd	r24, Y+1	; 0x01
    29b2:	28 2f       	mov	r18, r24
    29b4:	30 e0       	ldi	r19, 0x00	; 0
    29b6:	8e 81       	ldd	r24, Y+6	; 0x06
    29b8:	9f 81       	ldd	r25, Y+7	; 0x07
    29ba:	fc 01       	movw	r30, r24
    29bc:	e2 0f       	add	r30, r18
    29be:	f3 1f       	adc	r31, r19
    29c0:	20 81       	ld	r18, Z
    29c2:	89 89       	ldd	r24, Y+17	; 0x11
    29c4:	9a 89       	ldd	r25, Y+18	; 0x12
    29c6:	84 0f       	add	r24, r20
    29c8:	95 1f       	adc	r25, r21
    29ca:	fc 01       	movw	r30, r24
    29cc:	79 96       	adiw	r30, 0x19	; 25
    29ce:	20 83       	st	Z, r18

            /* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
             * configMAX_TASK_NAME_LEN characters just in case the memory after the
             * string is not accessible (extremely unlikely). */
            if( pcName[ x ] == ( char ) 0x00 )
    29d0:	89 81       	ldd	r24, Y+1	; 0x01
    29d2:	28 2f       	mov	r18, r24
    29d4:	30 e0       	ldi	r19, 0x00	; 0
    29d6:	8e 81       	ldd	r24, Y+6	; 0x06
    29d8:	9f 81       	ldd	r25, Y+7	; 0x07
    29da:	fc 01       	movw	r30, r24
    29dc:	e2 0f       	add	r30, r18
    29de:	f3 1f       	adc	r31, r19
    29e0:	80 81       	ld	r24, Z
    29e2:	88 23       	and	r24, r24
    29e4:	31 f0       	breq	.+12     	; 0x29f2 <prvInitialiseNewTask+0xb2>
    #endif /* portSTACK_GROWTH */

    /* Store the task name in the TCB. */
    if( pcName != NULL )
    {
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    29e6:	89 81       	ldd	r24, Y+1	; 0x01
    29e8:	8f 5f       	subi	r24, 0xFF	; 255
    29ea:	89 83       	std	Y+1, r24	; 0x01
    29ec:	89 81       	ldd	r24, Y+1	; 0x01
    29ee:	88 30       	cpi	r24, 0x08	; 8
    29f0:	e0 f2       	brcs	.-72     	; 0x29aa <prvInitialiseNewTask+0x6a>
            }
        }

        /* Ensure the name string is terminated in the case that the string length
         * was greater or equal to configMAX_TASK_NAME_LEN. */
        pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    29f2:	e9 89       	ldd	r30, Y+17	; 0x11
    29f4:	fa 89       	ldd	r31, Y+18	; 0x12
    29f6:	10 a2       	std	Z+32, r1	; 0x20
    29f8:	03 c0       	rjmp	.+6      	; 0x2a00 <prvInitialiseNewTask+0xc0>
    }
    else
    {
        /* The task has not been given a name, so just ensure there is a NULL
         * terminator when it is read out. */
        pxNewTCB->pcTaskName[ 0 ] = 0x00;
    29fa:	e9 89       	ldd	r30, Y+17	; 0x11
    29fc:	fa 89       	ldd	r31, Y+18	; 0x12
    29fe:	11 8e       	std	Z+25, r1	; 0x19
    }

    /* This is used as an array index so must ensure it's not too large. */
    configASSERT( uxPriority < configMAX_PRIORITIES );

    if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    2a00:	8e 85       	ldd	r24, Y+14	; 0x0e
    2a02:	84 30       	cpi	r24, 0x04	; 4
    2a04:	10 f0       	brcs	.+4      	; 0x2a0a <prvInitialiseNewTask+0xca>
    {
        uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    2a06:	83 e0       	ldi	r24, 0x03	; 3
    2a08:	8e 87       	std	Y+14, r24	; 0x0e
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxNewTCB->uxPriority = uxPriority;
    2a0a:	e9 89       	ldd	r30, Y+17	; 0x11
    2a0c:	fa 89       	ldd	r31, Y+18	; 0x12
    2a0e:	8e 85       	ldd	r24, Y+14	; 0x0e
    2a10:	86 8b       	std	Z+22, r24	; 0x16
            pxNewTCB->uxBasePriority = uxPriority;
            pxNewTCB->uxMutexesHeld = 0;
        }
    #endif /* configUSE_MUTEXES */

    vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    2a12:	89 89       	ldd	r24, Y+17	; 0x11
    2a14:	9a 89       	ldd	r25, Y+18	; 0x12
    2a16:	02 96       	adiw	r24, 0x02	; 2
    2a18:	0e 94 09 0a 	call	0x1412	; 0x1412 <vListInitialiseItem>
    vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    2a1c:	89 89       	ldd	r24, Y+17	; 0x11
    2a1e:	9a 89       	ldd	r25, Y+18	; 0x12
    2a20:	0c 96       	adiw	r24, 0x0c	; 12
    2a22:	0e 94 09 0a 	call	0x1412	; 0x1412 <vListInitialiseItem>

    /* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
     * back to  the containing TCB from a generic item in a list. */
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    2a26:	e9 89       	ldd	r30, Y+17	; 0x11
    2a28:	fa 89       	ldd	r31, Y+18	; 0x12
    2a2a:	89 89       	ldd	r24, Y+17	; 0x11
    2a2c:	9a 89       	ldd	r25, Y+18	; 0x12
    2a2e:	91 87       	std	Z+9, r25	; 0x09
    2a30:	80 87       	std	Z+8, r24	; 0x08

    /* Event lists are always in priority order. */
    listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    2a32:	8e 85       	ldd	r24, Y+14	; 0x0e
    2a34:	28 2f       	mov	r18, r24
    2a36:	30 e0       	ldi	r19, 0x00	; 0
    2a38:	84 e0       	ldi	r24, 0x04	; 4
    2a3a:	90 e0       	ldi	r25, 0x00	; 0
    2a3c:	82 1b       	sub	r24, r18
    2a3e:	93 0b       	sbc	r25, r19
    2a40:	e9 89       	ldd	r30, Y+17	; 0x11
    2a42:	fa 89       	ldd	r31, Y+18	; 0x12
    2a44:	95 87       	std	Z+13, r25	; 0x0d
    2a46:	84 87       	std	Z+12, r24	; 0x0c
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    2a48:	e9 89       	ldd	r30, Y+17	; 0x11
    2a4a:	fa 89       	ldd	r31, Y+18	; 0x12
    2a4c:	89 89       	ldd	r24, Y+17	; 0x11
    2a4e:	9a 89       	ldd	r25, Y+18	; 0x12
    2a50:	93 8b       	std	Z+19, r25	; 0x13
    2a52:	82 8b       	std	Z+18, r24	; 0x12
        }
    #endif

    #if ( configUSE_TASK_NOTIFICATIONS == 1 )
        {
            memset( ( void * ) &( pxNewTCB->ulNotifiedValue[ 0 ] ), 0x00, sizeof( pxNewTCB->ulNotifiedValue ) );
    2a54:	89 89       	ldd	r24, Y+17	; 0x11
    2a56:	9a 89       	ldd	r25, Y+18	; 0x12
    2a58:	81 96       	adiw	r24, 0x21	; 33
    2a5a:	60 e0       	ldi	r22, 0x00	; 0
    2a5c:	70 e0       	ldi	r23, 0x00	; 0
    2a5e:	44 e0       	ldi	r20, 0x04	; 4
    2a60:	50 e0       	ldi	r21, 0x00	; 0
    2a62:	0e 94 08 28 	call	0x5010	; 0x5010 <memset>
            memset( ( void * ) &( pxNewTCB->ucNotifyState[ 0 ] ), 0x00, sizeof( pxNewTCB->ucNotifyState ) );
    2a66:	89 89       	ldd	r24, Y+17	; 0x11
    2a68:	9a 89       	ldd	r25, Y+18	; 0x12
    2a6a:	85 96       	adiw	r24, 0x25	; 37
    2a6c:	60 e0       	ldi	r22, 0x00	; 0
    2a6e:	70 e0       	ldi	r23, 0x00	; 0
    2a70:	41 e0       	ldi	r20, 0x01	; 1
    2a72:	50 e0       	ldi	r21, 0x00	; 0
    2a74:	0e 94 08 28 	call	0x5010	; 0x5010 <memset>
                        }
                    #endif /* portSTACK_GROWTH */
                }
            #else /* portHAS_STACK_OVERFLOW_CHECKING */
                {
                    pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    2a78:	8a 81       	ldd	r24, Y+2	; 0x02
    2a7a:	9b 81       	ldd	r25, Y+3	; 0x03
    2a7c:	2c 81       	ldd	r18, Y+4	; 0x04
    2a7e:	3d 81       	ldd	r19, Y+5	; 0x05
    2a80:	4c 85       	ldd	r20, Y+12	; 0x0c
    2a82:	5d 85       	ldd	r21, Y+13	; 0x0d
    2a84:	b9 01       	movw	r22, r18
    2a86:	0e 94 e7 00 	call	0x1ce	; 0x1ce <pxPortInitialiseStack>
    2a8a:	e9 89       	ldd	r30, Y+17	; 0x11
    2a8c:	fa 89       	ldd	r31, Y+18	; 0x12
    2a8e:	91 83       	std	Z+1, r25	; 0x01
    2a90:	80 83       	st	Z, r24
                }
            #endif /* portHAS_STACK_OVERFLOW_CHECKING */
        }
    #endif /* portUSING_MPU_WRAPPERS */

    if( pxCreatedTask != NULL )
    2a92:	8f 85       	ldd	r24, Y+15	; 0x0f
    2a94:	98 89       	ldd	r25, Y+16	; 0x10
    2a96:	00 97       	sbiw	r24, 0x00	; 0
    2a98:	31 f0       	breq	.+12     	; 0x2aa6 <prvInitialiseNewTask+0x166>
    {
        /* Pass the handle out in an anonymous way.  The handle can be used to
         * change the created task's priority, delete the created task, etc.*/
        *pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    2a9a:	ef 85       	ldd	r30, Y+15	; 0x0f
    2a9c:	f8 89       	ldd	r31, Y+16	; 0x10
    2a9e:	89 89       	ldd	r24, Y+17	; 0x11
    2aa0:	9a 89       	ldd	r25, Y+18	; 0x12
    2aa2:	91 83       	std	Z+1, r25	; 0x01
    2aa4:	80 83       	st	Z, r24
    }
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }
}
    2aa6:	64 96       	adiw	r28, 0x14	; 20
    2aa8:	0f b6       	in	r0, 0x3f	; 63
    2aaa:	f8 94       	cli
    2aac:	de bf       	out	0x3e, r29	; 62
    2aae:	0f be       	out	0x3f, r0	; 63
    2ab0:	cd bf       	out	0x3d, r28	; 61
    2ab2:	cf 91       	pop	r28
    2ab4:	df 91       	pop	r29
    2ab6:	1f 91       	pop	r17
    2ab8:	0f 91       	pop	r16
    2aba:	ef 90       	pop	r14
    2abc:	df 90       	pop	r13
    2abe:	cf 90       	pop	r12
    2ac0:	bf 90       	pop	r11
    2ac2:	af 90       	pop	r10
    2ac4:	9f 90       	pop	r9
    2ac6:	8f 90       	pop	r8
    2ac8:	08 95       	ret

00002aca <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t * pxNewTCB )
{
    2aca:	df 93       	push	r29
    2acc:	cf 93       	push	r28
    2ace:	00 d0       	rcall	.+0      	; 0x2ad0 <prvAddNewTaskToReadyList+0x6>
    2ad0:	00 d0       	rcall	.+0      	; 0x2ad2 <prvAddNewTaskToReadyList+0x8>
    2ad2:	cd b7       	in	r28, 0x3d	; 61
    2ad4:	de b7       	in	r29, 0x3e	; 62
    2ad6:	9c 83       	std	Y+4, r25	; 0x04
    2ad8:	8b 83       	std	Y+3, r24	; 0x03
    /* Ensure interrupts don't access the task lists while the lists are being
     * updated. */
    taskENTER_CRITICAL();
    2ada:	0f b6       	in	r0, 0x3f	; 63
    2adc:	f8 94       	cli
    2ade:	0f 92       	push	r0
    {
        uxCurrentNumberOfTasks++;
    2ae0:	80 91 31 07 	lds	r24, 0x0731
    2ae4:	8f 5f       	subi	r24, 0xFF	; 255
    2ae6:	80 93 31 07 	sts	0x0731, r24

        if( pxCurrentTCB == NULL )
    2aea:	80 91 2e 07 	lds	r24, 0x072E
    2aee:	90 91 2f 07 	lds	r25, 0x072F
    2af2:	00 97       	sbiw	r24, 0x00	; 0
    2af4:	69 f4       	brne	.+26     	; 0x2b10 <prvAddNewTaskToReadyList+0x46>
        {
            /* There are no other tasks, or all the other tasks are in
             * the suspended state - make this the current task. */
            pxCurrentTCB = pxNewTCB;
    2af6:	8b 81       	ldd	r24, Y+3	; 0x03
    2af8:	9c 81       	ldd	r25, Y+4	; 0x04
    2afa:	90 93 2f 07 	sts	0x072F, r25
    2afe:	80 93 2e 07 	sts	0x072E, r24

            if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    2b02:	80 91 31 07 	lds	r24, 0x0731
    2b06:	81 30       	cpi	r24, 0x01	; 1
    2b08:	b9 f4       	brne	.+46     	; 0x2b38 <prvAddNewTaskToReadyList+0x6e>
            {
                /* This is the first task to be created so do the preliminary
                 * initialisation required.  We will not recover if this call
                 * fails, but we will report the failure. */
                prvInitialiseTaskLists();
    2b0a:	0e 94 e1 1e 	call	0x3dc2	; 0x3dc2 <prvInitialiseTaskLists>
    2b0e:	14 c0       	rjmp	.+40     	; 0x2b38 <prvAddNewTaskToReadyList+0x6e>
        else
        {
            /* If the scheduler is not already running, make this task the
             * current task if it is the highest priority task to be created
             * so far. */
            if( xSchedulerRunning == pdFALSE )
    2b10:	80 91 35 07 	lds	r24, 0x0735
    2b14:	88 23       	and	r24, r24
    2b16:	81 f4       	brne	.+32     	; 0x2b38 <prvAddNewTaskToReadyList+0x6e>
            {
                if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    2b18:	e0 91 2e 07 	lds	r30, 0x072E
    2b1c:	f0 91 2f 07 	lds	r31, 0x072F
    2b20:	96 89       	ldd	r25, Z+22	; 0x16
    2b22:	eb 81       	ldd	r30, Y+3	; 0x03
    2b24:	fc 81       	ldd	r31, Y+4	; 0x04
    2b26:	86 89       	ldd	r24, Z+22	; 0x16
    2b28:	89 17       	cp	r24, r25
    2b2a:	30 f0       	brcs	.+12     	; 0x2b38 <prvAddNewTaskToReadyList+0x6e>
                {
                    pxCurrentTCB = pxNewTCB;
    2b2c:	8b 81       	ldd	r24, Y+3	; 0x03
    2b2e:	9c 81       	ldd	r25, Y+4	; 0x04
    2b30:	90 93 2f 07 	sts	0x072F, r25
    2b34:	80 93 2e 07 	sts	0x072E, r24
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }

        uxTaskNumber++;
    2b38:	80 91 3a 07 	lds	r24, 0x073A
    2b3c:	8f 5f       	subi	r24, 0xFF	; 255
    2b3e:	80 93 3a 07 	sts	0x073A, r24
                pxNewTCB->uxTCBNumber = uxTaskNumber;
            }
        #endif /* configUSE_TRACE_FACILITY */
        traceTASK_CREATE( pxNewTCB );

        prvAddTaskToReadyList( pxNewTCB );
    2b42:	eb 81       	ldd	r30, Y+3	; 0x03
    2b44:	fc 81       	ldd	r31, Y+4	; 0x04
    2b46:	96 89       	ldd	r25, Z+22	; 0x16
    2b48:	80 91 34 07 	lds	r24, 0x0734
    2b4c:	89 17       	cp	r24, r25
    2b4e:	28 f4       	brcc	.+10     	; 0x2b5a <prvAddNewTaskToReadyList+0x90>
    2b50:	eb 81       	ldd	r30, Y+3	; 0x03
    2b52:	fc 81       	ldd	r31, Y+4	; 0x04
    2b54:	86 89       	ldd	r24, Z+22	; 0x16
    2b56:	80 93 34 07 	sts	0x0734, r24
    2b5a:	eb 81       	ldd	r30, Y+3	; 0x03
    2b5c:	fc 81       	ldd	r31, Y+4	; 0x04
    2b5e:	86 89       	ldd	r24, Z+22	; 0x16
    2b60:	28 2f       	mov	r18, r24
    2b62:	30 e0       	ldi	r19, 0x00	; 0
    2b64:	c9 01       	movw	r24, r18
    2b66:	88 0f       	add	r24, r24
    2b68:	99 1f       	adc	r25, r25
    2b6a:	88 0f       	add	r24, r24
    2b6c:	99 1f       	adc	r25, r25
    2b6e:	88 0f       	add	r24, r24
    2b70:	99 1f       	adc	r25, r25
    2b72:	82 0f       	add	r24, r18
    2b74:	93 1f       	adc	r25, r19
    2b76:	fc 01       	movw	r30, r24
    2b78:	e0 5c       	subi	r30, 0xC0	; 192
    2b7a:	f8 4f       	sbci	r31, 0xF8	; 248
    2b7c:	81 81       	ldd	r24, Z+1	; 0x01
    2b7e:	92 81       	ldd	r25, Z+2	; 0x02
    2b80:	9a 83       	std	Y+2, r25	; 0x02
    2b82:	89 83       	std	Y+1, r24	; 0x01
    2b84:	eb 81       	ldd	r30, Y+3	; 0x03
    2b86:	fc 81       	ldd	r31, Y+4	; 0x04
    2b88:	89 81       	ldd	r24, Y+1	; 0x01
    2b8a:	9a 81       	ldd	r25, Y+2	; 0x02
    2b8c:	95 83       	std	Z+5, r25	; 0x05
    2b8e:	84 83       	std	Z+4, r24	; 0x04
    2b90:	e9 81       	ldd	r30, Y+1	; 0x01
    2b92:	fa 81       	ldd	r31, Y+2	; 0x02
    2b94:	84 81       	ldd	r24, Z+4	; 0x04
    2b96:	95 81       	ldd	r25, Z+5	; 0x05
    2b98:	eb 81       	ldd	r30, Y+3	; 0x03
    2b9a:	fc 81       	ldd	r31, Y+4	; 0x04
    2b9c:	97 83       	std	Z+7, r25	; 0x07
    2b9e:	86 83       	std	Z+6, r24	; 0x06
    2ba0:	e9 81       	ldd	r30, Y+1	; 0x01
    2ba2:	fa 81       	ldd	r31, Y+2	; 0x02
    2ba4:	04 80       	ldd	r0, Z+4	; 0x04
    2ba6:	f5 81       	ldd	r31, Z+5	; 0x05
    2ba8:	e0 2d       	mov	r30, r0
    2baa:	8b 81       	ldd	r24, Y+3	; 0x03
    2bac:	9c 81       	ldd	r25, Y+4	; 0x04
    2bae:	02 96       	adiw	r24, 0x02	; 2
    2bb0:	93 83       	std	Z+3, r25	; 0x03
    2bb2:	82 83       	std	Z+2, r24	; 0x02
    2bb4:	8b 81       	ldd	r24, Y+3	; 0x03
    2bb6:	9c 81       	ldd	r25, Y+4	; 0x04
    2bb8:	02 96       	adiw	r24, 0x02	; 2
    2bba:	e9 81       	ldd	r30, Y+1	; 0x01
    2bbc:	fa 81       	ldd	r31, Y+2	; 0x02
    2bbe:	95 83       	std	Z+5, r25	; 0x05
    2bc0:	84 83       	std	Z+4, r24	; 0x04
    2bc2:	eb 81       	ldd	r30, Y+3	; 0x03
    2bc4:	fc 81       	ldd	r31, Y+4	; 0x04
    2bc6:	86 89       	ldd	r24, Z+22	; 0x16
    2bc8:	28 2f       	mov	r18, r24
    2bca:	30 e0       	ldi	r19, 0x00	; 0
    2bcc:	c9 01       	movw	r24, r18
    2bce:	88 0f       	add	r24, r24
    2bd0:	99 1f       	adc	r25, r25
    2bd2:	88 0f       	add	r24, r24
    2bd4:	99 1f       	adc	r25, r25
    2bd6:	88 0f       	add	r24, r24
    2bd8:	99 1f       	adc	r25, r25
    2bda:	82 0f       	add	r24, r18
    2bdc:	93 1f       	adc	r25, r19
    2bde:	80 5c       	subi	r24, 0xC0	; 192
    2be0:	98 4f       	sbci	r25, 0xF8	; 248
    2be2:	eb 81       	ldd	r30, Y+3	; 0x03
    2be4:	fc 81       	ldd	r31, Y+4	; 0x04
    2be6:	93 87       	std	Z+11, r25	; 0x0b
    2be8:	82 87       	std	Z+10, r24	; 0x0a
    2bea:	eb 81       	ldd	r30, Y+3	; 0x03
    2bec:	fc 81       	ldd	r31, Y+4	; 0x04
    2bee:	86 89       	ldd	r24, Z+22	; 0x16
    2bf0:	28 2f       	mov	r18, r24
    2bf2:	30 e0       	ldi	r19, 0x00	; 0
    2bf4:	c9 01       	movw	r24, r18
    2bf6:	88 0f       	add	r24, r24
    2bf8:	99 1f       	adc	r25, r25
    2bfa:	88 0f       	add	r24, r24
    2bfc:	99 1f       	adc	r25, r25
    2bfe:	88 0f       	add	r24, r24
    2c00:	99 1f       	adc	r25, r25
    2c02:	82 0f       	add	r24, r18
    2c04:	93 1f       	adc	r25, r19
    2c06:	fc 01       	movw	r30, r24
    2c08:	e0 5c       	subi	r30, 0xC0	; 192
    2c0a:	f8 4f       	sbci	r31, 0xF8	; 248
    2c0c:	80 81       	ld	r24, Z
    2c0e:	8f 5f       	subi	r24, 0xFF	; 255
    2c10:	80 83       	st	Z, r24

        portSETUP_TCB( pxNewTCB );
    }
    taskEXIT_CRITICAL();
    2c12:	0f 90       	pop	r0
    2c14:	0f be       	out	0x3f, r0	; 63

    if( xSchedulerRunning != pdFALSE )
    2c16:	80 91 35 07 	lds	r24, 0x0735
    2c1a:	88 23       	and	r24, r24
    2c1c:	61 f0       	breq	.+24     	; 0x2c36 <prvAddNewTaskToReadyList+0x16c>
    {
        /* If the created task is of a higher priority than the current task
         * then it should run now. */
        if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    2c1e:	e0 91 2e 07 	lds	r30, 0x072E
    2c22:	f0 91 2f 07 	lds	r31, 0x072F
    2c26:	96 89       	ldd	r25, Z+22	; 0x16
    2c28:	eb 81       	ldd	r30, Y+3	; 0x03
    2c2a:	fc 81       	ldd	r31, Y+4	; 0x04
    2c2c:	86 89       	ldd	r24, Z+22	; 0x16
    2c2e:	98 17       	cp	r25, r24
    2c30:	10 f4       	brcc	.+4      	; 0x2c36 <prvAddNewTaskToReadyList+0x16c>
        {
            taskYIELD_IF_USING_PREEMPTION();
    2c32:	0e 94 a6 02 	call	0x54c	; 0x54c <vPortYield>
    }
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }
}
    2c36:	0f 90       	pop	r0
    2c38:	0f 90       	pop	r0
    2c3a:	0f 90       	pop	r0
    2c3c:	0f 90       	pop	r0
    2c3e:	cf 91       	pop	r28
    2c40:	df 91       	pop	r29
    2c42:	08 95       	ret

00002c44 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

    void vTaskDelete( TaskHandle_t xTaskToDelete )
    {
    2c44:	df 93       	push	r29
    2c46:	cf 93       	push	r28
    2c48:	00 d0       	rcall	.+0      	; 0x2c4a <vTaskDelete+0x6>
    2c4a:	00 d0       	rcall	.+0      	; 0x2c4c <vTaskDelete+0x8>
    2c4c:	00 d0       	rcall	.+0      	; 0x2c4e <vTaskDelete+0xa>
    2c4e:	cd b7       	in	r28, 0x3d	; 61
    2c50:	de b7       	in	r29, 0x3e	; 62
    2c52:	9c 83       	std	Y+4, r25	; 0x04
    2c54:	8b 83       	std	Y+3, r24	; 0x03
        TCB_t * pxTCB;

        taskENTER_CRITICAL();
    2c56:	0f b6       	in	r0, 0x3f	; 63
    2c58:	f8 94       	cli
    2c5a:	0f 92       	push	r0
        {
            /* If null is passed in here then it is the calling task that is
             * being deleted. */
            pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    2c5c:	8b 81       	ldd	r24, Y+3	; 0x03
    2c5e:	9c 81       	ldd	r25, Y+4	; 0x04
    2c60:	00 97       	sbiw	r24, 0x00	; 0
    2c62:	39 f4       	brne	.+14     	; 0x2c72 <vTaskDelete+0x2e>
    2c64:	80 91 2e 07 	lds	r24, 0x072E
    2c68:	90 91 2f 07 	lds	r25, 0x072F
    2c6c:	9e 83       	std	Y+6, r25	; 0x06
    2c6e:	8d 83       	std	Y+5, r24	; 0x05
    2c70:	04 c0       	rjmp	.+8      	; 0x2c7a <vTaskDelete+0x36>
    2c72:	8b 81       	ldd	r24, Y+3	; 0x03
    2c74:	9c 81       	ldd	r25, Y+4	; 0x04
    2c76:	9e 83       	std	Y+6, r25	; 0x06
    2c78:	8d 83       	std	Y+5, r24	; 0x05
    2c7a:	8d 81       	ldd	r24, Y+5	; 0x05
    2c7c:	9e 81       	ldd	r25, Y+6	; 0x06
    2c7e:	9a 83       	std	Y+2, r25	; 0x02
    2c80:	89 83       	std	Y+1, r24	; 0x01

            /* Remove task from the ready/delayed list. */
            if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    2c82:	89 81       	ldd	r24, Y+1	; 0x01
    2c84:	9a 81       	ldd	r25, Y+2	; 0x02
    2c86:	02 96       	adiw	r24, 0x02	; 2
    2c88:	0e 94 c9 0a 	call	0x1592	; 0x1592 <uxListRemove>
            {
                mtCOVERAGE_TEST_MARKER();
            }

            /* Is the task waiting on an event also? */
            if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    2c8c:	e9 81       	ldd	r30, Y+1	; 0x01
    2c8e:	fa 81       	ldd	r31, Y+2	; 0x02
    2c90:	84 89       	ldd	r24, Z+20	; 0x14
    2c92:	95 89       	ldd	r25, Z+21	; 0x15
    2c94:	00 97       	sbiw	r24, 0x00	; 0
    2c96:	29 f0       	breq	.+10     	; 0x2ca2 <vTaskDelete+0x5e>
            {
                ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    2c98:	89 81       	ldd	r24, Y+1	; 0x01
    2c9a:	9a 81       	ldd	r25, Y+2	; 0x02
    2c9c:	0c 96       	adiw	r24, 0x0c	; 12
    2c9e:	0e 94 c9 0a 	call	0x1592	; 0x1592 <uxListRemove>

            /* Increment the uxTaskNumber also so kernel aware debuggers can
             * detect that the task lists need re-generating.  This is done before
             * portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
             * not return. */
            uxTaskNumber++;
    2ca2:	80 91 3a 07 	lds	r24, 0x073A
    2ca6:	8f 5f       	subi	r24, 0xFF	; 255
    2ca8:	80 93 3a 07 	sts	0x073A, r24

            if( pxTCB == pxCurrentTCB )
    2cac:	20 91 2e 07 	lds	r18, 0x072E
    2cb0:	30 91 2f 07 	lds	r19, 0x072F
    2cb4:	89 81       	ldd	r24, Y+1	; 0x01
    2cb6:	9a 81       	ldd	r25, Y+2	; 0x02
    2cb8:	82 17       	cp	r24, r18
    2cba:	93 07       	cpc	r25, r19
    2cbc:	81 f4       	brne	.+32     	; 0x2cde <vTaskDelete+0x9a>
                /* A task is deleting itself.  This cannot complete within the
                 * task itself, as a context switch to another task is required.
                 * Place the task in the termination list.  The idle task will
                 * check the termination list and free up any memory allocated by
                 * the scheduler for the TCB and stack of the deleted task. */
                vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
    2cbe:	89 81       	ldd	r24, Y+1	; 0x01
    2cc0:	9a 81       	ldd	r25, Y+2	; 0x02
    2cc2:	9c 01       	movw	r18, r24
    2cc4:	2e 5f       	subi	r18, 0xFE	; 254
    2cc6:	3f 4f       	sbci	r19, 0xFF	; 255
    2cc8:	83 e8       	ldi	r24, 0x83	; 131
    2cca:	97 e0       	ldi	r25, 0x07	; 7
    2ccc:	b9 01       	movw	r22, r18
    2cce:	0e 94 19 0a 	call	0x1432	; 0x1432 <vListInsertEnd>

                /* Increment the ucTasksDeleted variable so the idle task knows
                 * there is a task that has been deleted and that it should therefore
                 * check the xTasksWaitingTermination list. */
                ++uxDeletedTasksWaitingCleanUp;
    2cd2:	80 91 30 07 	lds	r24, 0x0730
    2cd6:	8f 5f       	subi	r24, 0xFF	; 255
    2cd8:	80 93 30 07 	sts	0x0730, r24
    2cdc:	07 c0       	rjmp	.+14     	; 0x2cec <vTaskDelete+0xa8>
                 * required. */
                portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
            }
            else
            {
                --uxCurrentNumberOfTasks;
    2cde:	80 91 31 07 	lds	r24, 0x0731
    2ce2:	81 50       	subi	r24, 0x01	; 1
    2ce4:	80 93 31 07 	sts	0x0731, r24
                traceTASK_DELETE( pxTCB );

                /* Reset the next expected unblock time in case it referred to
                 * the task that has just been deleted. */
                prvResetNextTaskUnblockTime();
    2ce8:	0e 94 63 1f 	call	0x3ec6	; 0x3ec6 <prvResetNextTaskUnblockTime>
            }
        }
        taskEXIT_CRITICAL();
    2cec:	0f 90       	pop	r0
    2cee:	0f be       	out	0x3f, r0	; 63

        /* If the task is not deleting itself, call prvDeleteTCB from outside of
         * critical section. If a task deletes itself, prvDeleteTCB is called
         * from prvCheckTasksWaitingTermination which is called from Idle task. */
        if( pxTCB != pxCurrentTCB )
    2cf0:	20 91 2e 07 	lds	r18, 0x072E
    2cf4:	30 91 2f 07 	lds	r19, 0x072F
    2cf8:	89 81       	ldd	r24, Y+1	; 0x01
    2cfa:	9a 81       	ldd	r25, Y+2	; 0x02
    2cfc:	82 17       	cp	r24, r18
    2cfe:	93 07       	cpc	r25, r19
    2d00:	21 f0       	breq	.+8      	; 0x2d0a <vTaskDelete+0xc6>
        {
            prvDeleteTCB( pxTCB );
    2d02:	89 81       	ldd	r24, Y+1	; 0x01
    2d04:	9a 81       	ldd	r25, Y+2	; 0x02
    2d06:	0e 94 4d 1f 	call	0x3e9a	; 0x3e9a <prvDeleteTCB>
        }

        /* Force a reschedule if it is the currently running task that has just
         * been deleted. */
        if( xSchedulerRunning != pdFALSE )
    2d0a:	80 91 35 07 	lds	r24, 0x0735
    2d0e:	88 23       	and	r24, r24
    2d10:	59 f0       	breq	.+22     	; 0x2d28 <vTaskDelete+0xe4>
        {
            if( pxTCB == pxCurrentTCB )
    2d12:	20 91 2e 07 	lds	r18, 0x072E
    2d16:	30 91 2f 07 	lds	r19, 0x072F
    2d1a:	89 81       	ldd	r24, Y+1	; 0x01
    2d1c:	9a 81       	ldd	r25, Y+2	; 0x02
    2d1e:	82 17       	cp	r24, r18
    2d20:	93 07       	cpc	r25, r19
    2d22:	11 f4       	brne	.+4      	; 0x2d28 <vTaskDelete+0xe4>
            {
                configASSERT( uxSchedulerSuspended == 0 );
                portYIELD_WITHIN_API();
    2d24:	0e 94 a6 02 	call	0x54c	; 0x54c <vPortYield>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    }
    2d28:	26 96       	adiw	r28, 0x06	; 6
    2d2a:	0f b6       	in	r0, 0x3f	; 63
    2d2c:	f8 94       	cli
    2d2e:	de bf       	out	0x3e, r29	; 62
    2d30:	0f be       	out	0x3f, r0	; 63
    2d32:	cd bf       	out	0x3d, r28	; 61
    2d34:	cf 91       	pop	r28
    2d36:	df 91       	pop	r29
    2d38:	08 95       	ret

00002d3a <xTaskDelayUntil>:

#if ( INCLUDE_xTaskDelayUntil == 1 )

    BaseType_t xTaskDelayUntil( TickType_t * const pxPreviousWakeTime,
                                const TickType_t xTimeIncrement )
    {
    2d3a:	df 93       	push	r29
    2d3c:	cf 93       	push	r28
    2d3e:	cd b7       	in	r28, 0x3d	; 61
    2d40:	de b7       	in	r29, 0x3e	; 62
    2d42:	2a 97       	sbiw	r28, 0x0a	; 10
    2d44:	0f b6       	in	r0, 0x3f	; 63
    2d46:	f8 94       	cli
    2d48:	de bf       	out	0x3e, r29	; 62
    2d4a:	0f be       	out	0x3f, r0	; 63
    2d4c:	cd bf       	out	0x3d, r28	; 61
    2d4e:	98 87       	std	Y+8, r25	; 0x08
    2d50:	8f 83       	std	Y+7, r24	; 0x07
    2d52:	7a 87       	std	Y+10, r23	; 0x0a
    2d54:	69 87       	std	Y+9, r22	; 0x09
        TickType_t xTimeToWake;
        BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
    2d56:	1b 82       	std	Y+3, r1	; 0x03

        configASSERT( pxPreviousWakeTime );
        configASSERT( ( xTimeIncrement > 0U ) );
        configASSERT( uxSchedulerSuspended == 0 );

        vTaskSuspendAll();
    2d58:	0e 94 73 17 	call	0x2ee6	; 0x2ee6 <vTaskSuspendAll>
        {
            /* Minor optimisation.  The tick count cannot change in this
             * block. */
            const TickType_t xConstTickCount = xTickCount;
    2d5c:	80 91 32 07 	lds	r24, 0x0732
    2d60:	90 91 33 07 	lds	r25, 0x0733
    2d64:	9a 83       	std	Y+2, r25	; 0x02
    2d66:	89 83       	std	Y+1, r24	; 0x01

            /* Generate the tick time at which the task wants to wake. */
            xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    2d68:	ef 81       	ldd	r30, Y+7	; 0x07
    2d6a:	f8 85       	ldd	r31, Y+8	; 0x08
    2d6c:	20 81       	ld	r18, Z
    2d6e:	31 81       	ldd	r19, Z+1	; 0x01
    2d70:	89 85       	ldd	r24, Y+9	; 0x09
    2d72:	9a 85       	ldd	r25, Y+10	; 0x0a
    2d74:	82 0f       	add	r24, r18
    2d76:	93 1f       	adc	r25, r19
    2d78:	9e 83       	std	Y+6, r25	; 0x06
    2d7a:	8d 83       	std	Y+5, r24	; 0x05

            if( xConstTickCount < *pxPreviousWakeTime )
    2d7c:	ef 81       	ldd	r30, Y+7	; 0x07
    2d7e:	f8 85       	ldd	r31, Y+8	; 0x08
    2d80:	20 81       	ld	r18, Z
    2d82:	31 81       	ldd	r19, Z+1	; 0x01
    2d84:	89 81       	ldd	r24, Y+1	; 0x01
    2d86:	9a 81       	ldd	r25, Y+2	; 0x02
    2d88:	82 17       	cp	r24, r18
    2d8a:	93 07       	cpc	r25, r19
    2d8c:	98 f4       	brcc	.+38     	; 0x2db4 <xTaskDelayUntil+0x7a>
                /* The tick count has overflowed since this function was
                 * lasted called.  In this case the only time we should ever
                 * actually delay is if the wake time has also  overflowed,
                 * and the wake time is greater than the tick time.  When this
                 * is the case it is as if neither time had overflowed. */
                if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
    2d8e:	ef 81       	ldd	r30, Y+7	; 0x07
    2d90:	f8 85       	ldd	r31, Y+8	; 0x08
    2d92:	20 81       	ld	r18, Z
    2d94:	31 81       	ldd	r19, Z+1	; 0x01
    2d96:	8d 81       	ldd	r24, Y+5	; 0x05
    2d98:	9e 81       	ldd	r25, Y+6	; 0x06
    2d9a:	82 17       	cp	r24, r18
    2d9c:	93 07       	cpc	r25, r19
    2d9e:	e0 f4       	brcc	.+56     	; 0x2dd8 <xTaskDelayUntil+0x9e>
    2da0:	2d 81       	ldd	r18, Y+5	; 0x05
    2da2:	3e 81       	ldd	r19, Y+6	; 0x06
    2da4:	89 81       	ldd	r24, Y+1	; 0x01
    2da6:	9a 81       	ldd	r25, Y+2	; 0x02
    2da8:	82 17       	cp	r24, r18
    2daa:	93 07       	cpc	r25, r19
    2dac:	a8 f4       	brcc	.+42     	; 0x2dd8 <xTaskDelayUntil+0x9e>
                {
                    xShouldDelay = pdTRUE;
    2dae:	81 e0       	ldi	r24, 0x01	; 1
    2db0:	8b 83       	std	Y+3, r24	; 0x03
    2db2:	12 c0       	rjmp	.+36     	; 0x2dd8 <xTaskDelayUntil+0x9e>
            else
            {
                /* The tick time has not overflowed.  In this case we will
                 * delay if either the wake time has overflowed, and/or the
                 * tick time is less than the wake time. */
                if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
    2db4:	ef 81       	ldd	r30, Y+7	; 0x07
    2db6:	f8 85       	ldd	r31, Y+8	; 0x08
    2db8:	20 81       	ld	r18, Z
    2dba:	31 81       	ldd	r19, Z+1	; 0x01
    2dbc:	8d 81       	ldd	r24, Y+5	; 0x05
    2dbe:	9e 81       	ldd	r25, Y+6	; 0x06
    2dc0:	82 17       	cp	r24, r18
    2dc2:	93 07       	cpc	r25, r19
    2dc4:	38 f0       	brcs	.+14     	; 0x2dd4 <xTaskDelayUntil+0x9a>
    2dc6:	2d 81       	ldd	r18, Y+5	; 0x05
    2dc8:	3e 81       	ldd	r19, Y+6	; 0x06
    2dca:	89 81       	ldd	r24, Y+1	; 0x01
    2dcc:	9a 81       	ldd	r25, Y+2	; 0x02
    2dce:	82 17       	cp	r24, r18
    2dd0:	93 07       	cpc	r25, r19
    2dd2:	10 f4       	brcc	.+4      	; 0x2dd8 <xTaskDelayUntil+0x9e>
                {
                    xShouldDelay = pdTRUE;
    2dd4:	81 e0       	ldi	r24, 0x01	; 1
    2dd6:	8b 83       	std	Y+3, r24	; 0x03
                    mtCOVERAGE_TEST_MARKER();
                }
            }

            /* Update the wake time ready for the next call. */
            *pxPreviousWakeTime = xTimeToWake;
    2dd8:	ef 81       	ldd	r30, Y+7	; 0x07
    2dda:	f8 85       	ldd	r31, Y+8	; 0x08
    2ddc:	8d 81       	ldd	r24, Y+5	; 0x05
    2dde:	9e 81       	ldd	r25, Y+6	; 0x06
    2de0:	91 83       	std	Z+1, r25	; 0x01
    2de2:	80 83       	st	Z, r24

            if( xShouldDelay != pdFALSE )
    2de4:	8b 81       	ldd	r24, Y+3	; 0x03
    2de6:	88 23       	and	r24, r24
    2de8:	49 f0       	breq	.+18     	; 0x2dfc <xTaskDelayUntil+0xc2>
            {
                traceTASK_DELAY_UNTIL( xTimeToWake );

                /* prvAddCurrentTaskToDelayedList() needs the block time, not
                 * the time to wake, so subtract the current tick count. */
                prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
    2dea:	8d 81       	ldd	r24, Y+5	; 0x05
    2dec:	9e 81       	ldd	r25, Y+6	; 0x06
    2dee:	29 81       	ldd	r18, Y+1	; 0x01
    2df0:	3a 81       	ldd	r19, Y+2	; 0x02
    2df2:	82 1b       	sub	r24, r18
    2df4:	93 0b       	sbc	r25, r19
    2df6:	60 e0       	ldi	r22, 0x00	; 0
    2df8:	0e 94 31 27 	call	0x4e62	; 0x4e62 <prvAddCurrentTaskToDelayedList>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        xAlreadyYielded = xTaskResumeAll();
    2dfc:	0e 94 7f 17 	call	0x2efe	; 0x2efe <xTaskResumeAll>
    2e00:	8c 83       	std	Y+4, r24	; 0x04

        /* Force a reschedule if xTaskResumeAll has not already done so, we may
         * have put ourselves to sleep. */
        if( xAlreadyYielded == pdFALSE )
    2e02:	8c 81       	ldd	r24, Y+4	; 0x04
    2e04:	88 23       	and	r24, r24
    2e06:	11 f4       	brne	.+4      	; 0x2e0c <xTaskDelayUntil+0xd2>
        {
            portYIELD_WITHIN_API();
    2e08:	0e 94 a6 02 	call	0x54c	; 0x54c <vPortYield>
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xShouldDelay;
    2e0c:	8b 81       	ldd	r24, Y+3	; 0x03
    }
    2e0e:	2a 96       	adiw	r28, 0x0a	; 10
    2e10:	0f b6       	in	r0, 0x3f	; 63
    2e12:	f8 94       	cli
    2e14:	de bf       	out	0x3e, r29	; 62
    2e16:	0f be       	out	0x3f, r0	; 63
    2e18:	cd bf       	out	0x3d, r28	; 61
    2e1a:	cf 91       	pop	r28
    2e1c:	df 91       	pop	r29
    2e1e:	08 95       	ret

00002e20 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

    void vTaskDelay( const TickType_t xTicksToDelay )
    {
    2e20:	df 93       	push	r29
    2e22:	cf 93       	push	r28
    2e24:	00 d0       	rcall	.+0      	; 0x2e26 <vTaskDelay+0x6>
    2e26:	0f 92       	push	r0
    2e28:	cd b7       	in	r28, 0x3d	; 61
    2e2a:	de b7       	in	r29, 0x3e	; 62
    2e2c:	9b 83       	std	Y+3, r25	; 0x03
    2e2e:	8a 83       	std	Y+2, r24	; 0x02
        BaseType_t xAlreadyYielded = pdFALSE;
    2e30:	19 82       	std	Y+1, r1	; 0x01

        /* A delay time of zero just forces a reschedule. */
        if( xTicksToDelay > ( TickType_t ) 0U )
    2e32:	8a 81       	ldd	r24, Y+2	; 0x02
    2e34:	9b 81       	ldd	r25, Y+3	; 0x03
    2e36:	00 97       	sbiw	r24, 0x00	; 0
    2e38:	51 f0       	breq	.+20     	; 0x2e4e <vTaskDelay+0x2e>
        {
            configASSERT( uxSchedulerSuspended == 0 );
            vTaskSuspendAll();
    2e3a:	0e 94 73 17 	call	0x2ee6	; 0x2ee6 <vTaskSuspendAll>
                 * list or removed from the blocked list until the scheduler
                 * is resumed.
                 *
                 * This task cannot be in an event list as it is the currently
                 * executing task. */
                prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
    2e3e:	8a 81       	ldd	r24, Y+2	; 0x02
    2e40:	9b 81       	ldd	r25, Y+3	; 0x03
    2e42:	60 e0       	ldi	r22, 0x00	; 0
    2e44:	0e 94 31 27 	call	0x4e62	; 0x4e62 <prvAddCurrentTaskToDelayedList>
            }
            xAlreadyYielded = xTaskResumeAll();
    2e48:	0e 94 7f 17 	call	0x2efe	; 0x2efe <xTaskResumeAll>
    2e4c:	89 83       	std	Y+1, r24	; 0x01
            mtCOVERAGE_TEST_MARKER();
        }

        /* Force a reschedule if xTaskResumeAll has not already done so, we may
         * have put ourselves to sleep. */
        if( xAlreadyYielded == pdFALSE )
    2e4e:	89 81       	ldd	r24, Y+1	; 0x01
    2e50:	88 23       	and	r24, r24
    2e52:	11 f4       	brne	.+4      	; 0x2e58 <vTaskDelay+0x38>
        {
            portYIELD_WITHIN_API();
    2e54:	0e 94 a6 02 	call	0x54c	; 0x54c <vPortYield>
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    2e58:	0f 90       	pop	r0
    2e5a:	0f 90       	pop	r0
    2e5c:	0f 90       	pop	r0
    2e5e:	cf 91       	pop	r28
    2e60:	df 91       	pop	r29
    2e62:	08 95       	ret

00002e64 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    2e64:	ef 92       	push	r14
    2e66:	ff 92       	push	r15
    2e68:	0f 93       	push	r16
    2e6a:	df 93       	push	r29
    2e6c:	cf 93       	push	r28
    2e6e:	00 d0       	rcall	.+0      	; 0x2e70 <vTaskStartScheduler+0xc>
    2e70:	cd b7       	in	r28, 0x3d	; 61
    2e72:	de b7       	in	r29, 0x3e	; 62
            }
        }
    #else /* if ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
        {
            /* The Idle task is being created using dynamically allocated RAM. */
            xReturn = xTaskCreate( prvIdleTask,
    2e74:	81 ed       	ldi	r24, 0xD1	; 209
    2e76:	9e e1       	ldi	r25, 0x1E	; 30
    2e78:	20 e0       	ldi	r18, 0x00	; 0
    2e7a:	31 e0       	ldi	r19, 0x01	; 1
    2e7c:	ed e3       	ldi	r30, 0x3D	; 61
    2e7e:	f7 e0       	ldi	r31, 0x07	; 7
    2e80:	b9 01       	movw	r22, r18
    2e82:	45 e5       	ldi	r20, 0x55	; 85
    2e84:	50 e0       	ldi	r21, 0x00	; 0
    2e86:	20 e0       	ldi	r18, 0x00	; 0
    2e88:	30 e0       	ldi	r19, 0x00	; 0
    2e8a:	00 e0       	ldi	r16, 0x00	; 0
    2e8c:	7f 01       	movw	r14, r30
    2e8e:	0e 94 28 14 	call	0x2850	; 0x2850 <xTaskCreate>
    2e92:	89 83       	std	Y+1, r24	; 0x01
                mtCOVERAGE_TEST_MARKER();
            }
        }
    #endif /* configUSE_TIMERS */

    if( xReturn == pdPASS )
    2e94:	89 81       	ldd	r24, Y+1	; 0x01
    2e96:	81 30       	cpi	r24, 0x01	; 1
    2e98:	81 f4       	brne	.+32     	; 0x2eba <vTaskStartScheduler+0x56>
        /* Interrupts are turned off here, to ensure a tick does not occur
         * before or during the call to xPortStartScheduler().  The stacks of
         * the created tasks contain a status word with interrupts switched on
         * so interrupts will automatically get re-enabled when the first task
         * starts to run. */
        portDISABLE_INTERRUPTS();
    2e9a:	f8 94       	cli
                 * for additional information. */
                _impure_ptr = &( pxCurrentTCB->xNewLib_reent );
            }
        #endif /* configUSE_NEWLIB_REENTRANT */

        xNextTaskUnblockTime = portMAX_DELAY;
    2e9c:	8f ef       	ldi	r24, 0xFF	; 255
    2e9e:	9f ef       	ldi	r25, 0xFF	; 255
    2ea0:	90 93 3c 07 	sts	0x073C, r25
    2ea4:	80 93 3b 07 	sts	0x073B, r24
        xSchedulerRunning = pdTRUE;
    2ea8:	81 e0       	ldi	r24, 0x01	; 1
    2eaa:	80 93 35 07 	sts	0x0735, r24
        xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
    2eae:	10 92 33 07 	sts	0x0733, r1
    2eb2:	10 92 32 07 	sts	0x0732, r1

        traceTASK_SWITCHED_IN();

        /* Setting up the timer tick is hardware specific and thus in the
         * portable interface. */
        if( xPortStartScheduler() != pdFALSE )
    2eb6:	0e 94 6a 02 	call	0x4d4	; 0x4d4 <xPortStartScheduler>
     * meaning xIdleTaskHandle is not used anywhere else. */
    ( void ) xIdleTaskHandle;

    /* OpenOCD makes use of uxTopUsedPriority for thread debugging. Prevent uxTopUsedPriority
     * from getting optimized out as it is no longer used by the kernel. */
    ( void ) uxTopUsedPriority;
    2eba:	80 91 12 01 	lds	r24, 0x0112
}
    2ebe:	0f 90       	pop	r0
    2ec0:	0f 90       	pop	r0
    2ec2:	cf 91       	pop	r28
    2ec4:	df 91       	pop	r29
    2ec6:	0f 91       	pop	r16
    2ec8:	ff 90       	pop	r15
    2eca:	ef 90       	pop	r14
    2ecc:	08 95       	ret

00002ece <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    2ece:	df 93       	push	r29
    2ed0:	cf 93       	push	r28
    2ed2:	cd b7       	in	r28, 0x3d	; 61
    2ed4:	de b7       	in	r29, 0x3e	; 62
    /* Stop the scheduler interrupts and call the portable scheduler end
     * routine so the original ISRs can be restored if necessary.  The port
     * layer must ensure interrupts enable  bit is left in the correct state. */
    portDISABLE_INTERRUPTS();
    2ed6:	f8 94       	cli
    xSchedulerRunning = pdFALSE;
    2ed8:	10 92 35 07 	sts	0x0735, r1
    vPortEndScheduler();
    2edc:	0e 94 9f 02 	call	0x53e	; 0x53e <vPortEndScheduler>
}
    2ee0:	cf 91       	pop	r28
    2ee2:	df 91       	pop	r29
    2ee4:	08 95       	ret

00002ee6 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    2ee6:	df 93       	push	r29
    2ee8:	cf 93       	push	r28
    2eea:	cd b7       	in	r28, 0x3d	; 61
    2eec:	de b7       	in	r29, 0x3e	; 62
     * do not otherwise exhibit real time behaviour. */
    portSOFTWARE_BARRIER();

    /* The scheduler is suspended if uxSchedulerSuspended is non-zero.  An increment
     * is used to allow calls to vTaskSuspendAll() to nest. */
    ++uxSchedulerSuspended;
    2eee:	80 91 3f 07 	lds	r24, 0x073F
    2ef2:	8f 5f       	subi	r24, 0xFF	; 255
    2ef4:	80 93 3f 07 	sts	0x073F, r24

    /* Enforces ordering for ports and optimised compilers that may otherwise place
     * the above increment elsewhere. */
    portMEMORY_BARRIER();
}
    2ef8:	cf 91       	pop	r28
    2efa:	df 91       	pop	r29
    2efc:	08 95       	ret

00002efe <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    2efe:	df 93       	push	r29
    2f00:	cf 93       	push	r28
    2f02:	cd b7       	in	r28, 0x3d	; 61
    2f04:	de b7       	in	r29, 0x3e	; 62
    2f06:	2b 97       	sbiw	r28, 0x0b	; 11
    2f08:	0f b6       	in	r0, 0x3f	; 63
    2f0a:	f8 94       	cli
    2f0c:	de bf       	out	0x3e, r29	; 62
    2f0e:	0f be       	out	0x3f, r0	; 63
    2f10:	cd bf       	out	0x3d, r28	; 61
    TCB_t * pxTCB = NULL;
    2f12:	1b 86       	std	Y+11, r1	; 0x0b
    2f14:	1a 86       	std	Y+10, r1	; 0x0a
    BaseType_t xAlreadyYielded = pdFALSE;
    2f16:	19 86       	std	Y+9, r1	; 0x09
    /* It is possible that an ISR caused a task to be removed from an event
     * list while the scheduler was suspended.  If this was the case then the
     * removed task will have been added to the xPendingReadyList.  Once the
     * scheduler has been resumed it is safe to move all the pending ready
     * tasks from this list into their appropriate ready list. */
    taskENTER_CRITICAL();
    2f18:	0f b6       	in	r0, 0x3f	; 63
    2f1a:	f8 94       	cli
    2f1c:	0f 92       	push	r0
    {
        --uxSchedulerSuspended;
    2f1e:	80 91 3f 07 	lds	r24, 0x073F
    2f22:	81 50       	subi	r24, 0x01	; 1
    2f24:	80 93 3f 07 	sts	0x073F, r24

        if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    2f28:	80 91 3f 07 	lds	r24, 0x073F
    2f2c:	88 23       	and	r24, r24
    2f2e:	09 f0       	breq	.+2      	; 0x2f32 <xTaskResumeAll+0x34>
    2f30:	2a c1       	rjmp	.+596    	; 0x3186 <xTaskResumeAll+0x288>
        {
            if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    2f32:	80 91 31 07 	lds	r24, 0x0731
    2f36:	88 23       	and	r24, r24
    2f38:	09 f4       	brne	.+2      	; 0x2f3c <xTaskResumeAll+0x3e>
    2f3a:	25 c1       	rjmp	.+586    	; 0x3186 <xTaskResumeAll+0x288>
    2f3c:	f3 c0       	rjmp	.+486    	; 0x3124 <xTaskResumeAll+0x226>
            {
                /* Move any readied tasks from the pending list into the
                 * appropriate ready list. */
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
                {
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    2f3e:	e0 91 7f 07 	lds	r30, 0x077F
    2f42:	f0 91 80 07 	lds	r31, 0x0780
    2f46:	86 81       	ldd	r24, Z+6	; 0x06
    2f48:	97 81       	ldd	r25, Z+7	; 0x07
    2f4a:	9b 87       	std	Y+11, r25	; 0x0b
    2f4c:	8a 87       	std	Y+10, r24	; 0x0a
                    listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
    2f4e:	ea 85       	ldd	r30, Y+10	; 0x0a
    2f50:	fb 85       	ldd	r31, Y+11	; 0x0b
    2f52:	84 89       	ldd	r24, Z+20	; 0x14
    2f54:	95 89       	ldd	r25, Z+21	; 0x15
    2f56:	98 87       	std	Y+8, r25	; 0x08
    2f58:	8f 83       	std	Y+7, r24	; 0x07
    2f5a:	ea 85       	ldd	r30, Y+10	; 0x0a
    2f5c:	fb 85       	ldd	r31, Y+11	; 0x0b
    2f5e:	a6 85       	ldd	r26, Z+14	; 0x0e
    2f60:	b7 85       	ldd	r27, Z+15	; 0x0f
    2f62:	ea 85       	ldd	r30, Y+10	; 0x0a
    2f64:	fb 85       	ldd	r31, Y+11	; 0x0b
    2f66:	80 89       	ldd	r24, Z+16	; 0x10
    2f68:	91 89       	ldd	r25, Z+17	; 0x11
    2f6a:	15 96       	adiw	r26, 0x05	; 5
    2f6c:	9c 93       	st	X, r25
    2f6e:	8e 93       	st	-X, r24
    2f70:	14 97       	sbiw	r26, 0x04	; 4
    2f72:	ea 85       	ldd	r30, Y+10	; 0x0a
    2f74:	fb 85       	ldd	r31, Y+11	; 0x0b
    2f76:	a0 89       	ldd	r26, Z+16	; 0x10
    2f78:	b1 89       	ldd	r27, Z+17	; 0x11
    2f7a:	ea 85       	ldd	r30, Y+10	; 0x0a
    2f7c:	fb 85       	ldd	r31, Y+11	; 0x0b
    2f7e:	86 85       	ldd	r24, Z+14	; 0x0e
    2f80:	97 85       	ldd	r25, Z+15	; 0x0f
    2f82:	13 96       	adiw	r26, 0x03	; 3
    2f84:	9c 93       	st	X, r25
    2f86:	8e 93       	st	-X, r24
    2f88:	12 97       	sbiw	r26, 0x02	; 2
    2f8a:	ef 81       	ldd	r30, Y+7	; 0x07
    2f8c:	f8 85       	ldd	r31, Y+8	; 0x08
    2f8e:	21 81       	ldd	r18, Z+1	; 0x01
    2f90:	32 81       	ldd	r19, Z+2	; 0x02
    2f92:	8a 85       	ldd	r24, Y+10	; 0x0a
    2f94:	9b 85       	ldd	r25, Y+11	; 0x0b
    2f96:	0c 96       	adiw	r24, 0x0c	; 12
    2f98:	28 17       	cp	r18, r24
    2f9a:	39 07       	cpc	r19, r25
    2f9c:	41 f4       	brne	.+16     	; 0x2fae <xTaskResumeAll+0xb0>
    2f9e:	ea 85       	ldd	r30, Y+10	; 0x0a
    2fa0:	fb 85       	ldd	r31, Y+11	; 0x0b
    2fa2:	80 89       	ldd	r24, Z+16	; 0x10
    2fa4:	91 89       	ldd	r25, Z+17	; 0x11
    2fa6:	ef 81       	ldd	r30, Y+7	; 0x07
    2fa8:	f8 85       	ldd	r31, Y+8	; 0x08
    2faa:	92 83       	std	Z+2, r25	; 0x02
    2fac:	81 83       	std	Z+1, r24	; 0x01
    2fae:	ea 85       	ldd	r30, Y+10	; 0x0a
    2fb0:	fb 85       	ldd	r31, Y+11	; 0x0b
    2fb2:	15 8a       	std	Z+21, r1	; 0x15
    2fb4:	14 8a       	std	Z+20, r1	; 0x14
    2fb6:	ef 81       	ldd	r30, Y+7	; 0x07
    2fb8:	f8 85       	ldd	r31, Y+8	; 0x08
    2fba:	80 81       	ld	r24, Z
    2fbc:	81 50       	subi	r24, 0x01	; 1
    2fbe:	ef 81       	ldd	r30, Y+7	; 0x07
    2fc0:	f8 85       	ldd	r31, Y+8	; 0x08
    2fc2:	80 83       	st	Z, r24
                    portMEMORY_BARRIER();
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    2fc4:	ea 85       	ldd	r30, Y+10	; 0x0a
    2fc6:	fb 85       	ldd	r31, Y+11	; 0x0b
    2fc8:	82 85       	ldd	r24, Z+10	; 0x0a
    2fca:	93 85       	ldd	r25, Z+11	; 0x0b
    2fcc:	9e 83       	std	Y+6, r25	; 0x06
    2fce:	8d 83       	std	Y+5, r24	; 0x05
    2fd0:	ea 85       	ldd	r30, Y+10	; 0x0a
    2fd2:	fb 85       	ldd	r31, Y+11	; 0x0b
    2fd4:	a4 81       	ldd	r26, Z+4	; 0x04
    2fd6:	b5 81       	ldd	r27, Z+5	; 0x05
    2fd8:	ea 85       	ldd	r30, Y+10	; 0x0a
    2fda:	fb 85       	ldd	r31, Y+11	; 0x0b
    2fdc:	86 81       	ldd	r24, Z+6	; 0x06
    2fde:	97 81       	ldd	r25, Z+7	; 0x07
    2fe0:	15 96       	adiw	r26, 0x05	; 5
    2fe2:	9c 93       	st	X, r25
    2fe4:	8e 93       	st	-X, r24
    2fe6:	14 97       	sbiw	r26, 0x04	; 4
    2fe8:	ea 85       	ldd	r30, Y+10	; 0x0a
    2fea:	fb 85       	ldd	r31, Y+11	; 0x0b
    2fec:	a6 81       	ldd	r26, Z+6	; 0x06
    2fee:	b7 81       	ldd	r27, Z+7	; 0x07
    2ff0:	ea 85       	ldd	r30, Y+10	; 0x0a
    2ff2:	fb 85       	ldd	r31, Y+11	; 0x0b
    2ff4:	84 81       	ldd	r24, Z+4	; 0x04
    2ff6:	95 81       	ldd	r25, Z+5	; 0x05
    2ff8:	13 96       	adiw	r26, 0x03	; 3
    2ffa:	9c 93       	st	X, r25
    2ffc:	8e 93       	st	-X, r24
    2ffe:	12 97       	sbiw	r26, 0x02	; 2
    3000:	ed 81       	ldd	r30, Y+5	; 0x05
    3002:	fe 81       	ldd	r31, Y+6	; 0x06
    3004:	21 81       	ldd	r18, Z+1	; 0x01
    3006:	32 81       	ldd	r19, Z+2	; 0x02
    3008:	8a 85       	ldd	r24, Y+10	; 0x0a
    300a:	9b 85       	ldd	r25, Y+11	; 0x0b
    300c:	02 96       	adiw	r24, 0x02	; 2
    300e:	28 17       	cp	r18, r24
    3010:	39 07       	cpc	r19, r25
    3012:	41 f4       	brne	.+16     	; 0x3024 <xTaskResumeAll+0x126>
    3014:	ea 85       	ldd	r30, Y+10	; 0x0a
    3016:	fb 85       	ldd	r31, Y+11	; 0x0b
    3018:	86 81       	ldd	r24, Z+6	; 0x06
    301a:	97 81       	ldd	r25, Z+7	; 0x07
    301c:	ed 81       	ldd	r30, Y+5	; 0x05
    301e:	fe 81       	ldd	r31, Y+6	; 0x06
    3020:	92 83       	std	Z+2, r25	; 0x02
    3022:	81 83       	std	Z+1, r24	; 0x01
    3024:	ea 85       	ldd	r30, Y+10	; 0x0a
    3026:	fb 85       	ldd	r31, Y+11	; 0x0b
    3028:	13 86       	std	Z+11, r1	; 0x0b
    302a:	12 86       	std	Z+10, r1	; 0x0a
    302c:	ed 81       	ldd	r30, Y+5	; 0x05
    302e:	fe 81       	ldd	r31, Y+6	; 0x06
    3030:	80 81       	ld	r24, Z
    3032:	81 50       	subi	r24, 0x01	; 1
    3034:	ed 81       	ldd	r30, Y+5	; 0x05
    3036:	fe 81       	ldd	r31, Y+6	; 0x06
    3038:	80 83       	st	Z, r24
                    prvAddTaskToReadyList( pxTCB );
    303a:	ea 85       	ldd	r30, Y+10	; 0x0a
    303c:	fb 85       	ldd	r31, Y+11	; 0x0b
    303e:	96 89       	ldd	r25, Z+22	; 0x16
    3040:	80 91 34 07 	lds	r24, 0x0734
    3044:	89 17       	cp	r24, r25
    3046:	28 f4       	brcc	.+10     	; 0x3052 <xTaskResumeAll+0x154>
    3048:	ea 85       	ldd	r30, Y+10	; 0x0a
    304a:	fb 85       	ldd	r31, Y+11	; 0x0b
    304c:	86 89       	ldd	r24, Z+22	; 0x16
    304e:	80 93 34 07 	sts	0x0734, r24
    3052:	ea 85       	ldd	r30, Y+10	; 0x0a
    3054:	fb 85       	ldd	r31, Y+11	; 0x0b
    3056:	86 89       	ldd	r24, Z+22	; 0x16
    3058:	28 2f       	mov	r18, r24
    305a:	30 e0       	ldi	r19, 0x00	; 0
    305c:	c9 01       	movw	r24, r18
    305e:	88 0f       	add	r24, r24
    3060:	99 1f       	adc	r25, r25
    3062:	88 0f       	add	r24, r24
    3064:	99 1f       	adc	r25, r25
    3066:	88 0f       	add	r24, r24
    3068:	99 1f       	adc	r25, r25
    306a:	82 0f       	add	r24, r18
    306c:	93 1f       	adc	r25, r19
    306e:	fc 01       	movw	r30, r24
    3070:	e0 5c       	subi	r30, 0xC0	; 192
    3072:	f8 4f       	sbci	r31, 0xF8	; 248
    3074:	81 81       	ldd	r24, Z+1	; 0x01
    3076:	92 81       	ldd	r25, Z+2	; 0x02
    3078:	9c 83       	std	Y+4, r25	; 0x04
    307a:	8b 83       	std	Y+3, r24	; 0x03
    307c:	ea 85       	ldd	r30, Y+10	; 0x0a
    307e:	fb 85       	ldd	r31, Y+11	; 0x0b
    3080:	8b 81       	ldd	r24, Y+3	; 0x03
    3082:	9c 81       	ldd	r25, Y+4	; 0x04
    3084:	95 83       	std	Z+5, r25	; 0x05
    3086:	84 83       	std	Z+4, r24	; 0x04
    3088:	eb 81       	ldd	r30, Y+3	; 0x03
    308a:	fc 81       	ldd	r31, Y+4	; 0x04
    308c:	84 81       	ldd	r24, Z+4	; 0x04
    308e:	95 81       	ldd	r25, Z+5	; 0x05
    3090:	ea 85       	ldd	r30, Y+10	; 0x0a
    3092:	fb 85       	ldd	r31, Y+11	; 0x0b
    3094:	97 83       	std	Z+7, r25	; 0x07
    3096:	86 83       	std	Z+6, r24	; 0x06
    3098:	eb 81       	ldd	r30, Y+3	; 0x03
    309a:	fc 81       	ldd	r31, Y+4	; 0x04
    309c:	04 80       	ldd	r0, Z+4	; 0x04
    309e:	f5 81       	ldd	r31, Z+5	; 0x05
    30a0:	e0 2d       	mov	r30, r0
    30a2:	8a 85       	ldd	r24, Y+10	; 0x0a
    30a4:	9b 85       	ldd	r25, Y+11	; 0x0b
    30a6:	02 96       	adiw	r24, 0x02	; 2
    30a8:	93 83       	std	Z+3, r25	; 0x03
    30aa:	82 83       	std	Z+2, r24	; 0x02
    30ac:	8a 85       	ldd	r24, Y+10	; 0x0a
    30ae:	9b 85       	ldd	r25, Y+11	; 0x0b
    30b0:	02 96       	adiw	r24, 0x02	; 2
    30b2:	eb 81       	ldd	r30, Y+3	; 0x03
    30b4:	fc 81       	ldd	r31, Y+4	; 0x04
    30b6:	95 83       	std	Z+5, r25	; 0x05
    30b8:	84 83       	std	Z+4, r24	; 0x04
    30ba:	ea 85       	ldd	r30, Y+10	; 0x0a
    30bc:	fb 85       	ldd	r31, Y+11	; 0x0b
    30be:	86 89       	ldd	r24, Z+22	; 0x16
    30c0:	28 2f       	mov	r18, r24
    30c2:	30 e0       	ldi	r19, 0x00	; 0
    30c4:	c9 01       	movw	r24, r18
    30c6:	88 0f       	add	r24, r24
    30c8:	99 1f       	adc	r25, r25
    30ca:	88 0f       	add	r24, r24
    30cc:	99 1f       	adc	r25, r25
    30ce:	88 0f       	add	r24, r24
    30d0:	99 1f       	adc	r25, r25
    30d2:	82 0f       	add	r24, r18
    30d4:	93 1f       	adc	r25, r19
    30d6:	80 5c       	subi	r24, 0xC0	; 192
    30d8:	98 4f       	sbci	r25, 0xF8	; 248
    30da:	ea 85       	ldd	r30, Y+10	; 0x0a
    30dc:	fb 85       	ldd	r31, Y+11	; 0x0b
    30de:	93 87       	std	Z+11, r25	; 0x0b
    30e0:	82 87       	std	Z+10, r24	; 0x0a
    30e2:	ea 85       	ldd	r30, Y+10	; 0x0a
    30e4:	fb 85       	ldd	r31, Y+11	; 0x0b
    30e6:	86 89       	ldd	r24, Z+22	; 0x16
    30e8:	28 2f       	mov	r18, r24
    30ea:	30 e0       	ldi	r19, 0x00	; 0
    30ec:	c9 01       	movw	r24, r18
    30ee:	88 0f       	add	r24, r24
    30f0:	99 1f       	adc	r25, r25
    30f2:	88 0f       	add	r24, r24
    30f4:	99 1f       	adc	r25, r25
    30f6:	88 0f       	add	r24, r24
    30f8:	99 1f       	adc	r25, r25
    30fa:	82 0f       	add	r24, r18
    30fc:	93 1f       	adc	r25, r19
    30fe:	fc 01       	movw	r30, r24
    3100:	e0 5c       	subi	r30, 0xC0	; 192
    3102:	f8 4f       	sbci	r31, 0xF8	; 248
    3104:	80 81       	ld	r24, Z
    3106:	8f 5f       	subi	r24, 0xFF	; 255
    3108:	80 83       	st	Z, r24

                    /* If the moved task has a priority higher than or equal to
                     * the current task then a yield must be performed. */
                    if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    310a:	ea 85       	ldd	r30, Y+10	; 0x0a
    310c:	fb 85       	ldd	r31, Y+11	; 0x0b
    310e:	96 89       	ldd	r25, Z+22	; 0x16
    3110:	e0 91 2e 07 	lds	r30, 0x072E
    3114:	f0 91 2f 07 	lds	r31, 0x072F
    3118:	86 89       	ldd	r24, Z+22	; 0x16
    311a:	98 17       	cp	r25, r24
    311c:	18 f0       	brcs	.+6      	; 0x3124 <xTaskResumeAll+0x226>
                    {
                        xYieldPending = pdTRUE;
    311e:	81 e0       	ldi	r24, 0x01	; 1
    3120:	80 93 38 07 	sts	0x0738, r24
        {
            if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
            {
                /* Move any readied tasks from the pending list into the
                 * appropriate ready list. */
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    3124:	80 91 7a 07 	lds	r24, 0x077A
    3128:	88 23       	and	r24, r24
    312a:	09 f0       	breq	.+2      	; 0x312e <xTaskResumeAll+0x230>
    312c:	08 cf       	rjmp	.-496    	; 0x2f3e <xTaskResumeAll+0x40>
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }

                if( pxTCB != NULL )
    312e:	8a 85       	ldd	r24, Y+10	; 0x0a
    3130:	9b 85       	ldd	r25, Y+11	; 0x0b
    3132:	00 97       	sbiw	r24, 0x00	; 0
    3134:	11 f0       	breq	.+4      	; 0x313a <xTaskResumeAll+0x23c>
                     * which may have prevented the next unblock time from being
                     * re-calculated, in which case re-calculate it now.  Mainly
                     * important for low power tickless implementations, where
                     * this can prevent an unnecessary exit from low power
                     * state. */
                    prvResetNextTaskUnblockTime();
    3136:	0e 94 63 1f 	call	0x3ec6	; 0x3ec6 <prvResetNextTaskUnblockTime>
                /* If any ticks occurred while the scheduler was suspended then
                 * they should be processed now.  This ensures the tick count does
                 * not  slip, and that any delayed tasks are resumed at the correct
                 * time. */
                {
                    TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
    313a:	80 91 36 07 	lds	r24, 0x0736
    313e:	90 91 37 07 	lds	r25, 0x0737
    3142:	9a 83       	std	Y+2, r25	; 0x02
    3144:	89 83       	std	Y+1, r24	; 0x01

                    if( xPendedCounts > ( TickType_t ) 0U )
    3146:	89 81       	ldd	r24, Y+1	; 0x01
    3148:	9a 81       	ldd	r25, Y+2	; 0x02
    314a:	00 97       	sbiw	r24, 0x00	; 0
    314c:	a1 f0       	breq	.+40     	; 0x3176 <xTaskResumeAll+0x278>
                    {
                        do
                        {
                            if( xTaskIncrementTick() != pdFALSE )
    314e:	0e 94 4c 19 	call	0x3298	; 0x3298 <xTaskIncrementTick>
    3152:	88 23       	and	r24, r24
    3154:	19 f0       	breq	.+6      	; 0x315c <xTaskResumeAll+0x25e>
                            {
                                xYieldPending = pdTRUE;
    3156:	81 e0       	ldi	r24, 0x01	; 1
    3158:	80 93 38 07 	sts	0x0738, r24
                            else
                            {
                                mtCOVERAGE_TEST_MARKER();
                            }

                            --xPendedCounts;
    315c:	89 81       	ldd	r24, Y+1	; 0x01
    315e:	9a 81       	ldd	r25, Y+2	; 0x02
    3160:	01 97       	sbiw	r24, 0x01	; 1
    3162:	9a 83       	std	Y+2, r25	; 0x02
    3164:	89 83       	std	Y+1, r24	; 0x01
                        } while( xPendedCounts > ( TickType_t ) 0U );
    3166:	89 81       	ldd	r24, Y+1	; 0x01
    3168:	9a 81       	ldd	r25, Y+2	; 0x02
    316a:	00 97       	sbiw	r24, 0x00	; 0
    316c:	81 f7       	brne	.-32     	; 0x314e <xTaskResumeAll+0x250>

                        xPendedTicks = 0;
    316e:	10 92 37 07 	sts	0x0737, r1
    3172:	10 92 36 07 	sts	0x0736, r1
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }

                if( xYieldPending != pdFALSE )
    3176:	80 91 38 07 	lds	r24, 0x0738
    317a:	88 23       	and	r24, r24
    317c:	21 f0       	breq	.+8      	; 0x3186 <xTaskResumeAll+0x288>
                {
                    #if ( configUSE_PREEMPTION != 0 )
                        {
                            xAlreadyYielded = pdTRUE;
    317e:	81 e0       	ldi	r24, 0x01	; 1
    3180:	89 87       	std	Y+9, r24	; 0x09
                        }
                    #endif
                    taskYIELD_IF_USING_PREEMPTION();
    3182:	0e 94 a6 02 	call	0x54c	; 0x54c <vPortYield>
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    taskEXIT_CRITICAL();
    3186:	0f 90       	pop	r0
    3188:	0f be       	out	0x3f, r0	; 63

    return xAlreadyYielded;
    318a:	89 85       	ldd	r24, Y+9	; 0x09
}
    318c:	2b 96       	adiw	r28, 0x0b	; 11
    318e:	0f b6       	in	r0, 0x3f	; 63
    3190:	f8 94       	cli
    3192:	de bf       	out	0x3e, r29	; 62
    3194:	0f be       	out	0x3f, r0	; 63
    3196:	cd bf       	out	0x3d, r28	; 61
    3198:	cf 91       	pop	r28
    319a:	df 91       	pop	r29
    319c:	08 95       	ret

0000319e <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
    319e:	df 93       	push	r29
    31a0:	cf 93       	push	r28
    31a2:	00 d0       	rcall	.+0      	; 0x31a4 <xTaskGetTickCount+0x6>
    31a4:	cd b7       	in	r28, 0x3d	; 61
    31a6:	de b7       	in	r29, 0x3e	; 62
    TickType_t xTicks;

    /* Critical section required if running on a 16 bit processor. */
    portTICK_TYPE_ENTER_CRITICAL();
    31a8:	0f b6       	in	r0, 0x3f	; 63
    31aa:	f8 94       	cli
    31ac:	0f 92       	push	r0
    {
        xTicks = xTickCount;
    31ae:	80 91 32 07 	lds	r24, 0x0732
    31b2:	90 91 33 07 	lds	r25, 0x0733
    31b6:	9a 83       	std	Y+2, r25	; 0x02
    31b8:	89 83       	std	Y+1, r24	; 0x01
    }
    portTICK_TYPE_EXIT_CRITICAL();
    31ba:	0f 90       	pop	r0
    31bc:	0f be       	out	0x3f, r0	; 63

    return xTicks;
    31be:	89 81       	ldd	r24, Y+1	; 0x01
    31c0:	9a 81       	ldd	r25, Y+2	; 0x02
}
    31c2:	0f 90       	pop	r0
    31c4:	0f 90       	pop	r0
    31c6:	cf 91       	pop	r28
    31c8:	df 91       	pop	r29
    31ca:	08 95       	ret

000031cc <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
    31cc:	df 93       	push	r29
    31ce:	cf 93       	push	r28
    31d0:	00 d0       	rcall	.+0      	; 0x31d2 <xTaskGetTickCountFromISR+0x6>
    31d2:	0f 92       	push	r0
    31d4:	cd b7       	in	r28, 0x3d	; 61
    31d6:	de b7       	in	r29, 0x3e	; 62
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
    31d8:	19 82       	std	Y+1, r1	; 0x01
    {
        xReturn = xTickCount;
    31da:	80 91 32 07 	lds	r24, 0x0732
    31de:	90 91 33 07 	lds	r25, 0x0733
    31e2:	9b 83       	std	Y+3, r25	; 0x03
    31e4:	8a 83       	std	Y+2, r24	; 0x02
    }
    portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    31e6:	8a 81       	ldd	r24, Y+2	; 0x02
    31e8:	9b 81       	ldd	r25, Y+3	; 0x03
}
    31ea:	0f 90       	pop	r0
    31ec:	0f 90       	pop	r0
    31ee:	0f 90       	pop	r0
    31f0:	cf 91       	pop	r28
    31f2:	df 91       	pop	r29
    31f4:	08 95       	ret

000031f6 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

UBaseType_t uxTaskGetNumberOfTasks( void )
{
    31f6:	df 93       	push	r29
    31f8:	cf 93       	push	r28
    31fa:	cd b7       	in	r28, 0x3d	; 61
    31fc:	de b7       	in	r29, 0x3e	; 62
    /* A critical section is not required because the variables are of type
     * BaseType_t. */
    return uxCurrentNumberOfTasks;
    31fe:	80 91 31 07 	lds	r24, 0x0731
}
    3202:	cf 91       	pop	r28
    3204:	df 91       	pop	r29
    3206:	08 95       	ret

00003208 <pcTaskGetName>:
/*-----------------------------------------------------------*/

char * pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    3208:	df 93       	push	r29
    320a:	cf 93       	push	r28
    320c:	00 d0       	rcall	.+0      	; 0x320e <pcTaskGetName+0x6>
    320e:	00 d0       	rcall	.+0      	; 0x3210 <pcTaskGetName+0x8>
    3210:	00 d0       	rcall	.+0      	; 0x3212 <pcTaskGetName+0xa>
    3212:	cd b7       	in	r28, 0x3d	; 61
    3214:	de b7       	in	r29, 0x3e	; 62
    3216:	9c 83       	std	Y+4, r25	; 0x04
    3218:	8b 83       	std	Y+3, r24	; 0x03
    TCB_t * pxTCB;

    /* If null is passed in here then the name of the calling task is being
     * queried. */
    pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    321a:	8b 81       	ldd	r24, Y+3	; 0x03
    321c:	9c 81       	ldd	r25, Y+4	; 0x04
    321e:	00 97       	sbiw	r24, 0x00	; 0
    3220:	39 f4       	brne	.+14     	; 0x3230 <pcTaskGetName+0x28>
    3222:	80 91 2e 07 	lds	r24, 0x072E
    3226:	90 91 2f 07 	lds	r25, 0x072F
    322a:	9e 83       	std	Y+6, r25	; 0x06
    322c:	8d 83       	std	Y+5, r24	; 0x05
    322e:	04 c0       	rjmp	.+8      	; 0x3238 <pcTaskGetName+0x30>
    3230:	8b 81       	ldd	r24, Y+3	; 0x03
    3232:	9c 81       	ldd	r25, Y+4	; 0x04
    3234:	9e 83       	std	Y+6, r25	; 0x06
    3236:	8d 83       	std	Y+5, r24	; 0x05
    3238:	8d 81       	ldd	r24, Y+5	; 0x05
    323a:	9e 81       	ldd	r25, Y+6	; 0x06
    323c:	9a 83       	std	Y+2, r25	; 0x02
    323e:	89 83       	std	Y+1, r24	; 0x01
    configASSERT( pxTCB );
    return &( pxTCB->pcTaskName[ 0 ] );
    3240:	89 81       	ldd	r24, Y+1	; 0x01
    3242:	9a 81       	ldd	r25, Y+2	; 0x02
    3244:	49 96       	adiw	r24, 0x19	; 25
}
    3246:	26 96       	adiw	r28, 0x06	; 6
    3248:	0f b6       	in	r0, 0x3f	; 63
    324a:	f8 94       	cli
    324c:	de bf       	out	0x3e, r29	; 62
    324e:	0f be       	out	0x3f, r0	; 63
    3250:	cd bf       	out	0x3d, r28	; 61
    3252:	cf 91       	pop	r28
    3254:	df 91       	pop	r29
    3256:	08 95       	ret

00003258 <xTaskCatchUpTicks>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskCatchUpTicks( TickType_t xTicksToCatchUp )
{
    3258:	df 93       	push	r29
    325a:	cf 93       	push	r28
    325c:	00 d0       	rcall	.+0      	; 0x325e <xTaskCatchUpTicks+0x6>
    325e:	0f 92       	push	r0
    3260:	cd b7       	in	r28, 0x3d	; 61
    3262:	de b7       	in	r29, 0x3e	; 62
    3264:	9b 83       	std	Y+3, r25	; 0x03
    3266:	8a 83       	std	Y+2, r24	; 0x02
     * relies on xPendedTicks being wound down to 0 in xTaskResumeAll(). */
    configASSERT( uxSchedulerSuspended == 0 );

    /* Use xPendedTicks to mimic xTicksToCatchUp number of ticks occurring when
     * the scheduler is suspended so the ticks are executed in xTaskResumeAll(). */
    vTaskSuspendAll();
    3268:	0e 94 73 17 	call	0x2ee6	; 0x2ee6 <vTaskSuspendAll>
    xPendedTicks += xTicksToCatchUp;
    326c:	20 91 36 07 	lds	r18, 0x0736
    3270:	30 91 37 07 	lds	r19, 0x0737
    3274:	8a 81       	ldd	r24, Y+2	; 0x02
    3276:	9b 81       	ldd	r25, Y+3	; 0x03
    3278:	82 0f       	add	r24, r18
    327a:	93 1f       	adc	r25, r19
    327c:	90 93 37 07 	sts	0x0737, r25
    3280:	80 93 36 07 	sts	0x0736, r24
    xYieldOccurred = xTaskResumeAll();
    3284:	0e 94 7f 17 	call	0x2efe	; 0x2efe <xTaskResumeAll>
    3288:	89 83       	std	Y+1, r24	; 0x01

    return xYieldOccurred;
    328a:	89 81       	ldd	r24, Y+1	; 0x01
}
    328c:	0f 90       	pop	r0
    328e:	0f 90       	pop	r0
    3290:	0f 90       	pop	r0
    3292:	cf 91       	pop	r28
    3294:	df 91       	pop	r29
    3296:	08 95       	ret

00003298 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    3298:	df 93       	push	r29
    329a:	cf 93       	push	r28
    329c:	cd b7       	in	r28, 0x3d	; 61
    329e:	de b7       	in	r29, 0x3e	; 62
    32a0:	2f 97       	sbiw	r28, 0x0f	; 15
    32a2:	0f b6       	in	r0, 0x3f	; 63
    32a4:	f8 94       	cli
    32a6:	de bf       	out	0x3e, r29	; 62
    32a8:	0f be       	out	0x3f, r0	; 63
    32aa:	cd bf       	out	0x3d, r28	; 61
    TCB_t * pxTCB;
    TickType_t xItemValue;
    BaseType_t xSwitchRequired = pdFALSE;
    32ac:	1b 86       	std	Y+11, r1	; 0x0b
    /* Called by the portable layer each time a tick interrupt occurs.
     * Increments the tick then checks to see if the new tick value will cause any
     * tasks to be unblocked. */
    traceTASK_INCREMENT_TICK( xTickCount );

    if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    32ae:	80 91 3f 07 	lds	r24, 0x073F
    32b2:	88 23       	and	r24, r24
    32b4:	09 f0       	breq	.+2      	; 0x32b8 <xTaskIncrementTick+0x20>
    32b6:	74 c1       	rjmp	.+744    	; 0x35a0 <xTaskIncrementTick+0x308>
    {
        /* Minor optimisation.  The tick count cannot change in this
         * block. */
        const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
    32b8:	80 91 32 07 	lds	r24, 0x0732
    32bc:	90 91 33 07 	lds	r25, 0x0733
    32c0:	01 96       	adiw	r24, 0x01	; 1
    32c2:	9a 87       	std	Y+10, r25	; 0x0a
    32c4:	89 87       	std	Y+9, r24	; 0x09

        /* Increment the RTOS tick, switching the delayed and overflowed
         * delayed lists if it wraps to 0. */
        xTickCount = xConstTickCount;
    32c6:	89 85       	ldd	r24, Y+9	; 0x09
    32c8:	9a 85       	ldd	r25, Y+10	; 0x0a
    32ca:	90 93 33 07 	sts	0x0733, r25
    32ce:	80 93 32 07 	sts	0x0732, r24

        if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
    32d2:	89 85       	ldd	r24, Y+9	; 0x09
    32d4:	9a 85       	ldd	r25, Y+10	; 0x0a
    32d6:	00 97       	sbiw	r24, 0x00	; 0
    32d8:	d9 f4       	brne	.+54     	; 0x3310 <xTaskIncrementTick+0x78>
        {
            taskSWITCH_DELAYED_LISTS();
    32da:	80 91 76 07 	lds	r24, 0x0776
    32de:	90 91 77 07 	lds	r25, 0x0777
    32e2:	98 87       	std	Y+8, r25	; 0x08
    32e4:	8f 83       	std	Y+7, r24	; 0x07
    32e6:	80 91 78 07 	lds	r24, 0x0778
    32ea:	90 91 79 07 	lds	r25, 0x0779
    32ee:	90 93 77 07 	sts	0x0777, r25
    32f2:	80 93 76 07 	sts	0x0776, r24
    32f6:	8f 81       	ldd	r24, Y+7	; 0x07
    32f8:	98 85       	ldd	r25, Y+8	; 0x08
    32fa:	90 93 79 07 	sts	0x0779, r25
    32fe:	80 93 78 07 	sts	0x0778, r24
    3302:	80 91 39 07 	lds	r24, 0x0739
    3306:	8f 5f       	subi	r24, 0xFF	; 255
    3308:	80 93 39 07 	sts	0x0739, r24
    330c:	0e 94 63 1f 	call	0x3ec6	; 0x3ec6 <prvResetNextTaskUnblockTime>

        /* See if this tick has made a timeout expire.  Tasks are stored in
         * the  queue in the order of their wake time - meaning once one task
         * has been found whose block time has not expired there is no need to
         * look any further down the list. */
        if( xConstTickCount >= xNextTaskUnblockTime )
    3310:	20 91 3b 07 	lds	r18, 0x073B
    3314:	30 91 3c 07 	lds	r19, 0x073C
    3318:	89 85       	ldd	r24, Y+9	; 0x09
    331a:	9a 85       	ldd	r25, Y+10	; 0x0a
    331c:	82 17       	cp	r24, r18
    331e:	93 07       	cpc	r25, r19
    3320:	08 f4       	brcc	.+2      	; 0x3324 <xTaskIncrementTick+0x8c>
    3322:	1f c1       	rjmp	.+574    	; 0x3562 <xTaskIncrementTick+0x2ca>
        {
            for( ; ; )
            {
                if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    3324:	e0 91 76 07 	lds	r30, 0x0776
    3328:	f0 91 77 07 	lds	r31, 0x0777
    332c:	80 81       	ld	r24, Z
    332e:	88 23       	and	r24, r24
    3330:	39 f4       	brne	.+14     	; 0x3340 <xTaskIncrementTick+0xa8>
                    /* The delayed list is empty.  Set xNextTaskUnblockTime
                     * to the maximum possible value so it is extremely
                     * unlikely that the
                     * if( xTickCount >= xNextTaskUnblockTime ) test will pass
                     * next time through. */
                    xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    3332:	8f ef       	ldi	r24, 0xFF	; 255
    3334:	9f ef       	ldi	r25, 0xFF	; 255
    3336:	90 93 3c 07 	sts	0x073C, r25
    333a:	80 93 3b 07 	sts	0x073B, r24
    333e:	11 c1       	rjmp	.+546    	; 0x3562 <xTaskIncrementTick+0x2ca>
                {
                    /* The delayed list is not empty, get the value of the
                     * item at the head of the delayed list.  This is the time
                     * at which the task at the head of the delayed list must
                     * be removed from the Blocked state. */
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    3340:	e0 91 76 07 	lds	r30, 0x0776
    3344:	f0 91 77 07 	lds	r31, 0x0777
    3348:	05 80       	ldd	r0, Z+5	; 0x05
    334a:	f6 81       	ldd	r31, Z+6	; 0x06
    334c:	e0 2d       	mov	r30, r0
    334e:	86 81       	ldd	r24, Z+6	; 0x06
    3350:	97 81       	ldd	r25, Z+7	; 0x07
    3352:	9f 87       	std	Y+15, r25	; 0x0f
    3354:	8e 87       	std	Y+14, r24	; 0x0e
                    xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
    3356:	ee 85       	ldd	r30, Y+14	; 0x0e
    3358:	ff 85       	ldd	r31, Y+15	; 0x0f
    335a:	82 81       	ldd	r24, Z+2	; 0x02
    335c:	93 81       	ldd	r25, Z+3	; 0x03
    335e:	9d 87       	std	Y+13, r25	; 0x0d
    3360:	8c 87       	std	Y+12, r24	; 0x0c

                    if( xConstTickCount < xItemValue )
    3362:	29 85       	ldd	r18, Y+9	; 0x09
    3364:	3a 85       	ldd	r19, Y+10	; 0x0a
    3366:	8c 85       	ldd	r24, Y+12	; 0x0c
    3368:	9d 85       	ldd	r25, Y+13	; 0x0d
    336a:	28 17       	cp	r18, r24
    336c:	39 07       	cpc	r19, r25
    336e:	38 f4       	brcc	.+14     	; 0x337e <xTaskIncrementTick+0xe6>
                        /* It is not time to unblock this item yet, but the
                         * item value is the time at which the task at the head
                         * of the blocked list must be removed from the Blocked
                         * state -  so record the item value in
                         * xNextTaskUnblockTime. */
                        xNextTaskUnblockTime = xItemValue;
    3370:	8c 85       	ldd	r24, Y+12	; 0x0c
    3372:	9d 85       	ldd	r25, Y+13	; 0x0d
    3374:	90 93 3c 07 	sts	0x073C, r25
    3378:	80 93 3b 07 	sts	0x073B, r24
    337c:	f2 c0       	rjmp	.+484    	; 0x3562 <xTaskIncrementTick+0x2ca>
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* It is time to remove the item from the Blocked state. */
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    337e:	ee 85       	ldd	r30, Y+14	; 0x0e
    3380:	ff 85       	ldd	r31, Y+15	; 0x0f
    3382:	82 85       	ldd	r24, Z+10	; 0x0a
    3384:	93 85       	ldd	r25, Z+11	; 0x0b
    3386:	9e 83       	std	Y+6, r25	; 0x06
    3388:	8d 83       	std	Y+5, r24	; 0x05
    338a:	ee 85       	ldd	r30, Y+14	; 0x0e
    338c:	ff 85       	ldd	r31, Y+15	; 0x0f
    338e:	a4 81       	ldd	r26, Z+4	; 0x04
    3390:	b5 81       	ldd	r27, Z+5	; 0x05
    3392:	ee 85       	ldd	r30, Y+14	; 0x0e
    3394:	ff 85       	ldd	r31, Y+15	; 0x0f
    3396:	86 81       	ldd	r24, Z+6	; 0x06
    3398:	97 81       	ldd	r25, Z+7	; 0x07
    339a:	15 96       	adiw	r26, 0x05	; 5
    339c:	9c 93       	st	X, r25
    339e:	8e 93       	st	-X, r24
    33a0:	14 97       	sbiw	r26, 0x04	; 4
    33a2:	ee 85       	ldd	r30, Y+14	; 0x0e
    33a4:	ff 85       	ldd	r31, Y+15	; 0x0f
    33a6:	a6 81       	ldd	r26, Z+6	; 0x06
    33a8:	b7 81       	ldd	r27, Z+7	; 0x07
    33aa:	ee 85       	ldd	r30, Y+14	; 0x0e
    33ac:	ff 85       	ldd	r31, Y+15	; 0x0f
    33ae:	84 81       	ldd	r24, Z+4	; 0x04
    33b0:	95 81       	ldd	r25, Z+5	; 0x05
    33b2:	13 96       	adiw	r26, 0x03	; 3
    33b4:	9c 93       	st	X, r25
    33b6:	8e 93       	st	-X, r24
    33b8:	12 97       	sbiw	r26, 0x02	; 2
    33ba:	ed 81       	ldd	r30, Y+5	; 0x05
    33bc:	fe 81       	ldd	r31, Y+6	; 0x06
    33be:	21 81       	ldd	r18, Z+1	; 0x01
    33c0:	32 81       	ldd	r19, Z+2	; 0x02
    33c2:	8e 85       	ldd	r24, Y+14	; 0x0e
    33c4:	9f 85       	ldd	r25, Y+15	; 0x0f
    33c6:	02 96       	adiw	r24, 0x02	; 2
    33c8:	28 17       	cp	r18, r24
    33ca:	39 07       	cpc	r19, r25
    33cc:	41 f4       	brne	.+16     	; 0x33de <xTaskIncrementTick+0x146>
    33ce:	ee 85       	ldd	r30, Y+14	; 0x0e
    33d0:	ff 85       	ldd	r31, Y+15	; 0x0f
    33d2:	86 81       	ldd	r24, Z+6	; 0x06
    33d4:	97 81       	ldd	r25, Z+7	; 0x07
    33d6:	ed 81       	ldd	r30, Y+5	; 0x05
    33d8:	fe 81       	ldd	r31, Y+6	; 0x06
    33da:	92 83       	std	Z+2, r25	; 0x02
    33dc:	81 83       	std	Z+1, r24	; 0x01
    33de:	ee 85       	ldd	r30, Y+14	; 0x0e
    33e0:	ff 85       	ldd	r31, Y+15	; 0x0f
    33e2:	13 86       	std	Z+11, r1	; 0x0b
    33e4:	12 86       	std	Z+10, r1	; 0x0a
    33e6:	ed 81       	ldd	r30, Y+5	; 0x05
    33e8:	fe 81       	ldd	r31, Y+6	; 0x06
    33ea:	80 81       	ld	r24, Z
    33ec:	81 50       	subi	r24, 0x01	; 1
    33ee:	ed 81       	ldd	r30, Y+5	; 0x05
    33f0:	fe 81       	ldd	r31, Y+6	; 0x06
    33f2:	80 83       	st	Z, r24

                    /* Is the task waiting on an event also?  If so remove
                     * it from the event list. */
                    if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    33f4:	ee 85       	ldd	r30, Y+14	; 0x0e
    33f6:	ff 85       	ldd	r31, Y+15	; 0x0f
    33f8:	84 89       	ldd	r24, Z+20	; 0x14
    33fa:	95 89       	ldd	r25, Z+21	; 0x15
    33fc:	00 97       	sbiw	r24, 0x00	; 0
    33fe:	d9 f1       	breq	.+118    	; 0x3476 <xTaskIncrementTick+0x1de>
                    {
                        listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
    3400:	ee 85       	ldd	r30, Y+14	; 0x0e
    3402:	ff 85       	ldd	r31, Y+15	; 0x0f
    3404:	84 89       	ldd	r24, Z+20	; 0x14
    3406:	95 89       	ldd	r25, Z+21	; 0x15
    3408:	9c 83       	std	Y+4, r25	; 0x04
    340a:	8b 83       	std	Y+3, r24	; 0x03
    340c:	ee 85       	ldd	r30, Y+14	; 0x0e
    340e:	ff 85       	ldd	r31, Y+15	; 0x0f
    3410:	a6 85       	ldd	r26, Z+14	; 0x0e
    3412:	b7 85       	ldd	r27, Z+15	; 0x0f
    3414:	ee 85       	ldd	r30, Y+14	; 0x0e
    3416:	ff 85       	ldd	r31, Y+15	; 0x0f
    3418:	80 89       	ldd	r24, Z+16	; 0x10
    341a:	91 89       	ldd	r25, Z+17	; 0x11
    341c:	15 96       	adiw	r26, 0x05	; 5
    341e:	9c 93       	st	X, r25
    3420:	8e 93       	st	-X, r24
    3422:	14 97       	sbiw	r26, 0x04	; 4
    3424:	ee 85       	ldd	r30, Y+14	; 0x0e
    3426:	ff 85       	ldd	r31, Y+15	; 0x0f
    3428:	a0 89       	ldd	r26, Z+16	; 0x10
    342a:	b1 89       	ldd	r27, Z+17	; 0x11
    342c:	ee 85       	ldd	r30, Y+14	; 0x0e
    342e:	ff 85       	ldd	r31, Y+15	; 0x0f
    3430:	86 85       	ldd	r24, Z+14	; 0x0e
    3432:	97 85       	ldd	r25, Z+15	; 0x0f
    3434:	13 96       	adiw	r26, 0x03	; 3
    3436:	9c 93       	st	X, r25
    3438:	8e 93       	st	-X, r24
    343a:	12 97       	sbiw	r26, 0x02	; 2
    343c:	eb 81       	ldd	r30, Y+3	; 0x03
    343e:	fc 81       	ldd	r31, Y+4	; 0x04
    3440:	21 81       	ldd	r18, Z+1	; 0x01
    3442:	32 81       	ldd	r19, Z+2	; 0x02
    3444:	8e 85       	ldd	r24, Y+14	; 0x0e
    3446:	9f 85       	ldd	r25, Y+15	; 0x0f
    3448:	0c 96       	adiw	r24, 0x0c	; 12
    344a:	28 17       	cp	r18, r24
    344c:	39 07       	cpc	r19, r25
    344e:	41 f4       	brne	.+16     	; 0x3460 <xTaskIncrementTick+0x1c8>
    3450:	ee 85       	ldd	r30, Y+14	; 0x0e
    3452:	ff 85       	ldd	r31, Y+15	; 0x0f
    3454:	80 89       	ldd	r24, Z+16	; 0x10
    3456:	91 89       	ldd	r25, Z+17	; 0x11
    3458:	eb 81       	ldd	r30, Y+3	; 0x03
    345a:	fc 81       	ldd	r31, Y+4	; 0x04
    345c:	92 83       	std	Z+2, r25	; 0x02
    345e:	81 83       	std	Z+1, r24	; 0x01
    3460:	ee 85       	ldd	r30, Y+14	; 0x0e
    3462:	ff 85       	ldd	r31, Y+15	; 0x0f
    3464:	15 8a       	std	Z+21, r1	; 0x15
    3466:	14 8a       	std	Z+20, r1	; 0x14
    3468:	eb 81       	ldd	r30, Y+3	; 0x03
    346a:	fc 81       	ldd	r31, Y+4	; 0x04
    346c:	80 81       	ld	r24, Z
    346e:	81 50       	subi	r24, 0x01	; 1
    3470:	eb 81       	ldd	r30, Y+3	; 0x03
    3472:	fc 81       	ldd	r31, Y+4	; 0x04
    3474:	80 83       	st	Z, r24
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* Place the unblocked task into the appropriate ready
                     * list. */
                    prvAddTaskToReadyList( pxTCB );
    3476:	ee 85       	ldd	r30, Y+14	; 0x0e
    3478:	ff 85       	ldd	r31, Y+15	; 0x0f
    347a:	96 89       	ldd	r25, Z+22	; 0x16
    347c:	80 91 34 07 	lds	r24, 0x0734
    3480:	89 17       	cp	r24, r25
    3482:	28 f4       	brcc	.+10     	; 0x348e <xTaskIncrementTick+0x1f6>
    3484:	ee 85       	ldd	r30, Y+14	; 0x0e
    3486:	ff 85       	ldd	r31, Y+15	; 0x0f
    3488:	86 89       	ldd	r24, Z+22	; 0x16
    348a:	80 93 34 07 	sts	0x0734, r24
    348e:	ee 85       	ldd	r30, Y+14	; 0x0e
    3490:	ff 85       	ldd	r31, Y+15	; 0x0f
    3492:	86 89       	ldd	r24, Z+22	; 0x16
    3494:	28 2f       	mov	r18, r24
    3496:	30 e0       	ldi	r19, 0x00	; 0
    3498:	c9 01       	movw	r24, r18
    349a:	88 0f       	add	r24, r24
    349c:	99 1f       	adc	r25, r25
    349e:	88 0f       	add	r24, r24
    34a0:	99 1f       	adc	r25, r25
    34a2:	88 0f       	add	r24, r24
    34a4:	99 1f       	adc	r25, r25
    34a6:	82 0f       	add	r24, r18
    34a8:	93 1f       	adc	r25, r19
    34aa:	fc 01       	movw	r30, r24
    34ac:	e0 5c       	subi	r30, 0xC0	; 192
    34ae:	f8 4f       	sbci	r31, 0xF8	; 248
    34b0:	81 81       	ldd	r24, Z+1	; 0x01
    34b2:	92 81       	ldd	r25, Z+2	; 0x02
    34b4:	9a 83       	std	Y+2, r25	; 0x02
    34b6:	89 83       	std	Y+1, r24	; 0x01
    34b8:	ee 85       	ldd	r30, Y+14	; 0x0e
    34ba:	ff 85       	ldd	r31, Y+15	; 0x0f
    34bc:	89 81       	ldd	r24, Y+1	; 0x01
    34be:	9a 81       	ldd	r25, Y+2	; 0x02
    34c0:	95 83       	std	Z+5, r25	; 0x05
    34c2:	84 83       	std	Z+4, r24	; 0x04
    34c4:	e9 81       	ldd	r30, Y+1	; 0x01
    34c6:	fa 81       	ldd	r31, Y+2	; 0x02
    34c8:	84 81       	ldd	r24, Z+4	; 0x04
    34ca:	95 81       	ldd	r25, Z+5	; 0x05
    34cc:	ee 85       	ldd	r30, Y+14	; 0x0e
    34ce:	ff 85       	ldd	r31, Y+15	; 0x0f
    34d0:	97 83       	std	Z+7, r25	; 0x07
    34d2:	86 83       	std	Z+6, r24	; 0x06
    34d4:	e9 81       	ldd	r30, Y+1	; 0x01
    34d6:	fa 81       	ldd	r31, Y+2	; 0x02
    34d8:	04 80       	ldd	r0, Z+4	; 0x04
    34da:	f5 81       	ldd	r31, Z+5	; 0x05
    34dc:	e0 2d       	mov	r30, r0
    34de:	8e 85       	ldd	r24, Y+14	; 0x0e
    34e0:	9f 85       	ldd	r25, Y+15	; 0x0f
    34e2:	02 96       	adiw	r24, 0x02	; 2
    34e4:	93 83       	std	Z+3, r25	; 0x03
    34e6:	82 83       	std	Z+2, r24	; 0x02
    34e8:	8e 85       	ldd	r24, Y+14	; 0x0e
    34ea:	9f 85       	ldd	r25, Y+15	; 0x0f
    34ec:	02 96       	adiw	r24, 0x02	; 2
    34ee:	e9 81       	ldd	r30, Y+1	; 0x01
    34f0:	fa 81       	ldd	r31, Y+2	; 0x02
    34f2:	95 83       	std	Z+5, r25	; 0x05
    34f4:	84 83       	std	Z+4, r24	; 0x04
    34f6:	ee 85       	ldd	r30, Y+14	; 0x0e
    34f8:	ff 85       	ldd	r31, Y+15	; 0x0f
    34fa:	86 89       	ldd	r24, Z+22	; 0x16
    34fc:	28 2f       	mov	r18, r24
    34fe:	30 e0       	ldi	r19, 0x00	; 0
    3500:	c9 01       	movw	r24, r18
    3502:	88 0f       	add	r24, r24
    3504:	99 1f       	adc	r25, r25
    3506:	88 0f       	add	r24, r24
    3508:	99 1f       	adc	r25, r25
    350a:	88 0f       	add	r24, r24
    350c:	99 1f       	adc	r25, r25
    350e:	82 0f       	add	r24, r18
    3510:	93 1f       	adc	r25, r19
    3512:	80 5c       	subi	r24, 0xC0	; 192
    3514:	98 4f       	sbci	r25, 0xF8	; 248
    3516:	ee 85       	ldd	r30, Y+14	; 0x0e
    3518:	ff 85       	ldd	r31, Y+15	; 0x0f
    351a:	93 87       	std	Z+11, r25	; 0x0b
    351c:	82 87       	std	Z+10, r24	; 0x0a
    351e:	ee 85       	ldd	r30, Y+14	; 0x0e
    3520:	ff 85       	ldd	r31, Y+15	; 0x0f
    3522:	86 89       	ldd	r24, Z+22	; 0x16
    3524:	28 2f       	mov	r18, r24
    3526:	30 e0       	ldi	r19, 0x00	; 0
    3528:	c9 01       	movw	r24, r18
    352a:	88 0f       	add	r24, r24
    352c:	99 1f       	adc	r25, r25
    352e:	88 0f       	add	r24, r24
    3530:	99 1f       	adc	r25, r25
    3532:	88 0f       	add	r24, r24
    3534:	99 1f       	adc	r25, r25
    3536:	82 0f       	add	r24, r18
    3538:	93 1f       	adc	r25, r19
    353a:	fc 01       	movw	r30, r24
    353c:	e0 5c       	subi	r30, 0xC0	; 192
    353e:	f8 4f       	sbci	r31, 0xF8	; 248
    3540:	80 81       	ld	r24, Z
    3542:	8f 5f       	subi	r24, 0xFF	; 255
    3544:	80 83       	st	Z, r24
                        {
                            /* Preemption is on, but a context switch should
                             * only be performed if the unblocked task has a
                             * priority that is equal to or higher than the
                             * currently executing task. */
                            if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    3546:	ee 85       	ldd	r30, Y+14	; 0x0e
    3548:	ff 85       	ldd	r31, Y+15	; 0x0f
    354a:	96 89       	ldd	r25, Z+22	; 0x16
    354c:	e0 91 2e 07 	lds	r30, 0x072E
    3550:	f0 91 2f 07 	lds	r31, 0x072F
    3554:	86 89       	ldd	r24, Z+22	; 0x16
    3556:	98 17       	cp	r25, r24
    3558:	08 f4       	brcc	.+2      	; 0x355c <xTaskIncrementTick+0x2c4>
    355a:	e4 ce       	rjmp	.-568    	; 0x3324 <xTaskIncrementTick+0x8c>
                            {
                                xSwitchRequired = pdTRUE;
    355c:	81 e0       	ldi	r24, 0x01	; 1
    355e:	8b 87       	std	Y+11, r24	; 0x0b
    3560:	e1 ce       	rjmp	.-574    	; 0x3324 <xTaskIncrementTick+0x8c>
        /* Tasks of equal priority to the currently running task will share
         * processing time (time slice) if preemption is on, and the application
         * writer has not explicitly turned time slicing off. */
        #if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
            {
                if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    3562:	e0 91 2e 07 	lds	r30, 0x072E
    3566:	f0 91 2f 07 	lds	r31, 0x072F
    356a:	86 89       	ldd	r24, Z+22	; 0x16
    356c:	28 2f       	mov	r18, r24
    356e:	30 e0       	ldi	r19, 0x00	; 0
    3570:	c9 01       	movw	r24, r18
    3572:	88 0f       	add	r24, r24
    3574:	99 1f       	adc	r25, r25
    3576:	88 0f       	add	r24, r24
    3578:	99 1f       	adc	r25, r25
    357a:	88 0f       	add	r24, r24
    357c:	99 1f       	adc	r25, r25
    357e:	82 0f       	add	r24, r18
    3580:	93 1f       	adc	r25, r19
    3582:	fc 01       	movw	r30, r24
    3584:	e0 5c       	subi	r30, 0xC0	; 192
    3586:	f8 4f       	sbci	r31, 0xF8	; 248
    3588:	80 81       	ld	r24, Z
    358a:	82 30       	cpi	r24, 0x02	; 2
    358c:	10 f0       	brcs	.+4      	; 0x3592 <xTaskIncrementTick+0x2fa>
                {
                    xSwitchRequired = pdTRUE;
    358e:	81 e0       	ldi	r24, 0x01	; 1
    3590:	8b 87       	std	Y+11, r24	; 0x0b
            }
        #endif /* configUSE_TICK_HOOK */

        #if ( configUSE_PREEMPTION == 1 )
            {
                if( xYieldPending != pdFALSE )
    3592:	80 91 38 07 	lds	r24, 0x0738
    3596:	88 23       	and	r24, r24
    3598:	61 f0       	breq	.+24     	; 0x35b2 <xTaskIncrementTick+0x31a>
                {
                    xSwitchRequired = pdTRUE;
    359a:	81 e0       	ldi	r24, 0x01	; 1
    359c:	8b 87       	std	Y+11, r24	; 0x0b
    359e:	09 c0       	rjmp	.+18     	; 0x35b2 <xTaskIncrementTick+0x31a>
            }
        #endif /* configUSE_PREEMPTION */
    }
    else
    {
        ++xPendedTicks;
    35a0:	80 91 36 07 	lds	r24, 0x0736
    35a4:	90 91 37 07 	lds	r25, 0x0737
    35a8:	01 96       	adiw	r24, 0x01	; 1
    35aa:	90 93 37 07 	sts	0x0737, r25
    35ae:	80 93 36 07 	sts	0x0736, r24
                vApplicationTickHook();
            }
        #endif
    }

    return xSwitchRequired;
    35b2:	8b 85       	ldd	r24, Y+11	; 0x0b
}
    35b4:	2f 96       	adiw	r28, 0x0f	; 15
    35b6:	0f b6       	in	r0, 0x3f	; 63
    35b8:	f8 94       	cli
    35ba:	de bf       	out	0x3e, r29	; 62
    35bc:	0f be       	out	0x3f, r0	; 63
    35be:	cd bf       	out	0x3d, r28	; 61
    35c0:	cf 91       	pop	r28
    35c2:	df 91       	pop	r29
    35c4:	08 95       	ret

000035c6 <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    35c6:	df 93       	push	r29
    35c8:	cf 93       	push	r28
    35ca:	00 d0       	rcall	.+0      	; 0x35cc <vTaskSwitchContext+0x6>
    35cc:	0f 92       	push	r0
    35ce:	cd b7       	in	r28, 0x3d	; 61
    35d0:	de b7       	in	r29, 0x3e	; 62
    if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    35d2:	80 91 3f 07 	lds	r24, 0x073F
    35d6:	88 23       	and	r24, r24
    35d8:	21 f0       	breq	.+8      	; 0x35e2 <vTaskSwitchContext+0x1c>
    {
        /* The scheduler is currently suspended - do not allow a context
         * switch. */
        xYieldPending = pdTRUE;
    35da:	81 e0       	ldi	r24, 0x01	; 1
    35dc:	80 93 38 07 	sts	0x0738, r24
    35e0:	59 c0       	rjmp	.+178    	; 0x3694 <vTaskSwitchContext+0xce>
    }
    else
    {
        xYieldPending = pdFALSE;
    35e2:	10 92 38 07 	sts	0x0738, r1
            }
        #endif

        /* Select a new task to run using either the generic C or port
         * optimised asm code. */
        taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    35e6:	80 91 34 07 	lds	r24, 0x0734
    35ea:	8b 83       	std	Y+3, r24	; 0x03
    35ec:	03 c0       	rjmp	.+6      	; 0x35f4 <vTaskSwitchContext+0x2e>
    35ee:	8b 81       	ldd	r24, Y+3	; 0x03
    35f0:	81 50       	subi	r24, 0x01	; 1
    35f2:	8b 83       	std	Y+3, r24	; 0x03
    35f4:	8b 81       	ldd	r24, Y+3	; 0x03
    35f6:	28 2f       	mov	r18, r24
    35f8:	30 e0       	ldi	r19, 0x00	; 0
    35fa:	c9 01       	movw	r24, r18
    35fc:	88 0f       	add	r24, r24
    35fe:	99 1f       	adc	r25, r25
    3600:	88 0f       	add	r24, r24
    3602:	99 1f       	adc	r25, r25
    3604:	88 0f       	add	r24, r24
    3606:	99 1f       	adc	r25, r25
    3608:	82 0f       	add	r24, r18
    360a:	93 1f       	adc	r25, r19
    360c:	fc 01       	movw	r30, r24
    360e:	e0 5c       	subi	r30, 0xC0	; 192
    3610:	f8 4f       	sbci	r31, 0xF8	; 248
    3612:	80 81       	ld	r24, Z
    3614:	88 23       	and	r24, r24
    3616:	59 f3       	breq	.-42     	; 0x35ee <vTaskSwitchContext+0x28>
    3618:	8b 81       	ldd	r24, Y+3	; 0x03
    361a:	28 2f       	mov	r18, r24
    361c:	30 e0       	ldi	r19, 0x00	; 0
    361e:	c9 01       	movw	r24, r18
    3620:	88 0f       	add	r24, r24
    3622:	99 1f       	adc	r25, r25
    3624:	88 0f       	add	r24, r24
    3626:	99 1f       	adc	r25, r25
    3628:	88 0f       	add	r24, r24
    362a:	99 1f       	adc	r25, r25
    362c:	82 0f       	add	r24, r18
    362e:	93 1f       	adc	r25, r19
    3630:	80 5c       	subi	r24, 0xC0	; 192
    3632:	98 4f       	sbci	r25, 0xF8	; 248
    3634:	9a 83       	std	Y+2, r25	; 0x02
    3636:	89 83       	std	Y+1, r24	; 0x01
    3638:	e9 81       	ldd	r30, Y+1	; 0x01
    363a:	fa 81       	ldd	r31, Y+2	; 0x02
    363c:	01 80       	ldd	r0, Z+1	; 0x01
    363e:	f2 81       	ldd	r31, Z+2	; 0x02
    3640:	e0 2d       	mov	r30, r0
    3642:	82 81       	ldd	r24, Z+2	; 0x02
    3644:	93 81       	ldd	r25, Z+3	; 0x03
    3646:	e9 81       	ldd	r30, Y+1	; 0x01
    3648:	fa 81       	ldd	r31, Y+2	; 0x02
    364a:	92 83       	std	Z+2, r25	; 0x02
    364c:	81 83       	std	Z+1, r24	; 0x01
    364e:	e9 81       	ldd	r30, Y+1	; 0x01
    3650:	fa 81       	ldd	r31, Y+2	; 0x02
    3652:	21 81       	ldd	r18, Z+1	; 0x01
    3654:	32 81       	ldd	r19, Z+2	; 0x02
    3656:	89 81       	ldd	r24, Y+1	; 0x01
    3658:	9a 81       	ldd	r25, Y+2	; 0x02
    365a:	03 96       	adiw	r24, 0x03	; 3
    365c:	28 17       	cp	r18, r24
    365e:	39 07       	cpc	r19, r25
    3660:	59 f4       	brne	.+22     	; 0x3678 <vTaskSwitchContext+0xb2>
    3662:	e9 81       	ldd	r30, Y+1	; 0x01
    3664:	fa 81       	ldd	r31, Y+2	; 0x02
    3666:	01 80       	ldd	r0, Z+1	; 0x01
    3668:	f2 81       	ldd	r31, Z+2	; 0x02
    366a:	e0 2d       	mov	r30, r0
    366c:	82 81       	ldd	r24, Z+2	; 0x02
    366e:	93 81       	ldd	r25, Z+3	; 0x03
    3670:	e9 81       	ldd	r30, Y+1	; 0x01
    3672:	fa 81       	ldd	r31, Y+2	; 0x02
    3674:	92 83       	std	Z+2, r25	; 0x02
    3676:	81 83       	std	Z+1, r24	; 0x01
    3678:	e9 81       	ldd	r30, Y+1	; 0x01
    367a:	fa 81       	ldd	r31, Y+2	; 0x02
    367c:	01 80       	ldd	r0, Z+1	; 0x01
    367e:	f2 81       	ldd	r31, Z+2	; 0x02
    3680:	e0 2d       	mov	r30, r0
    3682:	86 81       	ldd	r24, Z+6	; 0x06
    3684:	97 81       	ldd	r25, Z+7	; 0x07
    3686:	90 93 2f 07 	sts	0x072F, r25
    368a:	80 93 2e 07 	sts	0x072E, r24
    368e:	8b 81       	ldd	r24, Y+3	; 0x03
    3690:	80 93 34 07 	sts	0x0734, r24
                 * for additional information. */
                _impure_ptr = &( pxCurrentTCB->xNewLib_reent );
            }
        #endif /* configUSE_NEWLIB_REENTRANT */
    }
}
    3694:	0f 90       	pop	r0
    3696:	0f 90       	pop	r0
    3698:	0f 90       	pop	r0
    369a:	cf 91       	pop	r28
    369c:	df 91       	pop	r29
    369e:	08 95       	ret

000036a0 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList,
                            const TickType_t xTicksToWait )
{
    36a0:	df 93       	push	r29
    36a2:	cf 93       	push	r28
    36a4:	00 d0       	rcall	.+0      	; 0x36a6 <vTaskPlaceOnEventList+0x6>
    36a6:	00 d0       	rcall	.+0      	; 0x36a8 <vTaskPlaceOnEventList+0x8>
    36a8:	cd b7       	in	r28, 0x3d	; 61
    36aa:	de b7       	in	r29, 0x3e	; 62
    36ac:	9a 83       	std	Y+2, r25	; 0x02
    36ae:	89 83       	std	Y+1, r24	; 0x01
    36b0:	7c 83       	std	Y+4, r23	; 0x04
    36b2:	6b 83       	std	Y+3, r22	; 0x03
     *      xItemValue = ( configMAX_PRIORITIES - uxPriority )
     * Therefore, the event list is sorted in descending priority order.
     *
     * The queue that contains the event list is locked, preventing
     * simultaneous access from interrupts. */
    vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    36b4:	80 91 2e 07 	lds	r24, 0x072E
    36b8:	90 91 2f 07 	lds	r25, 0x072F
    36bc:	9c 01       	movw	r18, r24
    36be:	24 5f       	subi	r18, 0xF4	; 244
    36c0:	3f 4f       	sbci	r19, 0xFF	; 255
    36c2:	89 81       	ldd	r24, Y+1	; 0x01
    36c4:	9a 81       	ldd	r25, Y+2	; 0x02
    36c6:	b9 01       	movw	r22, r18
    36c8:	0e 94 5d 0a 	call	0x14ba	; 0x14ba <vListInsert>

    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    36cc:	8b 81       	ldd	r24, Y+3	; 0x03
    36ce:	9c 81       	ldd	r25, Y+4	; 0x04
    36d0:	61 e0       	ldi	r22, 0x01	; 1
    36d2:	0e 94 31 27 	call	0x4e62	; 0x4e62 <prvAddCurrentTaskToDelayedList>
}
    36d6:	0f 90       	pop	r0
    36d8:	0f 90       	pop	r0
    36da:	0f 90       	pop	r0
    36dc:	0f 90       	pop	r0
    36de:	cf 91       	pop	r28
    36e0:	df 91       	pop	r29
    36e2:	08 95       	ret

000036e4 <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList,
                                     const TickType_t xItemValue,
                                     const TickType_t xTicksToWait )
{
    36e4:	df 93       	push	r29
    36e6:	cf 93       	push	r28
    36e8:	cd b7       	in	r28, 0x3d	; 61
    36ea:	de b7       	in	r29, 0x3e	; 62
    36ec:	28 97       	sbiw	r28, 0x08	; 8
    36ee:	0f b6       	in	r0, 0x3f	; 63
    36f0:	f8 94       	cli
    36f2:	de bf       	out	0x3e, r29	; 62
    36f4:	0f be       	out	0x3f, r0	; 63
    36f6:	cd bf       	out	0x3d, r28	; 61
    36f8:	9c 83       	std	Y+4, r25	; 0x04
    36fa:	8b 83       	std	Y+3, r24	; 0x03
    36fc:	7e 83       	std	Y+6, r23	; 0x06
    36fe:	6d 83       	std	Y+5, r22	; 0x05
    3700:	58 87       	std	Y+8, r21	; 0x08
    3702:	4f 83       	std	Y+7, r20	; 0x07
    configASSERT( uxSchedulerSuspended != 0 );

    /* Store the item value in the event list item.  It is safe to access the
     * event list item here as interrupts won't access the event list item of a
     * task that is not in the Blocked state. */
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    3704:	e0 91 2e 07 	lds	r30, 0x072E
    3708:	f0 91 2f 07 	lds	r31, 0x072F
    370c:	8d 81       	ldd	r24, Y+5	; 0x05
    370e:	9e 81       	ldd	r25, Y+6	; 0x06
    3710:	90 68       	ori	r25, 0x80	; 128
    3712:	95 87       	std	Z+13, r25	; 0x0d
    3714:	84 87       	std	Z+12, r24	; 0x0c
    /* Place the event list item of the TCB at the end of the appropriate event
     * list.  It is safe to access the event list here because it is part of an
     * event group implementation - and interrupts don't access event groups
     * directly (instead they access them indirectly by pending function calls to
     * the task level). */
    listINSERT_END( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    3716:	eb 81       	ldd	r30, Y+3	; 0x03
    3718:	fc 81       	ldd	r31, Y+4	; 0x04
    371a:	81 81       	ldd	r24, Z+1	; 0x01
    371c:	92 81       	ldd	r25, Z+2	; 0x02
    371e:	9a 83       	std	Y+2, r25	; 0x02
    3720:	89 83       	std	Y+1, r24	; 0x01
    3722:	e0 91 2e 07 	lds	r30, 0x072E
    3726:	f0 91 2f 07 	lds	r31, 0x072F
    372a:	89 81       	ldd	r24, Y+1	; 0x01
    372c:	9a 81       	ldd	r25, Y+2	; 0x02
    372e:	97 87       	std	Z+15, r25	; 0x0f
    3730:	86 87       	std	Z+14, r24	; 0x0e
    3732:	a0 91 2e 07 	lds	r26, 0x072E
    3736:	b0 91 2f 07 	lds	r27, 0x072F
    373a:	e9 81       	ldd	r30, Y+1	; 0x01
    373c:	fa 81       	ldd	r31, Y+2	; 0x02
    373e:	84 81       	ldd	r24, Z+4	; 0x04
    3740:	95 81       	ldd	r25, Z+5	; 0x05
    3742:	51 96       	adiw	r26, 0x11	; 17
    3744:	9c 93       	st	X, r25
    3746:	8e 93       	st	-X, r24
    3748:	50 97       	sbiw	r26, 0x10	; 16
    374a:	e9 81       	ldd	r30, Y+1	; 0x01
    374c:	fa 81       	ldd	r31, Y+2	; 0x02
    374e:	04 80       	ldd	r0, Z+4	; 0x04
    3750:	f5 81       	ldd	r31, Z+5	; 0x05
    3752:	e0 2d       	mov	r30, r0
    3754:	80 91 2e 07 	lds	r24, 0x072E
    3758:	90 91 2f 07 	lds	r25, 0x072F
    375c:	0c 96       	adiw	r24, 0x0c	; 12
    375e:	93 83       	std	Z+3, r25	; 0x03
    3760:	82 83       	std	Z+2, r24	; 0x02
    3762:	80 91 2e 07 	lds	r24, 0x072E
    3766:	90 91 2f 07 	lds	r25, 0x072F
    376a:	0c 96       	adiw	r24, 0x0c	; 12
    376c:	e9 81       	ldd	r30, Y+1	; 0x01
    376e:	fa 81       	ldd	r31, Y+2	; 0x02
    3770:	95 83       	std	Z+5, r25	; 0x05
    3772:	84 83       	std	Z+4, r24	; 0x04
    3774:	e0 91 2e 07 	lds	r30, 0x072E
    3778:	f0 91 2f 07 	lds	r31, 0x072F
    377c:	8b 81       	ldd	r24, Y+3	; 0x03
    377e:	9c 81       	ldd	r25, Y+4	; 0x04
    3780:	95 8b       	std	Z+21, r25	; 0x15
    3782:	84 8b       	std	Z+20, r24	; 0x14
    3784:	eb 81       	ldd	r30, Y+3	; 0x03
    3786:	fc 81       	ldd	r31, Y+4	; 0x04
    3788:	80 81       	ld	r24, Z
    378a:	8f 5f       	subi	r24, 0xFF	; 255
    378c:	eb 81       	ldd	r30, Y+3	; 0x03
    378e:	fc 81       	ldd	r31, Y+4	; 0x04
    3790:	80 83       	st	Z, r24

    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    3792:	8f 81       	ldd	r24, Y+7	; 0x07
    3794:	98 85       	ldd	r25, Y+8	; 0x08
    3796:	61 e0       	ldi	r22, 0x01	; 1
    3798:	0e 94 31 27 	call	0x4e62	; 0x4e62 <prvAddCurrentTaskToDelayedList>
}
    379c:	28 96       	adiw	r28, 0x08	; 8
    379e:	0f b6       	in	r0, 0x3f	; 63
    37a0:	f8 94       	cli
    37a2:	de bf       	out	0x3e, r29	; 62
    37a4:	0f be       	out	0x3f, r0	; 63
    37a6:	cd bf       	out	0x3d, r28	; 61
    37a8:	cf 91       	pop	r28
    37aa:	df 91       	pop	r29
    37ac:	08 95       	ret

000037ae <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    37ae:	df 93       	push	r29
    37b0:	cf 93       	push	r28
    37b2:	cd b7       	in	r28, 0x3d	; 61
    37b4:	de b7       	in	r29, 0x3e	; 62
    37b6:	2d 97       	sbiw	r28, 0x0d	; 13
    37b8:	0f b6       	in	r0, 0x3f	; 63
    37ba:	f8 94       	cli
    37bc:	de bf       	out	0x3e, r29	; 62
    37be:	0f be       	out	0x3f, r0	; 63
    37c0:	cd bf       	out	0x3d, r28	; 61
    37c2:	9d 87       	std	Y+13, r25	; 0x0d
    37c4:	8c 87       	std	Y+12, r24	; 0x0c
     * get called - the lock count on the queue will get modified instead.  This
     * means exclusive access to the event list is guaranteed here.
     *
     * This function assumes that a check has already been made to ensure that
     * pxEventList is not empty. */
    pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    37c6:	ec 85       	ldd	r30, Y+12	; 0x0c
    37c8:	fd 85       	ldd	r31, Y+13	; 0x0d
    37ca:	05 80       	ldd	r0, Z+5	; 0x05
    37cc:	f6 81       	ldd	r31, Z+6	; 0x06
    37ce:	e0 2d       	mov	r30, r0
    37d0:	86 81       	ldd	r24, Z+6	; 0x06
    37d2:	97 81       	ldd	r25, Z+7	; 0x07
    37d4:	9b 87       	std	Y+11, r25	; 0x0b
    37d6:	8a 87       	std	Y+10, r24	; 0x0a
    configASSERT( pxUnblockedTCB );
    listREMOVE_ITEM( &( pxUnblockedTCB->xEventListItem ) );
    37d8:	ea 85       	ldd	r30, Y+10	; 0x0a
    37da:	fb 85       	ldd	r31, Y+11	; 0x0b
    37dc:	84 89       	ldd	r24, Z+20	; 0x14
    37de:	95 89       	ldd	r25, Z+21	; 0x15
    37e0:	98 87       	std	Y+8, r25	; 0x08
    37e2:	8f 83       	std	Y+7, r24	; 0x07
    37e4:	ea 85       	ldd	r30, Y+10	; 0x0a
    37e6:	fb 85       	ldd	r31, Y+11	; 0x0b
    37e8:	a6 85       	ldd	r26, Z+14	; 0x0e
    37ea:	b7 85       	ldd	r27, Z+15	; 0x0f
    37ec:	ea 85       	ldd	r30, Y+10	; 0x0a
    37ee:	fb 85       	ldd	r31, Y+11	; 0x0b
    37f0:	80 89       	ldd	r24, Z+16	; 0x10
    37f2:	91 89       	ldd	r25, Z+17	; 0x11
    37f4:	15 96       	adiw	r26, 0x05	; 5
    37f6:	9c 93       	st	X, r25
    37f8:	8e 93       	st	-X, r24
    37fa:	14 97       	sbiw	r26, 0x04	; 4
    37fc:	ea 85       	ldd	r30, Y+10	; 0x0a
    37fe:	fb 85       	ldd	r31, Y+11	; 0x0b
    3800:	a0 89       	ldd	r26, Z+16	; 0x10
    3802:	b1 89       	ldd	r27, Z+17	; 0x11
    3804:	ea 85       	ldd	r30, Y+10	; 0x0a
    3806:	fb 85       	ldd	r31, Y+11	; 0x0b
    3808:	86 85       	ldd	r24, Z+14	; 0x0e
    380a:	97 85       	ldd	r25, Z+15	; 0x0f
    380c:	13 96       	adiw	r26, 0x03	; 3
    380e:	9c 93       	st	X, r25
    3810:	8e 93       	st	-X, r24
    3812:	12 97       	sbiw	r26, 0x02	; 2
    3814:	ef 81       	ldd	r30, Y+7	; 0x07
    3816:	f8 85       	ldd	r31, Y+8	; 0x08
    3818:	21 81       	ldd	r18, Z+1	; 0x01
    381a:	32 81       	ldd	r19, Z+2	; 0x02
    381c:	8a 85       	ldd	r24, Y+10	; 0x0a
    381e:	9b 85       	ldd	r25, Y+11	; 0x0b
    3820:	0c 96       	adiw	r24, 0x0c	; 12
    3822:	28 17       	cp	r18, r24
    3824:	39 07       	cpc	r19, r25
    3826:	41 f4       	brne	.+16     	; 0x3838 <xTaskRemoveFromEventList+0x8a>
    3828:	ea 85       	ldd	r30, Y+10	; 0x0a
    382a:	fb 85       	ldd	r31, Y+11	; 0x0b
    382c:	80 89       	ldd	r24, Z+16	; 0x10
    382e:	91 89       	ldd	r25, Z+17	; 0x11
    3830:	ef 81       	ldd	r30, Y+7	; 0x07
    3832:	f8 85       	ldd	r31, Y+8	; 0x08
    3834:	92 83       	std	Z+2, r25	; 0x02
    3836:	81 83       	std	Z+1, r24	; 0x01
    3838:	ea 85       	ldd	r30, Y+10	; 0x0a
    383a:	fb 85       	ldd	r31, Y+11	; 0x0b
    383c:	15 8a       	std	Z+21, r1	; 0x15
    383e:	14 8a       	std	Z+20, r1	; 0x14
    3840:	ef 81       	ldd	r30, Y+7	; 0x07
    3842:	f8 85       	ldd	r31, Y+8	; 0x08
    3844:	80 81       	ld	r24, Z
    3846:	81 50       	subi	r24, 0x01	; 1
    3848:	ef 81       	ldd	r30, Y+7	; 0x07
    384a:	f8 85       	ldd	r31, Y+8	; 0x08
    384c:	80 83       	st	Z, r24

    if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    384e:	80 91 3f 07 	lds	r24, 0x073F
    3852:	88 23       	and	r24, r24
    3854:	09 f0       	breq	.+2      	; 0x3858 <xTaskRemoveFromEventList+0xaa>
    3856:	a4 c0       	rjmp	.+328    	; 0x39a0 <xTaskRemoveFromEventList+0x1f2>
    {
        listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
    3858:	ea 85       	ldd	r30, Y+10	; 0x0a
    385a:	fb 85       	ldd	r31, Y+11	; 0x0b
    385c:	82 85       	ldd	r24, Z+10	; 0x0a
    385e:	93 85       	ldd	r25, Z+11	; 0x0b
    3860:	9e 83       	std	Y+6, r25	; 0x06
    3862:	8d 83       	std	Y+5, r24	; 0x05
    3864:	ea 85       	ldd	r30, Y+10	; 0x0a
    3866:	fb 85       	ldd	r31, Y+11	; 0x0b
    3868:	a4 81       	ldd	r26, Z+4	; 0x04
    386a:	b5 81       	ldd	r27, Z+5	; 0x05
    386c:	ea 85       	ldd	r30, Y+10	; 0x0a
    386e:	fb 85       	ldd	r31, Y+11	; 0x0b
    3870:	86 81       	ldd	r24, Z+6	; 0x06
    3872:	97 81       	ldd	r25, Z+7	; 0x07
    3874:	15 96       	adiw	r26, 0x05	; 5
    3876:	9c 93       	st	X, r25
    3878:	8e 93       	st	-X, r24
    387a:	14 97       	sbiw	r26, 0x04	; 4
    387c:	ea 85       	ldd	r30, Y+10	; 0x0a
    387e:	fb 85       	ldd	r31, Y+11	; 0x0b
    3880:	a6 81       	ldd	r26, Z+6	; 0x06
    3882:	b7 81       	ldd	r27, Z+7	; 0x07
    3884:	ea 85       	ldd	r30, Y+10	; 0x0a
    3886:	fb 85       	ldd	r31, Y+11	; 0x0b
    3888:	84 81       	ldd	r24, Z+4	; 0x04
    388a:	95 81       	ldd	r25, Z+5	; 0x05
    388c:	13 96       	adiw	r26, 0x03	; 3
    388e:	9c 93       	st	X, r25
    3890:	8e 93       	st	-X, r24
    3892:	12 97       	sbiw	r26, 0x02	; 2
    3894:	ed 81       	ldd	r30, Y+5	; 0x05
    3896:	fe 81       	ldd	r31, Y+6	; 0x06
    3898:	21 81       	ldd	r18, Z+1	; 0x01
    389a:	32 81       	ldd	r19, Z+2	; 0x02
    389c:	8a 85       	ldd	r24, Y+10	; 0x0a
    389e:	9b 85       	ldd	r25, Y+11	; 0x0b
    38a0:	02 96       	adiw	r24, 0x02	; 2
    38a2:	28 17       	cp	r18, r24
    38a4:	39 07       	cpc	r19, r25
    38a6:	41 f4       	brne	.+16     	; 0x38b8 <xTaskRemoveFromEventList+0x10a>
    38a8:	ea 85       	ldd	r30, Y+10	; 0x0a
    38aa:	fb 85       	ldd	r31, Y+11	; 0x0b
    38ac:	86 81       	ldd	r24, Z+6	; 0x06
    38ae:	97 81       	ldd	r25, Z+7	; 0x07
    38b0:	ed 81       	ldd	r30, Y+5	; 0x05
    38b2:	fe 81       	ldd	r31, Y+6	; 0x06
    38b4:	92 83       	std	Z+2, r25	; 0x02
    38b6:	81 83       	std	Z+1, r24	; 0x01
    38b8:	ea 85       	ldd	r30, Y+10	; 0x0a
    38ba:	fb 85       	ldd	r31, Y+11	; 0x0b
    38bc:	13 86       	std	Z+11, r1	; 0x0b
    38be:	12 86       	std	Z+10, r1	; 0x0a
    38c0:	ed 81       	ldd	r30, Y+5	; 0x05
    38c2:	fe 81       	ldd	r31, Y+6	; 0x06
    38c4:	80 81       	ld	r24, Z
    38c6:	81 50       	subi	r24, 0x01	; 1
    38c8:	ed 81       	ldd	r30, Y+5	; 0x05
    38ca:	fe 81       	ldd	r31, Y+6	; 0x06
    38cc:	80 83       	st	Z, r24
        prvAddTaskToReadyList( pxUnblockedTCB );
    38ce:	ea 85       	ldd	r30, Y+10	; 0x0a
    38d0:	fb 85       	ldd	r31, Y+11	; 0x0b
    38d2:	96 89       	ldd	r25, Z+22	; 0x16
    38d4:	80 91 34 07 	lds	r24, 0x0734
    38d8:	89 17       	cp	r24, r25
    38da:	28 f4       	brcc	.+10     	; 0x38e6 <xTaskRemoveFromEventList+0x138>
    38dc:	ea 85       	ldd	r30, Y+10	; 0x0a
    38de:	fb 85       	ldd	r31, Y+11	; 0x0b
    38e0:	86 89       	ldd	r24, Z+22	; 0x16
    38e2:	80 93 34 07 	sts	0x0734, r24
    38e6:	ea 85       	ldd	r30, Y+10	; 0x0a
    38e8:	fb 85       	ldd	r31, Y+11	; 0x0b
    38ea:	86 89       	ldd	r24, Z+22	; 0x16
    38ec:	28 2f       	mov	r18, r24
    38ee:	30 e0       	ldi	r19, 0x00	; 0
    38f0:	c9 01       	movw	r24, r18
    38f2:	88 0f       	add	r24, r24
    38f4:	99 1f       	adc	r25, r25
    38f6:	88 0f       	add	r24, r24
    38f8:	99 1f       	adc	r25, r25
    38fa:	88 0f       	add	r24, r24
    38fc:	99 1f       	adc	r25, r25
    38fe:	82 0f       	add	r24, r18
    3900:	93 1f       	adc	r25, r19
    3902:	fc 01       	movw	r30, r24
    3904:	e0 5c       	subi	r30, 0xC0	; 192
    3906:	f8 4f       	sbci	r31, 0xF8	; 248
    3908:	81 81       	ldd	r24, Z+1	; 0x01
    390a:	92 81       	ldd	r25, Z+2	; 0x02
    390c:	9c 83       	std	Y+4, r25	; 0x04
    390e:	8b 83       	std	Y+3, r24	; 0x03
    3910:	ea 85       	ldd	r30, Y+10	; 0x0a
    3912:	fb 85       	ldd	r31, Y+11	; 0x0b
    3914:	8b 81       	ldd	r24, Y+3	; 0x03
    3916:	9c 81       	ldd	r25, Y+4	; 0x04
    3918:	95 83       	std	Z+5, r25	; 0x05
    391a:	84 83       	std	Z+4, r24	; 0x04
    391c:	eb 81       	ldd	r30, Y+3	; 0x03
    391e:	fc 81       	ldd	r31, Y+4	; 0x04
    3920:	84 81       	ldd	r24, Z+4	; 0x04
    3922:	95 81       	ldd	r25, Z+5	; 0x05
    3924:	ea 85       	ldd	r30, Y+10	; 0x0a
    3926:	fb 85       	ldd	r31, Y+11	; 0x0b
    3928:	97 83       	std	Z+7, r25	; 0x07
    392a:	86 83       	std	Z+6, r24	; 0x06
    392c:	eb 81       	ldd	r30, Y+3	; 0x03
    392e:	fc 81       	ldd	r31, Y+4	; 0x04
    3930:	04 80       	ldd	r0, Z+4	; 0x04
    3932:	f5 81       	ldd	r31, Z+5	; 0x05
    3934:	e0 2d       	mov	r30, r0
    3936:	8a 85       	ldd	r24, Y+10	; 0x0a
    3938:	9b 85       	ldd	r25, Y+11	; 0x0b
    393a:	02 96       	adiw	r24, 0x02	; 2
    393c:	93 83       	std	Z+3, r25	; 0x03
    393e:	82 83       	std	Z+2, r24	; 0x02
    3940:	8a 85       	ldd	r24, Y+10	; 0x0a
    3942:	9b 85       	ldd	r25, Y+11	; 0x0b
    3944:	02 96       	adiw	r24, 0x02	; 2
    3946:	eb 81       	ldd	r30, Y+3	; 0x03
    3948:	fc 81       	ldd	r31, Y+4	; 0x04
    394a:	95 83       	std	Z+5, r25	; 0x05
    394c:	84 83       	std	Z+4, r24	; 0x04
    394e:	ea 85       	ldd	r30, Y+10	; 0x0a
    3950:	fb 85       	ldd	r31, Y+11	; 0x0b
    3952:	86 89       	ldd	r24, Z+22	; 0x16
    3954:	28 2f       	mov	r18, r24
    3956:	30 e0       	ldi	r19, 0x00	; 0
    3958:	c9 01       	movw	r24, r18
    395a:	88 0f       	add	r24, r24
    395c:	99 1f       	adc	r25, r25
    395e:	88 0f       	add	r24, r24
    3960:	99 1f       	adc	r25, r25
    3962:	88 0f       	add	r24, r24
    3964:	99 1f       	adc	r25, r25
    3966:	82 0f       	add	r24, r18
    3968:	93 1f       	adc	r25, r19
    396a:	80 5c       	subi	r24, 0xC0	; 192
    396c:	98 4f       	sbci	r25, 0xF8	; 248
    396e:	ea 85       	ldd	r30, Y+10	; 0x0a
    3970:	fb 85       	ldd	r31, Y+11	; 0x0b
    3972:	93 87       	std	Z+11, r25	; 0x0b
    3974:	82 87       	std	Z+10, r24	; 0x0a
    3976:	ea 85       	ldd	r30, Y+10	; 0x0a
    3978:	fb 85       	ldd	r31, Y+11	; 0x0b
    397a:	86 89       	ldd	r24, Z+22	; 0x16
    397c:	28 2f       	mov	r18, r24
    397e:	30 e0       	ldi	r19, 0x00	; 0
    3980:	c9 01       	movw	r24, r18
    3982:	88 0f       	add	r24, r24
    3984:	99 1f       	adc	r25, r25
    3986:	88 0f       	add	r24, r24
    3988:	99 1f       	adc	r25, r25
    398a:	88 0f       	add	r24, r24
    398c:	99 1f       	adc	r25, r25
    398e:	82 0f       	add	r24, r18
    3990:	93 1f       	adc	r25, r19
    3992:	fc 01       	movw	r30, r24
    3994:	e0 5c       	subi	r30, 0xC0	; 192
    3996:	f8 4f       	sbci	r31, 0xF8	; 248
    3998:	80 81       	ld	r24, Z
    399a:	8f 5f       	subi	r24, 0xFF	; 255
    399c:	80 83       	st	Z, r24
    399e:	30 c0       	rjmp	.+96     	; 0x3a00 <xTaskRemoveFromEventList+0x252>
    }
    else
    {
        /* The delayed and ready lists cannot be accessed, so hold this task
         * pending until the scheduler is resumed. */
        listINSERT_END( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    39a0:	80 91 7b 07 	lds	r24, 0x077B
    39a4:	90 91 7c 07 	lds	r25, 0x077C
    39a8:	9a 83       	std	Y+2, r25	; 0x02
    39aa:	89 83       	std	Y+1, r24	; 0x01
    39ac:	ea 85       	ldd	r30, Y+10	; 0x0a
    39ae:	fb 85       	ldd	r31, Y+11	; 0x0b
    39b0:	89 81       	ldd	r24, Y+1	; 0x01
    39b2:	9a 81       	ldd	r25, Y+2	; 0x02
    39b4:	97 87       	std	Z+15, r25	; 0x0f
    39b6:	86 87       	std	Z+14, r24	; 0x0e
    39b8:	e9 81       	ldd	r30, Y+1	; 0x01
    39ba:	fa 81       	ldd	r31, Y+2	; 0x02
    39bc:	84 81       	ldd	r24, Z+4	; 0x04
    39be:	95 81       	ldd	r25, Z+5	; 0x05
    39c0:	ea 85       	ldd	r30, Y+10	; 0x0a
    39c2:	fb 85       	ldd	r31, Y+11	; 0x0b
    39c4:	91 8b       	std	Z+17, r25	; 0x11
    39c6:	80 8b       	std	Z+16, r24	; 0x10
    39c8:	e9 81       	ldd	r30, Y+1	; 0x01
    39ca:	fa 81       	ldd	r31, Y+2	; 0x02
    39cc:	04 80       	ldd	r0, Z+4	; 0x04
    39ce:	f5 81       	ldd	r31, Z+5	; 0x05
    39d0:	e0 2d       	mov	r30, r0
    39d2:	8a 85       	ldd	r24, Y+10	; 0x0a
    39d4:	9b 85       	ldd	r25, Y+11	; 0x0b
    39d6:	0c 96       	adiw	r24, 0x0c	; 12
    39d8:	93 83       	std	Z+3, r25	; 0x03
    39da:	82 83       	std	Z+2, r24	; 0x02
    39dc:	8a 85       	ldd	r24, Y+10	; 0x0a
    39de:	9b 85       	ldd	r25, Y+11	; 0x0b
    39e0:	0c 96       	adiw	r24, 0x0c	; 12
    39e2:	e9 81       	ldd	r30, Y+1	; 0x01
    39e4:	fa 81       	ldd	r31, Y+2	; 0x02
    39e6:	95 83       	std	Z+5, r25	; 0x05
    39e8:	84 83       	std	Z+4, r24	; 0x04
    39ea:	ea 85       	ldd	r30, Y+10	; 0x0a
    39ec:	fb 85       	ldd	r31, Y+11	; 0x0b
    39ee:	8a e7       	ldi	r24, 0x7A	; 122
    39f0:	97 e0       	ldi	r25, 0x07	; 7
    39f2:	95 8b       	std	Z+21, r25	; 0x15
    39f4:	84 8b       	std	Z+20, r24	; 0x14
    39f6:	80 91 7a 07 	lds	r24, 0x077A
    39fa:	8f 5f       	subi	r24, 0xFF	; 255
    39fc:	80 93 7a 07 	sts	0x077A, r24
    }

    if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    3a00:	ea 85       	ldd	r30, Y+10	; 0x0a
    3a02:	fb 85       	ldd	r31, Y+11	; 0x0b
    3a04:	96 89       	ldd	r25, Z+22	; 0x16
    3a06:	e0 91 2e 07 	lds	r30, 0x072E
    3a0a:	f0 91 2f 07 	lds	r31, 0x072F
    3a0e:	86 89       	ldd	r24, Z+22	; 0x16
    3a10:	89 17       	cp	r24, r25
    3a12:	30 f4       	brcc	.+12     	; 0x3a20 <xTaskRemoveFromEventList+0x272>
    {
        /* Return true if the task removed from the event list has a higher
         * priority than the calling task.  This allows the calling task to know if
         * it should force a context switch now. */
        xReturn = pdTRUE;
    3a14:	81 e0       	ldi	r24, 0x01	; 1
    3a16:	89 87       	std	Y+9, r24	; 0x09

        /* Mark that a yield is pending in case the user is not using the
         * "xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
        xYieldPending = pdTRUE;
    3a18:	81 e0       	ldi	r24, 0x01	; 1
    3a1a:	80 93 38 07 	sts	0x0738, r24
    3a1e:	01 c0       	rjmp	.+2      	; 0x3a22 <xTaskRemoveFromEventList+0x274>
    }
    else
    {
        xReturn = pdFALSE;
    3a20:	19 86       	std	Y+9, r1	; 0x09
    }

    return xReturn;
    3a22:	89 85       	ldd	r24, Y+9	; 0x09
}
    3a24:	2d 96       	adiw	r28, 0x0d	; 13
    3a26:	0f b6       	in	r0, 0x3f	; 63
    3a28:	f8 94       	cli
    3a2a:	de bf       	out	0x3e, r29	; 62
    3a2c:	0f be       	out	0x3f, r0	; 63
    3a2e:	cd bf       	out	0x3d, r28	; 61
    3a30:	cf 91       	pop	r28
    3a32:	df 91       	pop	r29
    3a34:	08 95       	ret

00003a36 <vTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem,
                                        const TickType_t xItemValue )
{
    3a36:	df 93       	push	r29
    3a38:	cf 93       	push	r28
    3a3a:	cd b7       	in	r28, 0x3d	; 61
    3a3c:	de b7       	in	r29, 0x3e	; 62
    3a3e:	2c 97       	sbiw	r28, 0x0c	; 12
    3a40:	0f b6       	in	r0, 0x3f	; 63
    3a42:	f8 94       	cli
    3a44:	de bf       	out	0x3e, r29	; 62
    3a46:	0f be       	out	0x3f, r0	; 63
    3a48:	cd bf       	out	0x3d, r28	; 61
    3a4a:	9a 87       	std	Y+10, r25	; 0x0a
    3a4c:	89 87       	std	Y+9, r24	; 0x09
    3a4e:	7c 87       	std	Y+12, r23	; 0x0c
    3a50:	6b 87       	std	Y+11, r22	; 0x0b
    /* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
     * the event flags implementation. */
    configASSERT( uxSchedulerSuspended != pdFALSE );

    /* Store the new item value in the event list. */
    listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    3a52:	8b 85       	ldd	r24, Y+11	; 0x0b
    3a54:	9c 85       	ldd	r25, Y+12	; 0x0c
    3a56:	90 68       	ori	r25, 0x80	; 128
    3a58:	e9 85       	ldd	r30, Y+9	; 0x09
    3a5a:	fa 85       	ldd	r31, Y+10	; 0x0a
    3a5c:	91 83       	std	Z+1, r25	; 0x01
    3a5e:	80 83       	st	Z, r24

    /* Remove the event list form the event flag.  Interrupts do not access
     * event flags. */
    pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    3a60:	e9 85       	ldd	r30, Y+9	; 0x09
    3a62:	fa 85       	ldd	r31, Y+10	; 0x0a
    3a64:	86 81       	ldd	r24, Z+6	; 0x06
    3a66:	97 81       	ldd	r25, Z+7	; 0x07
    3a68:	98 87       	std	Y+8, r25	; 0x08
    3a6a:	8f 83       	std	Y+7, r24	; 0x07
    configASSERT( pxUnblockedTCB );
    listREMOVE_ITEM( pxEventListItem );
    3a6c:	e9 85       	ldd	r30, Y+9	; 0x09
    3a6e:	fa 85       	ldd	r31, Y+10	; 0x0a
    3a70:	80 85       	ldd	r24, Z+8	; 0x08
    3a72:	91 85       	ldd	r25, Z+9	; 0x09
    3a74:	9e 83       	std	Y+6, r25	; 0x06
    3a76:	8d 83       	std	Y+5, r24	; 0x05
    3a78:	e9 85       	ldd	r30, Y+9	; 0x09
    3a7a:	fa 85       	ldd	r31, Y+10	; 0x0a
    3a7c:	a2 81       	ldd	r26, Z+2	; 0x02
    3a7e:	b3 81       	ldd	r27, Z+3	; 0x03
    3a80:	e9 85       	ldd	r30, Y+9	; 0x09
    3a82:	fa 85       	ldd	r31, Y+10	; 0x0a
    3a84:	84 81       	ldd	r24, Z+4	; 0x04
    3a86:	95 81       	ldd	r25, Z+5	; 0x05
    3a88:	15 96       	adiw	r26, 0x05	; 5
    3a8a:	9c 93       	st	X, r25
    3a8c:	8e 93       	st	-X, r24
    3a8e:	14 97       	sbiw	r26, 0x04	; 4
    3a90:	e9 85       	ldd	r30, Y+9	; 0x09
    3a92:	fa 85       	ldd	r31, Y+10	; 0x0a
    3a94:	a4 81       	ldd	r26, Z+4	; 0x04
    3a96:	b5 81       	ldd	r27, Z+5	; 0x05
    3a98:	e9 85       	ldd	r30, Y+9	; 0x09
    3a9a:	fa 85       	ldd	r31, Y+10	; 0x0a
    3a9c:	82 81       	ldd	r24, Z+2	; 0x02
    3a9e:	93 81       	ldd	r25, Z+3	; 0x03
    3aa0:	13 96       	adiw	r26, 0x03	; 3
    3aa2:	9c 93       	st	X, r25
    3aa4:	8e 93       	st	-X, r24
    3aa6:	12 97       	sbiw	r26, 0x02	; 2
    3aa8:	ed 81       	ldd	r30, Y+5	; 0x05
    3aaa:	fe 81       	ldd	r31, Y+6	; 0x06
    3aac:	21 81       	ldd	r18, Z+1	; 0x01
    3aae:	32 81       	ldd	r19, Z+2	; 0x02
    3ab0:	89 85       	ldd	r24, Y+9	; 0x09
    3ab2:	9a 85       	ldd	r25, Y+10	; 0x0a
    3ab4:	28 17       	cp	r18, r24
    3ab6:	39 07       	cpc	r19, r25
    3ab8:	41 f4       	brne	.+16     	; 0x3aca <vTaskRemoveFromUnorderedEventList+0x94>
    3aba:	e9 85       	ldd	r30, Y+9	; 0x09
    3abc:	fa 85       	ldd	r31, Y+10	; 0x0a
    3abe:	84 81       	ldd	r24, Z+4	; 0x04
    3ac0:	95 81       	ldd	r25, Z+5	; 0x05
    3ac2:	ed 81       	ldd	r30, Y+5	; 0x05
    3ac4:	fe 81       	ldd	r31, Y+6	; 0x06
    3ac6:	92 83       	std	Z+2, r25	; 0x02
    3ac8:	81 83       	std	Z+1, r24	; 0x01
    3aca:	e9 85       	ldd	r30, Y+9	; 0x09
    3acc:	fa 85       	ldd	r31, Y+10	; 0x0a
    3ace:	11 86       	std	Z+9, r1	; 0x09
    3ad0:	10 86       	std	Z+8, r1	; 0x08
    3ad2:	ed 81       	ldd	r30, Y+5	; 0x05
    3ad4:	fe 81       	ldd	r31, Y+6	; 0x06
    3ad6:	80 81       	ld	r24, Z
    3ad8:	81 50       	subi	r24, 0x01	; 1
    3ada:	ed 81       	ldd	r30, Y+5	; 0x05
    3adc:	fe 81       	ldd	r31, Y+6	; 0x06
    3ade:	80 83       	st	Z, r24
    #endif

    /* Remove the task from the delayed list and add it to the ready list.  The
     * scheduler is suspended so interrupts will not be accessing the ready
     * lists. */
    listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
    3ae0:	ef 81       	ldd	r30, Y+7	; 0x07
    3ae2:	f8 85       	ldd	r31, Y+8	; 0x08
    3ae4:	82 85       	ldd	r24, Z+10	; 0x0a
    3ae6:	93 85       	ldd	r25, Z+11	; 0x0b
    3ae8:	9c 83       	std	Y+4, r25	; 0x04
    3aea:	8b 83       	std	Y+3, r24	; 0x03
    3aec:	ef 81       	ldd	r30, Y+7	; 0x07
    3aee:	f8 85       	ldd	r31, Y+8	; 0x08
    3af0:	a4 81       	ldd	r26, Z+4	; 0x04
    3af2:	b5 81       	ldd	r27, Z+5	; 0x05
    3af4:	ef 81       	ldd	r30, Y+7	; 0x07
    3af6:	f8 85       	ldd	r31, Y+8	; 0x08
    3af8:	86 81       	ldd	r24, Z+6	; 0x06
    3afa:	97 81       	ldd	r25, Z+7	; 0x07
    3afc:	15 96       	adiw	r26, 0x05	; 5
    3afe:	9c 93       	st	X, r25
    3b00:	8e 93       	st	-X, r24
    3b02:	14 97       	sbiw	r26, 0x04	; 4
    3b04:	ef 81       	ldd	r30, Y+7	; 0x07
    3b06:	f8 85       	ldd	r31, Y+8	; 0x08
    3b08:	a6 81       	ldd	r26, Z+6	; 0x06
    3b0a:	b7 81       	ldd	r27, Z+7	; 0x07
    3b0c:	ef 81       	ldd	r30, Y+7	; 0x07
    3b0e:	f8 85       	ldd	r31, Y+8	; 0x08
    3b10:	84 81       	ldd	r24, Z+4	; 0x04
    3b12:	95 81       	ldd	r25, Z+5	; 0x05
    3b14:	13 96       	adiw	r26, 0x03	; 3
    3b16:	9c 93       	st	X, r25
    3b18:	8e 93       	st	-X, r24
    3b1a:	12 97       	sbiw	r26, 0x02	; 2
    3b1c:	eb 81       	ldd	r30, Y+3	; 0x03
    3b1e:	fc 81       	ldd	r31, Y+4	; 0x04
    3b20:	21 81       	ldd	r18, Z+1	; 0x01
    3b22:	32 81       	ldd	r19, Z+2	; 0x02
    3b24:	8f 81       	ldd	r24, Y+7	; 0x07
    3b26:	98 85       	ldd	r25, Y+8	; 0x08
    3b28:	02 96       	adiw	r24, 0x02	; 2
    3b2a:	28 17       	cp	r18, r24
    3b2c:	39 07       	cpc	r19, r25
    3b2e:	41 f4       	brne	.+16     	; 0x3b40 <vTaskRemoveFromUnorderedEventList+0x10a>
    3b30:	ef 81       	ldd	r30, Y+7	; 0x07
    3b32:	f8 85       	ldd	r31, Y+8	; 0x08
    3b34:	86 81       	ldd	r24, Z+6	; 0x06
    3b36:	97 81       	ldd	r25, Z+7	; 0x07
    3b38:	eb 81       	ldd	r30, Y+3	; 0x03
    3b3a:	fc 81       	ldd	r31, Y+4	; 0x04
    3b3c:	92 83       	std	Z+2, r25	; 0x02
    3b3e:	81 83       	std	Z+1, r24	; 0x01
    3b40:	ef 81       	ldd	r30, Y+7	; 0x07
    3b42:	f8 85       	ldd	r31, Y+8	; 0x08
    3b44:	13 86       	std	Z+11, r1	; 0x0b
    3b46:	12 86       	std	Z+10, r1	; 0x0a
    3b48:	eb 81       	ldd	r30, Y+3	; 0x03
    3b4a:	fc 81       	ldd	r31, Y+4	; 0x04
    3b4c:	80 81       	ld	r24, Z
    3b4e:	81 50       	subi	r24, 0x01	; 1
    3b50:	eb 81       	ldd	r30, Y+3	; 0x03
    3b52:	fc 81       	ldd	r31, Y+4	; 0x04
    3b54:	80 83       	st	Z, r24
    prvAddTaskToReadyList( pxUnblockedTCB );
    3b56:	ef 81       	ldd	r30, Y+7	; 0x07
    3b58:	f8 85       	ldd	r31, Y+8	; 0x08
    3b5a:	96 89       	ldd	r25, Z+22	; 0x16
    3b5c:	80 91 34 07 	lds	r24, 0x0734
    3b60:	89 17       	cp	r24, r25
    3b62:	28 f4       	brcc	.+10     	; 0x3b6e <vTaskRemoveFromUnorderedEventList+0x138>
    3b64:	ef 81       	ldd	r30, Y+7	; 0x07
    3b66:	f8 85       	ldd	r31, Y+8	; 0x08
    3b68:	86 89       	ldd	r24, Z+22	; 0x16
    3b6a:	80 93 34 07 	sts	0x0734, r24
    3b6e:	ef 81       	ldd	r30, Y+7	; 0x07
    3b70:	f8 85       	ldd	r31, Y+8	; 0x08
    3b72:	86 89       	ldd	r24, Z+22	; 0x16
    3b74:	28 2f       	mov	r18, r24
    3b76:	30 e0       	ldi	r19, 0x00	; 0
    3b78:	c9 01       	movw	r24, r18
    3b7a:	88 0f       	add	r24, r24
    3b7c:	99 1f       	adc	r25, r25
    3b7e:	88 0f       	add	r24, r24
    3b80:	99 1f       	adc	r25, r25
    3b82:	88 0f       	add	r24, r24
    3b84:	99 1f       	adc	r25, r25
    3b86:	82 0f       	add	r24, r18
    3b88:	93 1f       	adc	r25, r19
    3b8a:	fc 01       	movw	r30, r24
    3b8c:	e0 5c       	subi	r30, 0xC0	; 192
    3b8e:	f8 4f       	sbci	r31, 0xF8	; 248
    3b90:	81 81       	ldd	r24, Z+1	; 0x01
    3b92:	92 81       	ldd	r25, Z+2	; 0x02
    3b94:	9a 83       	std	Y+2, r25	; 0x02
    3b96:	89 83       	std	Y+1, r24	; 0x01
    3b98:	ef 81       	ldd	r30, Y+7	; 0x07
    3b9a:	f8 85       	ldd	r31, Y+8	; 0x08
    3b9c:	89 81       	ldd	r24, Y+1	; 0x01
    3b9e:	9a 81       	ldd	r25, Y+2	; 0x02
    3ba0:	95 83       	std	Z+5, r25	; 0x05
    3ba2:	84 83       	std	Z+4, r24	; 0x04
    3ba4:	e9 81       	ldd	r30, Y+1	; 0x01
    3ba6:	fa 81       	ldd	r31, Y+2	; 0x02
    3ba8:	84 81       	ldd	r24, Z+4	; 0x04
    3baa:	95 81       	ldd	r25, Z+5	; 0x05
    3bac:	ef 81       	ldd	r30, Y+7	; 0x07
    3bae:	f8 85       	ldd	r31, Y+8	; 0x08
    3bb0:	97 83       	std	Z+7, r25	; 0x07
    3bb2:	86 83       	std	Z+6, r24	; 0x06
    3bb4:	e9 81       	ldd	r30, Y+1	; 0x01
    3bb6:	fa 81       	ldd	r31, Y+2	; 0x02
    3bb8:	04 80       	ldd	r0, Z+4	; 0x04
    3bba:	f5 81       	ldd	r31, Z+5	; 0x05
    3bbc:	e0 2d       	mov	r30, r0
    3bbe:	8f 81       	ldd	r24, Y+7	; 0x07
    3bc0:	98 85       	ldd	r25, Y+8	; 0x08
    3bc2:	02 96       	adiw	r24, 0x02	; 2
    3bc4:	93 83       	std	Z+3, r25	; 0x03
    3bc6:	82 83       	std	Z+2, r24	; 0x02
    3bc8:	8f 81       	ldd	r24, Y+7	; 0x07
    3bca:	98 85       	ldd	r25, Y+8	; 0x08
    3bcc:	02 96       	adiw	r24, 0x02	; 2
    3bce:	e9 81       	ldd	r30, Y+1	; 0x01
    3bd0:	fa 81       	ldd	r31, Y+2	; 0x02
    3bd2:	95 83       	std	Z+5, r25	; 0x05
    3bd4:	84 83       	std	Z+4, r24	; 0x04
    3bd6:	ef 81       	ldd	r30, Y+7	; 0x07
    3bd8:	f8 85       	ldd	r31, Y+8	; 0x08
    3bda:	86 89       	ldd	r24, Z+22	; 0x16
    3bdc:	28 2f       	mov	r18, r24
    3bde:	30 e0       	ldi	r19, 0x00	; 0
    3be0:	c9 01       	movw	r24, r18
    3be2:	88 0f       	add	r24, r24
    3be4:	99 1f       	adc	r25, r25
    3be6:	88 0f       	add	r24, r24
    3be8:	99 1f       	adc	r25, r25
    3bea:	88 0f       	add	r24, r24
    3bec:	99 1f       	adc	r25, r25
    3bee:	82 0f       	add	r24, r18
    3bf0:	93 1f       	adc	r25, r19
    3bf2:	80 5c       	subi	r24, 0xC0	; 192
    3bf4:	98 4f       	sbci	r25, 0xF8	; 248
    3bf6:	ef 81       	ldd	r30, Y+7	; 0x07
    3bf8:	f8 85       	ldd	r31, Y+8	; 0x08
    3bfa:	93 87       	std	Z+11, r25	; 0x0b
    3bfc:	82 87       	std	Z+10, r24	; 0x0a
    3bfe:	ef 81       	ldd	r30, Y+7	; 0x07
    3c00:	f8 85       	ldd	r31, Y+8	; 0x08
    3c02:	86 89       	ldd	r24, Z+22	; 0x16
    3c04:	28 2f       	mov	r18, r24
    3c06:	30 e0       	ldi	r19, 0x00	; 0
    3c08:	c9 01       	movw	r24, r18
    3c0a:	88 0f       	add	r24, r24
    3c0c:	99 1f       	adc	r25, r25
    3c0e:	88 0f       	add	r24, r24
    3c10:	99 1f       	adc	r25, r25
    3c12:	88 0f       	add	r24, r24
    3c14:	99 1f       	adc	r25, r25
    3c16:	82 0f       	add	r24, r18
    3c18:	93 1f       	adc	r25, r19
    3c1a:	fc 01       	movw	r30, r24
    3c1c:	e0 5c       	subi	r30, 0xC0	; 192
    3c1e:	f8 4f       	sbci	r31, 0xF8	; 248
    3c20:	80 81       	ld	r24, Z
    3c22:	8f 5f       	subi	r24, 0xFF	; 255
    3c24:	80 83       	st	Z, r24

    if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    3c26:	ef 81       	ldd	r30, Y+7	; 0x07
    3c28:	f8 85       	ldd	r31, Y+8	; 0x08
    3c2a:	96 89       	ldd	r25, Z+22	; 0x16
    3c2c:	e0 91 2e 07 	lds	r30, 0x072E
    3c30:	f0 91 2f 07 	lds	r31, 0x072F
    3c34:	86 89       	ldd	r24, Z+22	; 0x16
    3c36:	89 17       	cp	r24, r25
    3c38:	18 f4       	brcc	.+6      	; 0x3c40 <vTaskRemoveFromUnorderedEventList+0x20a>
    {
        /* The unblocked task has a priority above that of the calling task, so
         * a context switch is required.  This function is called with the
         * scheduler suspended so xYieldPending is set so the context switch
         * occurs immediately that the scheduler is resumed (unsuspended). */
        xYieldPending = pdTRUE;
    3c3a:	81 e0       	ldi	r24, 0x01	; 1
    3c3c:	80 93 38 07 	sts	0x0738, r24
    }
}
    3c40:	2c 96       	adiw	r28, 0x0c	; 12
    3c42:	0f b6       	in	r0, 0x3f	; 63
    3c44:	f8 94       	cli
    3c46:	de bf       	out	0x3e, r29	; 62
    3c48:	0f be       	out	0x3f, r0	; 63
    3c4a:	cd bf       	out	0x3d, r28	; 61
    3c4c:	cf 91       	pop	r28
    3c4e:	df 91       	pop	r29
    3c50:	08 95       	ret

00003c52 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    3c52:	df 93       	push	r29
    3c54:	cf 93       	push	r28
    3c56:	00 d0       	rcall	.+0      	; 0x3c58 <vTaskSetTimeOutState+0x6>
    3c58:	cd b7       	in	r28, 0x3d	; 61
    3c5a:	de b7       	in	r29, 0x3e	; 62
    3c5c:	9a 83       	std	Y+2, r25	; 0x02
    3c5e:	89 83       	std	Y+1, r24	; 0x01
    configASSERT( pxTimeOut );
    taskENTER_CRITICAL();
    3c60:	0f b6       	in	r0, 0x3f	; 63
    3c62:	f8 94       	cli
    3c64:	0f 92       	push	r0
    {
        pxTimeOut->xOverflowCount = xNumOfOverflows;
    3c66:	80 91 39 07 	lds	r24, 0x0739
    3c6a:	e9 81       	ldd	r30, Y+1	; 0x01
    3c6c:	fa 81       	ldd	r31, Y+2	; 0x02
    3c6e:	80 83       	st	Z, r24
        pxTimeOut->xTimeOnEntering = xTickCount;
    3c70:	80 91 32 07 	lds	r24, 0x0732
    3c74:	90 91 33 07 	lds	r25, 0x0733
    3c78:	e9 81       	ldd	r30, Y+1	; 0x01
    3c7a:	fa 81       	ldd	r31, Y+2	; 0x02
    3c7c:	92 83       	std	Z+2, r25	; 0x02
    3c7e:	81 83       	std	Z+1, r24	; 0x01
    }
    taskEXIT_CRITICAL();
    3c80:	0f 90       	pop	r0
    3c82:	0f be       	out	0x3f, r0	; 63
}
    3c84:	0f 90       	pop	r0
    3c86:	0f 90       	pop	r0
    3c88:	cf 91       	pop	r28
    3c8a:	df 91       	pop	r29
    3c8c:	08 95       	ret

00003c8e <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    3c8e:	df 93       	push	r29
    3c90:	cf 93       	push	r28
    3c92:	00 d0       	rcall	.+0      	; 0x3c94 <vTaskInternalSetTimeOutState+0x6>
    3c94:	cd b7       	in	r28, 0x3d	; 61
    3c96:	de b7       	in	r29, 0x3e	; 62
    3c98:	9a 83       	std	Y+2, r25	; 0x02
    3c9a:	89 83       	std	Y+1, r24	; 0x01
    /* For internal use only as it does not use a critical section. */
    pxTimeOut->xOverflowCount = xNumOfOverflows;
    3c9c:	80 91 39 07 	lds	r24, 0x0739
    3ca0:	e9 81       	ldd	r30, Y+1	; 0x01
    3ca2:	fa 81       	ldd	r31, Y+2	; 0x02
    3ca4:	80 83       	st	Z, r24
    pxTimeOut->xTimeOnEntering = xTickCount;
    3ca6:	80 91 32 07 	lds	r24, 0x0732
    3caa:	90 91 33 07 	lds	r25, 0x0733
    3cae:	e9 81       	ldd	r30, Y+1	; 0x01
    3cb0:	fa 81       	ldd	r31, Y+2	; 0x02
    3cb2:	92 83       	std	Z+2, r25	; 0x02
    3cb4:	81 83       	std	Z+1, r24	; 0x01
}
    3cb6:	0f 90       	pop	r0
    3cb8:	0f 90       	pop	r0
    3cba:	cf 91       	pop	r28
    3cbc:	df 91       	pop	r29
    3cbe:	08 95       	ret

00003cc0 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut,
                                 TickType_t * const pxTicksToWait )
{
    3cc0:	df 93       	push	r29
    3cc2:	cf 93       	push	r28
    3cc4:	cd b7       	in	r28, 0x3d	; 61
    3cc6:	de b7       	in	r29, 0x3e	; 62
    3cc8:	29 97       	sbiw	r28, 0x09	; 9
    3cca:	0f b6       	in	r0, 0x3f	; 63
    3ccc:	f8 94       	cli
    3cce:	de bf       	out	0x3e, r29	; 62
    3cd0:	0f be       	out	0x3f, r0	; 63
    3cd2:	cd bf       	out	0x3d, r28	; 61
    3cd4:	9f 83       	std	Y+7, r25	; 0x07
    3cd6:	8e 83       	std	Y+6, r24	; 0x06
    3cd8:	79 87       	std	Y+9, r23	; 0x09
    3cda:	68 87       	std	Y+8, r22	; 0x08
    BaseType_t xReturn;

    configASSERT( pxTimeOut );
    configASSERT( pxTicksToWait );

    taskENTER_CRITICAL();
    3cdc:	0f b6       	in	r0, 0x3f	; 63
    3cde:	f8 94       	cli
    3ce0:	0f 92       	push	r0
    {
        /* Minor optimisation.  The tick count cannot change in this block. */
        const TickType_t xConstTickCount = xTickCount;
    3ce2:	80 91 32 07 	lds	r24, 0x0732
    3ce6:	90 91 33 07 	lds	r25, 0x0733
    3cea:	9c 83       	std	Y+4, r25	; 0x04
    3cec:	8b 83       	std	Y+3, r24	; 0x03
        const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    3cee:	ee 81       	ldd	r30, Y+6	; 0x06
    3cf0:	ff 81       	ldd	r31, Y+7	; 0x07
    3cf2:	21 81       	ldd	r18, Z+1	; 0x01
    3cf4:	32 81       	ldd	r19, Z+2	; 0x02
    3cf6:	8b 81       	ldd	r24, Y+3	; 0x03
    3cf8:	9c 81       	ldd	r25, Y+4	; 0x04
    3cfa:	82 1b       	sub	r24, r18
    3cfc:	93 0b       	sbc	r25, r19
    3cfe:	9a 83       	std	Y+2, r25	; 0x02
    3d00:	89 83       	std	Y+1, r24	; 0x01
                xReturn = pdFALSE;
            }
            else
        #endif

        if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    3d02:	ee 81       	ldd	r30, Y+6	; 0x06
    3d04:	ff 81       	ldd	r31, Y+7	; 0x07
    3d06:	90 81       	ld	r25, Z
    3d08:	80 91 39 07 	lds	r24, 0x0739
    3d0c:	98 17       	cp	r25, r24
    3d0e:	81 f0       	breq	.+32     	; 0x3d30 <xTaskCheckForTimeOut+0x70>
    3d10:	ee 81       	ldd	r30, Y+6	; 0x06
    3d12:	ff 81       	ldd	r31, Y+7	; 0x07
    3d14:	21 81       	ldd	r18, Z+1	; 0x01
    3d16:	32 81       	ldd	r19, Z+2	; 0x02
    3d18:	8b 81       	ldd	r24, Y+3	; 0x03
    3d1a:	9c 81       	ldd	r25, Y+4	; 0x04
    3d1c:	82 17       	cp	r24, r18
    3d1e:	93 07       	cpc	r25, r19
    3d20:	38 f0       	brcs	.+14     	; 0x3d30 <xTaskCheckForTimeOut+0x70>
            /* The tick count is greater than the time at which
             * vTaskSetTimeout() was called, but has also overflowed since
             * vTaskSetTimeOut() was called.  It must have wrapped all the way
             * around and gone past again. This passed since vTaskSetTimeout()
             * was called. */
            xReturn = pdTRUE;
    3d22:	81 e0       	ldi	r24, 0x01	; 1
    3d24:	8d 83       	std	Y+5, r24	; 0x05
            *pxTicksToWait = ( TickType_t ) 0;
    3d26:	e8 85       	ldd	r30, Y+8	; 0x08
    3d28:	f9 85       	ldd	r31, Y+9	; 0x09
    3d2a:	11 82       	std	Z+1, r1	; 0x01
    3d2c:	10 82       	st	Z, r1
    3d2e:	23 c0       	rjmp	.+70     	; 0x3d76 <xTaskCheckForTimeOut+0xb6>
        }
        else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    3d30:	e8 85       	ldd	r30, Y+8	; 0x08
    3d32:	f9 85       	ldd	r31, Y+9	; 0x09
    3d34:	20 81       	ld	r18, Z
    3d36:	31 81       	ldd	r19, Z+1	; 0x01
    3d38:	89 81       	ldd	r24, Y+1	; 0x01
    3d3a:	9a 81       	ldd	r25, Y+2	; 0x02
    3d3c:	82 17       	cp	r24, r18
    3d3e:	93 07       	cpc	r25, r19
    3d40:	a0 f4       	brcc	.+40     	; 0x3d6a <xTaskCheckForTimeOut+0xaa>
        {
            /* Not a genuine timeout. Adjust parameters for time remaining. */
            *pxTicksToWait -= xElapsedTime;
    3d42:	e8 85       	ldd	r30, Y+8	; 0x08
    3d44:	f9 85       	ldd	r31, Y+9	; 0x09
    3d46:	20 81       	ld	r18, Z
    3d48:	31 81       	ldd	r19, Z+1	; 0x01
    3d4a:	89 81       	ldd	r24, Y+1	; 0x01
    3d4c:	9a 81       	ldd	r25, Y+2	; 0x02
    3d4e:	a9 01       	movw	r20, r18
    3d50:	48 1b       	sub	r20, r24
    3d52:	59 0b       	sbc	r21, r25
    3d54:	ca 01       	movw	r24, r20
    3d56:	e8 85       	ldd	r30, Y+8	; 0x08
    3d58:	f9 85       	ldd	r31, Y+9	; 0x09
    3d5a:	91 83       	std	Z+1, r25	; 0x01
    3d5c:	80 83       	st	Z, r24
            vTaskInternalSetTimeOutState( pxTimeOut );
    3d5e:	8e 81       	ldd	r24, Y+6	; 0x06
    3d60:	9f 81       	ldd	r25, Y+7	; 0x07
    3d62:	0e 94 47 1e 	call	0x3c8e	; 0x3c8e <vTaskInternalSetTimeOutState>
            xReturn = pdFALSE;
    3d66:	1d 82       	std	Y+5, r1	; 0x05
    3d68:	06 c0       	rjmp	.+12     	; 0x3d76 <xTaskCheckForTimeOut+0xb6>
        }
        else
        {
            *pxTicksToWait = ( TickType_t ) 0;
    3d6a:	e8 85       	ldd	r30, Y+8	; 0x08
    3d6c:	f9 85       	ldd	r31, Y+9	; 0x09
    3d6e:	11 82       	std	Z+1, r1	; 0x01
    3d70:	10 82       	st	Z, r1
            xReturn = pdTRUE;
    3d72:	81 e0       	ldi	r24, 0x01	; 1
    3d74:	8d 83       	std	Y+5, r24	; 0x05
        }
    }
    taskEXIT_CRITICAL();
    3d76:	0f 90       	pop	r0
    3d78:	0f be       	out	0x3f, r0	; 63

    return xReturn;
    3d7a:	8d 81       	ldd	r24, Y+5	; 0x05
}
    3d7c:	29 96       	adiw	r28, 0x09	; 9
    3d7e:	0f b6       	in	r0, 0x3f	; 63
    3d80:	f8 94       	cli
    3d82:	de bf       	out	0x3e, r29	; 62
    3d84:	0f be       	out	0x3f, r0	; 63
    3d86:	cd bf       	out	0x3d, r28	; 61
    3d88:	cf 91       	pop	r28
    3d8a:	df 91       	pop	r29
    3d8c:	08 95       	ret

00003d8e <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    3d8e:	df 93       	push	r29
    3d90:	cf 93       	push	r28
    3d92:	cd b7       	in	r28, 0x3d	; 61
    3d94:	de b7       	in	r29, 0x3e	; 62
    xYieldPending = pdTRUE;
    3d96:	81 e0       	ldi	r24, 0x01	; 1
    3d98:	80 93 38 07 	sts	0x0738, r24
}
    3d9c:	cf 91       	pop	r28
    3d9e:	df 91       	pop	r29
    3da0:	08 95       	ret

00003da2 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    3da2:	df 93       	push	r29
    3da4:	cf 93       	push	r28
    3da6:	00 d0       	rcall	.+0      	; 0x3da8 <prvIdleTask+0x6>
    3da8:	cd b7       	in	r28, 0x3d	; 61
    3daa:	de b7       	in	r29, 0x3e	; 62
    3dac:	9a 83       	std	Y+2, r25	; 0x02
    3dae:	89 83       	std	Y+1, r24	; 0x01

    for( ; ; )
    {
        /* See if any tasks have deleted themselves - if so then the idle task
         * is responsible for freeing the deleted task's TCB and stack. */
        prvCheckTasksWaitingTermination();
    3db0:	0e 94 1e 1f 	call	0x3e3c	; 0x3e3c <prvCheckTasksWaitingTermination>
                 *
                 * A critical region is not required here as we are just reading from
                 * the list, and an occasional incorrect value will not matter.  If
                 * the ready list at the idle priority contains more than one task
                 * then a task other than the idle task is ready to execute. */
                if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    3db4:	80 91 40 07 	lds	r24, 0x0740
    3db8:	82 30       	cpi	r24, 0x02	; 2
    3dba:	d0 f3       	brcs	.-12     	; 0x3db0 <prvIdleTask+0xe>
                {
                    taskYIELD();
    3dbc:	0e 94 a6 02 	call	0x54c	; 0x54c <vPortYield>
    3dc0:	f7 cf       	rjmp	.-18     	; 0x3db0 <prvIdleTask+0xe>

00003dc2 <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
    3dc2:	df 93       	push	r29
    3dc4:	cf 93       	push	r28
    3dc6:	0f 92       	push	r0
    3dc8:	cd b7       	in	r28, 0x3d	; 61
    3dca:	de b7       	in	r29, 0x3e	; 62
    UBaseType_t uxPriority;

    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    3dcc:	19 82       	std	Y+1, r1	; 0x01
    3dce:	13 c0       	rjmp	.+38     	; 0x3df6 <prvInitialiseTaskLists+0x34>
    {
        vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    3dd0:	89 81       	ldd	r24, Y+1	; 0x01
    3dd2:	28 2f       	mov	r18, r24
    3dd4:	30 e0       	ldi	r19, 0x00	; 0
    3dd6:	c9 01       	movw	r24, r18
    3dd8:	88 0f       	add	r24, r24
    3dda:	99 1f       	adc	r25, r25
    3ddc:	88 0f       	add	r24, r24
    3dde:	99 1f       	adc	r25, r25
    3de0:	88 0f       	add	r24, r24
    3de2:	99 1f       	adc	r25, r25
    3de4:	82 0f       	add	r24, r18
    3de6:	93 1f       	adc	r25, r19
    3de8:	80 5c       	subi	r24, 0xC0	; 192
    3dea:	98 4f       	sbci	r25, 0xF8	; 248
    3dec:	0e 94 df 09 	call	0x13be	; 0x13be <vListInitialise>

static void prvInitialiseTaskLists( void )
{
    UBaseType_t uxPriority;

    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    3df0:	89 81       	ldd	r24, Y+1	; 0x01
    3df2:	8f 5f       	subi	r24, 0xFF	; 255
    3df4:	89 83       	std	Y+1, r24	; 0x01
    3df6:	89 81       	ldd	r24, Y+1	; 0x01
    3df8:	84 30       	cpi	r24, 0x04	; 4
    3dfa:	50 f3       	brcs	.-44     	; 0x3dd0 <prvInitialiseTaskLists+0xe>
    {
        vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    }

    vListInitialise( &xDelayedTaskList1 );
    3dfc:	84 e6       	ldi	r24, 0x64	; 100
    3dfe:	97 e0       	ldi	r25, 0x07	; 7
    3e00:	0e 94 df 09 	call	0x13be	; 0x13be <vListInitialise>
    vListInitialise( &xDelayedTaskList2 );
    3e04:	8d e6       	ldi	r24, 0x6D	; 109
    3e06:	97 e0       	ldi	r25, 0x07	; 7
    3e08:	0e 94 df 09 	call	0x13be	; 0x13be <vListInitialise>
    vListInitialise( &xPendingReadyList );
    3e0c:	8a e7       	ldi	r24, 0x7A	; 122
    3e0e:	97 e0       	ldi	r25, 0x07	; 7
    3e10:	0e 94 df 09 	call	0x13be	; 0x13be <vListInitialise>

    #if ( INCLUDE_vTaskDelete == 1 )
        {
            vListInitialise( &xTasksWaitingTermination );
    3e14:	83 e8       	ldi	r24, 0x83	; 131
    3e16:	97 e0       	ldi	r25, 0x07	; 7
    3e18:	0e 94 df 09 	call	0x13be	; 0x13be <vListInitialise>
        }
    #endif /* INCLUDE_vTaskSuspend */

    /* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
     * using list2. */
    pxDelayedTaskList = &xDelayedTaskList1;
    3e1c:	84 e6       	ldi	r24, 0x64	; 100
    3e1e:	97 e0       	ldi	r25, 0x07	; 7
    3e20:	90 93 77 07 	sts	0x0777, r25
    3e24:	80 93 76 07 	sts	0x0776, r24
    pxOverflowDelayedTaskList = &xDelayedTaskList2;
    3e28:	8d e6       	ldi	r24, 0x6D	; 109
    3e2a:	97 e0       	ldi	r25, 0x07	; 7
    3e2c:	90 93 79 07 	sts	0x0779, r25
    3e30:	80 93 78 07 	sts	0x0778, r24
}
    3e34:	0f 90       	pop	r0
    3e36:	cf 91       	pop	r28
    3e38:	df 91       	pop	r29
    3e3a:	08 95       	ret

00003e3c <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    3e3c:	df 93       	push	r29
    3e3e:	cf 93       	push	r28
    3e40:	00 d0       	rcall	.+0      	; 0x3e42 <prvCheckTasksWaitingTermination+0x6>
    3e42:	cd b7       	in	r28, 0x3d	; 61
    3e44:	de b7       	in	r29, 0x3e	; 62
    3e46:	20 c0       	rjmp	.+64     	; 0x3e88 <prvCheckTasksWaitingTermination+0x4c>

            /* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
             * being called too often in the idle task. */
            while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
            {
                taskENTER_CRITICAL();
    3e48:	0f b6       	in	r0, 0x3f	; 63
    3e4a:	f8 94       	cli
    3e4c:	0f 92       	push	r0
                {
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    3e4e:	e0 91 88 07 	lds	r30, 0x0788
    3e52:	f0 91 89 07 	lds	r31, 0x0789
    3e56:	86 81       	ldd	r24, Z+6	; 0x06
    3e58:	97 81       	ldd	r25, Z+7	; 0x07
    3e5a:	9a 83       	std	Y+2, r25	; 0x02
    3e5c:	89 83       	std	Y+1, r24	; 0x01
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    3e5e:	89 81       	ldd	r24, Y+1	; 0x01
    3e60:	9a 81       	ldd	r25, Y+2	; 0x02
    3e62:	02 96       	adiw	r24, 0x02	; 2
    3e64:	0e 94 c9 0a 	call	0x1592	; 0x1592 <uxListRemove>
                    --uxCurrentNumberOfTasks;
    3e68:	80 91 31 07 	lds	r24, 0x0731
    3e6c:	81 50       	subi	r24, 0x01	; 1
    3e6e:	80 93 31 07 	sts	0x0731, r24
                    --uxDeletedTasksWaitingCleanUp;
    3e72:	80 91 30 07 	lds	r24, 0x0730
    3e76:	81 50       	subi	r24, 0x01	; 1
    3e78:	80 93 30 07 	sts	0x0730, r24
                }
                taskEXIT_CRITICAL();
    3e7c:	0f 90       	pop	r0
    3e7e:	0f be       	out	0x3f, r0	; 63

                prvDeleteTCB( pxTCB );
    3e80:	89 81       	ldd	r24, Y+1	; 0x01
    3e82:	9a 81       	ldd	r25, Y+2	; 0x02
    3e84:	0e 94 4d 1f 	call	0x3e9a	; 0x3e9a <prvDeleteTCB>
        {
            TCB_t * pxTCB;

            /* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
             * being called too often in the idle task. */
            while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    3e88:	80 91 30 07 	lds	r24, 0x0730
    3e8c:	88 23       	and	r24, r24
    3e8e:	e1 f6       	brne	.-72     	; 0x3e48 <prvCheckTasksWaitingTermination+0xc>

                prvDeleteTCB( pxTCB );
            }
        }
    #endif /* INCLUDE_vTaskDelete */
}
    3e90:	0f 90       	pop	r0
    3e92:	0f 90       	pop	r0
    3e94:	cf 91       	pop	r28
    3e96:	df 91       	pop	r29
    3e98:	08 95       	ret

00003e9a <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

    static void prvDeleteTCB( TCB_t * pxTCB )
    {
    3e9a:	df 93       	push	r29
    3e9c:	cf 93       	push	r28
    3e9e:	00 d0       	rcall	.+0      	; 0x3ea0 <prvDeleteTCB+0x6>
    3ea0:	cd b7       	in	r28, 0x3d	; 61
    3ea2:	de b7       	in	r29, 0x3e	; 62
    3ea4:	9a 83       	std	Y+2, r25	; 0x02
    3ea6:	89 83       	std	Y+1, r24	; 0x01

        #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
            {
                /* The task can only have been allocated dynamically - free both
                 * the stack and TCB. */
                vPortFreeStack( pxTCB->pxStack );
    3ea8:	e9 81       	ldd	r30, Y+1	; 0x01
    3eaa:	fa 81       	ldd	r31, Y+2	; 0x02
    3eac:	87 89       	ldd	r24, Z+23	; 0x17
    3eae:	90 8d       	ldd	r25, Z+24	; 0x18
    3eb0:	0e 94 c1 00 	call	0x182	; 0x182 <vPortFree>
                vPortFree( pxTCB );
    3eb4:	89 81       	ldd	r24, Y+1	; 0x01
    3eb6:	9a 81       	ldd	r25, Y+2	; 0x02
    3eb8:	0e 94 c1 00 	call	0x182	; 0x182 <vPortFree>
                    configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB );
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
    }
    3ebc:	0f 90       	pop	r0
    3ebe:	0f 90       	pop	r0
    3ec0:	cf 91       	pop	r28
    3ec2:	df 91       	pop	r29
    3ec4:	08 95       	ret

00003ec6 <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    3ec6:	df 93       	push	r29
    3ec8:	cf 93       	push	r28
    3eca:	cd b7       	in	r28, 0x3d	; 61
    3ecc:	de b7       	in	r29, 0x3e	; 62
    if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    3ece:	e0 91 76 07 	lds	r30, 0x0776
    3ed2:	f0 91 77 07 	lds	r31, 0x0777
    3ed6:	80 81       	ld	r24, Z
    3ed8:	88 23       	and	r24, r24
    3eda:	39 f4       	brne	.+14     	; 0x3eea <prvResetNextTaskUnblockTime+0x24>
    {
        /* The new current delayed list is empty.  Set xNextTaskUnblockTime to
         * the maximum possible value so it is  extremely unlikely that the
         * if( xTickCount >= xNextTaskUnblockTime ) test will pass until
         * there is an item in the delayed list. */
        xNextTaskUnblockTime = portMAX_DELAY;
    3edc:	8f ef       	ldi	r24, 0xFF	; 255
    3ede:	9f ef       	ldi	r25, 0xFF	; 255
    3ee0:	90 93 3c 07 	sts	0x073C, r25
    3ee4:	80 93 3b 07 	sts	0x073B, r24
    3ee8:	0d c0       	rjmp	.+26     	; 0x3f04 <prvResetNextTaskUnblockTime+0x3e>
    {
        /* The new current delayed list is not empty, get the value of
         * the item at the head of the delayed list.  This is the time at
         * which the task at the head of the delayed list should be removed
         * from the Blocked state. */
        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );
    3eea:	e0 91 76 07 	lds	r30, 0x0776
    3eee:	f0 91 77 07 	lds	r31, 0x0777
    3ef2:	05 80       	ldd	r0, Z+5	; 0x05
    3ef4:	f6 81       	ldd	r31, Z+6	; 0x06
    3ef6:	e0 2d       	mov	r30, r0
    3ef8:	80 81       	ld	r24, Z
    3efa:	91 81       	ldd	r25, Z+1	; 0x01
    3efc:	90 93 3c 07 	sts	0x073C, r25
    3f00:	80 93 3b 07 	sts	0x073B, r24
    }
}
    3f04:	cf 91       	pop	r28
    3f06:	df 91       	pop	r29
    3f08:	08 95       	ret

00003f0a <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
    3f0a:	df 93       	push	r29
    3f0c:	cf 93       	push	r28
    3f0e:	00 d0       	rcall	.+0      	; 0x3f10 <uxTaskResetEventItemValue+0x6>
    3f10:	cd b7       	in	r28, 0x3d	; 61
    3f12:	de b7       	in	r29, 0x3e	; 62
    TickType_t uxReturn;

    uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    3f14:	e0 91 2e 07 	lds	r30, 0x072E
    3f18:	f0 91 2f 07 	lds	r31, 0x072F
    3f1c:	84 85       	ldd	r24, Z+12	; 0x0c
    3f1e:	95 85       	ldd	r25, Z+13	; 0x0d
    3f20:	9a 83       	std	Y+2, r25	; 0x02
    3f22:	89 83       	std	Y+1, r24	; 0x01

    /* Reset the event list item to its normal value - so it can be used with
     * queues and semaphores. */
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    3f24:	a0 91 2e 07 	lds	r26, 0x072E
    3f28:	b0 91 2f 07 	lds	r27, 0x072F
    3f2c:	e0 91 2e 07 	lds	r30, 0x072E
    3f30:	f0 91 2f 07 	lds	r31, 0x072F
    3f34:	86 89       	ldd	r24, Z+22	; 0x16
    3f36:	28 2f       	mov	r18, r24
    3f38:	30 e0       	ldi	r19, 0x00	; 0
    3f3a:	84 e0       	ldi	r24, 0x04	; 4
    3f3c:	90 e0       	ldi	r25, 0x00	; 0
    3f3e:	82 1b       	sub	r24, r18
    3f40:	93 0b       	sbc	r25, r19
    3f42:	1d 96       	adiw	r26, 0x0d	; 13
    3f44:	9c 93       	st	X, r25
    3f46:	8e 93       	st	-X, r24
    3f48:	1c 97       	sbiw	r26, 0x0c	; 12

    return uxReturn;
    3f4a:	89 81       	ldd	r24, Y+1	; 0x01
    3f4c:	9a 81       	ldd	r25, Y+2	; 0x02
}
    3f4e:	0f 90       	pop	r0
    3f50:	0f 90       	pop	r0
    3f52:	cf 91       	pop	r28
    3f54:	df 91       	pop	r29
    3f56:	08 95       	ret

00003f58 <ulTaskGenericNotifyTake>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    uint32_t ulTaskGenericNotifyTake( UBaseType_t uxIndexToWait,
                                      BaseType_t xClearCountOnExit,
                                      TickType_t xTicksToWait )
    {
    3f58:	df 93       	push	r29
    3f5a:	cf 93       	push	r28
    3f5c:	cd b7       	in	r28, 0x3d	; 61
    3f5e:	de b7       	in	r29, 0x3e	; 62
    3f60:	28 97       	sbiw	r28, 0x08	; 8
    3f62:	0f b6       	in	r0, 0x3f	; 63
    3f64:	f8 94       	cli
    3f66:	de bf       	out	0x3e, r29	; 62
    3f68:	0f be       	out	0x3f, r0	; 63
    3f6a:	cd bf       	out	0x3d, r28	; 61
    3f6c:	8d 83       	std	Y+5, r24	; 0x05
    3f6e:	6e 83       	std	Y+6, r22	; 0x06
    3f70:	58 87       	std	Y+8, r21	; 0x08
    3f72:	4f 83       	std	Y+7, r20	; 0x07
        uint32_t ulReturn;

        configASSERT( uxIndexToWait < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        taskENTER_CRITICAL();
    3f74:	0f b6       	in	r0, 0x3f	; 63
    3f76:	f8 94       	cli
    3f78:	0f 92       	push	r0
        {
            /* Only block if the notification count is not already non-zero. */
            if( pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] == 0UL )
    3f7a:	20 91 2e 07 	lds	r18, 0x072E
    3f7e:	30 91 2f 07 	lds	r19, 0x072F
    3f82:	8d 81       	ldd	r24, Y+5	; 0x05
    3f84:	88 2f       	mov	r24, r24
    3f86:	90 e0       	ldi	r25, 0x00	; 0
    3f88:	88 0f       	add	r24, r24
    3f8a:	99 1f       	adc	r25, r25
    3f8c:	88 0f       	add	r24, r24
    3f8e:	99 1f       	adc	r25, r25
    3f90:	82 0f       	add	r24, r18
    3f92:	93 1f       	adc	r25, r19
    3f94:	fc 01       	movw	r30, r24
    3f96:	b1 96       	adiw	r30, 0x21	; 33
    3f98:	80 81       	ld	r24, Z
    3f9a:	91 81       	ldd	r25, Z+1	; 0x01
    3f9c:	a2 81       	ldd	r26, Z+2	; 0x02
    3f9e:	b3 81       	ldd	r27, Z+3	; 0x03
    3fa0:	00 97       	sbiw	r24, 0x00	; 0
    3fa2:	a1 05       	cpc	r26, r1
    3fa4:	b1 05       	cpc	r27, r1
    3fa6:	c1 f4       	brne	.+48     	; 0x3fd8 <ulTaskGenericNotifyTake+0x80>
            {
                /* Mark this task as waiting for a notification. */
                pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskWAITING_NOTIFICATION;
    3fa8:	20 91 2e 07 	lds	r18, 0x072E
    3fac:	30 91 2f 07 	lds	r19, 0x072F
    3fb0:	8d 81       	ldd	r24, Y+5	; 0x05
    3fb2:	88 2f       	mov	r24, r24
    3fb4:	90 e0       	ldi	r25, 0x00	; 0
    3fb6:	82 0f       	add	r24, r18
    3fb8:	93 1f       	adc	r25, r19
    3fba:	fc 01       	movw	r30, r24
    3fbc:	b5 96       	adiw	r30, 0x25	; 37
    3fbe:	81 e0       	ldi	r24, 0x01	; 1
    3fc0:	80 83       	st	Z, r24

                if( xTicksToWait > ( TickType_t ) 0 )
    3fc2:	8f 81       	ldd	r24, Y+7	; 0x07
    3fc4:	98 85       	ldd	r25, Y+8	; 0x08
    3fc6:	00 97       	sbiw	r24, 0x00	; 0
    3fc8:	39 f0       	breq	.+14     	; 0x3fd8 <ulTaskGenericNotifyTake+0x80>
                {
                    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    3fca:	8f 81       	ldd	r24, Y+7	; 0x07
    3fcc:	98 85       	ldd	r25, Y+8	; 0x08
    3fce:	61 e0       	ldi	r22, 0x01	; 1
    3fd0:	0e 94 31 27 	call	0x4e62	; 0x4e62 <prvAddCurrentTaskToDelayedList>

                    /* All ports are written to allow a yield in a critical
                     * section (some will yield immediately, others wait until the
                     * critical section exits) - but it is not something that
                     * application code should ever do. */
                    portYIELD_WITHIN_API();
    3fd4:	0e 94 a6 02 	call	0x54c	; 0x54c <vPortYield>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    3fd8:	0f 90       	pop	r0
    3fda:	0f be       	out	0x3f, r0	; 63

        taskENTER_CRITICAL();
    3fdc:	0f b6       	in	r0, 0x3f	; 63
    3fde:	f8 94       	cli
    3fe0:	0f 92       	push	r0
        {
            traceTASK_NOTIFY_TAKE( uxIndexToWait );
            ulReturn = pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ];
    3fe2:	20 91 2e 07 	lds	r18, 0x072E
    3fe6:	30 91 2f 07 	lds	r19, 0x072F
    3fea:	8d 81       	ldd	r24, Y+5	; 0x05
    3fec:	88 2f       	mov	r24, r24
    3fee:	90 e0       	ldi	r25, 0x00	; 0
    3ff0:	88 0f       	add	r24, r24
    3ff2:	99 1f       	adc	r25, r25
    3ff4:	88 0f       	add	r24, r24
    3ff6:	99 1f       	adc	r25, r25
    3ff8:	82 0f       	add	r24, r18
    3ffa:	93 1f       	adc	r25, r19
    3ffc:	fc 01       	movw	r30, r24
    3ffe:	b1 96       	adiw	r30, 0x21	; 33
    4000:	80 81       	ld	r24, Z
    4002:	91 81       	ldd	r25, Z+1	; 0x01
    4004:	a2 81       	ldd	r26, Z+2	; 0x02
    4006:	b3 81       	ldd	r27, Z+3	; 0x03
    4008:	89 83       	std	Y+1, r24	; 0x01
    400a:	9a 83       	std	Y+2, r25	; 0x02
    400c:	ab 83       	std	Y+3, r26	; 0x03
    400e:	bc 83       	std	Y+4, r27	; 0x04

            if( ulReturn != 0UL )
    4010:	89 81       	ldd	r24, Y+1	; 0x01
    4012:	9a 81       	ldd	r25, Y+2	; 0x02
    4014:	ab 81       	ldd	r26, Y+3	; 0x03
    4016:	bc 81       	ldd	r27, Y+4	; 0x04
    4018:	00 97       	sbiw	r24, 0x00	; 0
    401a:	a1 05       	cpc	r26, r1
    401c:	b1 05       	cpc	r27, r1
    401e:	a9 f1       	breq	.+106    	; 0x408a <ulTaskGenericNotifyTake+0x132>
            {
                if( xClearCountOnExit != pdFALSE )
    4020:	8e 81       	ldd	r24, Y+6	; 0x06
    4022:	88 23       	and	r24, r24
    4024:	a1 f0       	breq	.+40     	; 0x404e <ulTaskGenericNotifyTake+0xf6>
                {
                    pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] = 0UL;
    4026:	20 91 2e 07 	lds	r18, 0x072E
    402a:	30 91 2f 07 	lds	r19, 0x072F
    402e:	8d 81       	ldd	r24, Y+5	; 0x05
    4030:	88 2f       	mov	r24, r24
    4032:	90 e0       	ldi	r25, 0x00	; 0
    4034:	88 0f       	add	r24, r24
    4036:	99 1f       	adc	r25, r25
    4038:	88 0f       	add	r24, r24
    403a:	99 1f       	adc	r25, r25
    403c:	82 0f       	add	r24, r18
    403e:	93 1f       	adc	r25, r19
    4040:	fc 01       	movw	r30, r24
    4042:	b1 96       	adiw	r30, 0x21	; 33
    4044:	10 82       	st	Z, r1
    4046:	11 82       	std	Z+1, r1	; 0x01
    4048:	12 82       	std	Z+2, r1	; 0x02
    404a:	13 82       	std	Z+3, r1	; 0x03
    404c:	1e c0       	rjmp	.+60     	; 0x408a <ulTaskGenericNotifyTake+0x132>
                }
                else
                {
                    pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] = ulReturn - ( uint32_t ) 1;
    404e:	e0 91 2e 07 	lds	r30, 0x072E
    4052:	f0 91 2f 07 	lds	r31, 0x072F
    4056:	8d 81       	ldd	r24, Y+5	; 0x05
    4058:	68 2f       	mov	r22, r24
    405a:	70 e0       	ldi	r23, 0x00	; 0
    405c:	89 81       	ldd	r24, Y+1	; 0x01
    405e:	9a 81       	ldd	r25, Y+2	; 0x02
    4060:	ab 81       	ldd	r26, Y+3	; 0x03
    4062:	bc 81       	ldd	r27, Y+4	; 0x04
    4064:	9c 01       	movw	r18, r24
    4066:	ad 01       	movw	r20, r26
    4068:	21 50       	subi	r18, 0x01	; 1
    406a:	30 40       	sbci	r19, 0x00	; 0
    406c:	40 40       	sbci	r20, 0x00	; 0
    406e:	50 40       	sbci	r21, 0x00	; 0
    4070:	cb 01       	movw	r24, r22
    4072:	88 0f       	add	r24, r24
    4074:	99 1f       	adc	r25, r25
    4076:	88 0f       	add	r24, r24
    4078:	99 1f       	adc	r25, r25
    407a:	8e 0f       	add	r24, r30
    407c:	9f 1f       	adc	r25, r31
    407e:	fc 01       	movw	r30, r24
    4080:	b1 96       	adiw	r30, 0x21	; 33
    4082:	20 83       	st	Z, r18
    4084:	31 83       	std	Z+1, r19	; 0x01
    4086:	42 83       	std	Z+2, r20	; 0x02
    4088:	53 83       	std	Z+3, r21	; 0x03
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskNOT_WAITING_NOTIFICATION;
    408a:	20 91 2e 07 	lds	r18, 0x072E
    408e:	30 91 2f 07 	lds	r19, 0x072F
    4092:	8d 81       	ldd	r24, Y+5	; 0x05
    4094:	88 2f       	mov	r24, r24
    4096:	90 e0       	ldi	r25, 0x00	; 0
    4098:	82 0f       	add	r24, r18
    409a:	93 1f       	adc	r25, r19
    409c:	fc 01       	movw	r30, r24
    409e:	b5 96       	adiw	r30, 0x25	; 37
    40a0:	10 82       	st	Z, r1
        }
        taskEXIT_CRITICAL();
    40a2:	0f 90       	pop	r0
    40a4:	0f be       	out	0x3f, r0	; 63

        return ulReturn;
    40a6:	89 81       	ldd	r24, Y+1	; 0x01
    40a8:	9a 81       	ldd	r25, Y+2	; 0x02
    40aa:	ab 81       	ldd	r26, Y+3	; 0x03
    40ac:	bc 81       	ldd	r27, Y+4	; 0x04
    }
    40ae:	bc 01       	movw	r22, r24
    40b0:	cd 01       	movw	r24, r26
    40b2:	28 96       	adiw	r28, 0x08	; 8
    40b4:	0f b6       	in	r0, 0x3f	; 63
    40b6:	f8 94       	cli
    40b8:	de bf       	out	0x3e, r29	; 62
    40ba:	0f be       	out	0x3f, r0	; 63
    40bc:	cd bf       	out	0x3d, r28	; 61
    40be:	cf 91       	pop	r28
    40c0:	df 91       	pop	r29
    40c2:	08 95       	ret

000040c4 <xTaskGenericNotifyWait>:
    BaseType_t xTaskGenericNotifyWait( UBaseType_t uxIndexToWait,
                                       uint32_t ulBitsToClearOnEntry,
                                       uint32_t ulBitsToClearOnExit,
                                       uint32_t * pulNotificationValue,
                                       TickType_t xTicksToWait )
    {
    40c4:	cf 92       	push	r12
    40c6:	df 92       	push	r13
    40c8:	ef 92       	push	r14
    40ca:	ff 92       	push	r15
    40cc:	0f 93       	push	r16
    40ce:	1f 93       	push	r17
    40d0:	df 93       	push	r29
    40d2:	cf 93       	push	r28
    40d4:	cd b7       	in	r28, 0x3d	; 61
    40d6:	de b7       	in	r29, 0x3e	; 62
    40d8:	2e 97       	sbiw	r28, 0x0e	; 14
    40da:	0f b6       	in	r0, 0x3f	; 63
    40dc:	f8 94       	cli
    40de:	de bf       	out	0x3e, r29	; 62
    40e0:	0f be       	out	0x3f, r0	; 63
    40e2:	cd bf       	out	0x3d, r28	; 61
    40e4:	8a 83       	std	Y+2, r24	; 0x02
    40e6:	4b 83       	std	Y+3, r20	; 0x03
    40e8:	5c 83       	std	Y+4, r21	; 0x04
    40ea:	6d 83       	std	Y+5, r22	; 0x05
    40ec:	7e 83       	std	Y+6, r23	; 0x06
    40ee:	0f 83       	std	Y+7, r16	; 0x07
    40f0:	18 87       	std	Y+8, r17	; 0x08
    40f2:	29 87       	std	Y+9, r18	; 0x09
    40f4:	3a 87       	std	Y+10, r19	; 0x0a
    40f6:	fc 86       	std	Y+12, r15	; 0x0c
    40f8:	eb 86       	std	Y+11, r14	; 0x0b
    40fa:	de 86       	std	Y+14, r13	; 0x0e
    40fc:	cd 86       	std	Y+13, r12	; 0x0d
        BaseType_t xReturn;

        configASSERT( uxIndexToWait < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        taskENTER_CRITICAL();
    40fe:	0f b6       	in	r0, 0x3f	; 63
    4100:	f8 94       	cli
    4102:	0f 92       	push	r0
        {
            /* Only block if a notification is not already pending. */
            if( pxCurrentTCB->ucNotifyState[ uxIndexToWait ] != taskNOTIFICATION_RECEIVED )
    4104:	20 91 2e 07 	lds	r18, 0x072E
    4108:	30 91 2f 07 	lds	r19, 0x072F
    410c:	8a 81       	ldd	r24, Y+2	; 0x02
    410e:	88 2f       	mov	r24, r24
    4110:	90 e0       	ldi	r25, 0x00	; 0
    4112:	82 0f       	add	r24, r18
    4114:	93 1f       	adc	r25, r19
    4116:	fc 01       	movw	r30, r24
    4118:	b5 96       	adiw	r30, 0x25	; 37
    411a:	80 81       	ld	r24, Z
    411c:	82 30       	cpi	r24, 0x02	; 2
    411e:	09 f4       	brne	.+2      	; 0x4122 <xTaskGenericNotifyWait+0x5e>
    4120:	47 c0       	rjmp	.+142    	; 0x41b0 <xTaskGenericNotifyWait+0xec>
            {
                /* Clear bits in the task's notification value as bits may get
                 * set  by the notifying task or interrupt.  This can be used to
                 * clear the value to zero. */
                pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] &= ~ulBitsToClearOnEntry;
    4122:	60 91 2e 07 	lds	r22, 0x072E
    4126:	70 91 2f 07 	lds	r23, 0x072F
    412a:	8a 81       	ldd	r24, Y+2	; 0x02
    412c:	08 2f       	mov	r16, r24
    412e:	10 e0       	ldi	r17, 0x00	; 0
    4130:	8a 81       	ldd	r24, Y+2	; 0x02
    4132:	88 2f       	mov	r24, r24
    4134:	90 e0       	ldi	r25, 0x00	; 0
    4136:	88 0f       	add	r24, r24
    4138:	99 1f       	adc	r25, r25
    413a:	88 0f       	add	r24, r24
    413c:	99 1f       	adc	r25, r25
    413e:	86 0f       	add	r24, r22
    4140:	97 1f       	adc	r25, r23
    4142:	fc 01       	movw	r30, r24
    4144:	b1 96       	adiw	r30, 0x21	; 33
    4146:	20 81       	ld	r18, Z
    4148:	31 81       	ldd	r19, Z+1	; 0x01
    414a:	42 81       	ldd	r20, Z+2	; 0x02
    414c:	53 81       	ldd	r21, Z+3	; 0x03
    414e:	8b 81       	ldd	r24, Y+3	; 0x03
    4150:	9c 81       	ldd	r25, Y+4	; 0x04
    4152:	ad 81       	ldd	r26, Y+5	; 0x05
    4154:	be 81       	ldd	r27, Y+6	; 0x06
    4156:	80 95       	com	r24
    4158:	90 95       	com	r25
    415a:	a0 95       	com	r26
    415c:	b0 95       	com	r27
    415e:	28 23       	and	r18, r24
    4160:	39 23       	and	r19, r25
    4162:	4a 23       	and	r20, r26
    4164:	5b 23       	and	r21, r27
    4166:	c8 01       	movw	r24, r16
    4168:	88 0f       	add	r24, r24
    416a:	99 1f       	adc	r25, r25
    416c:	88 0f       	add	r24, r24
    416e:	99 1f       	adc	r25, r25
    4170:	86 0f       	add	r24, r22
    4172:	97 1f       	adc	r25, r23
    4174:	fc 01       	movw	r30, r24
    4176:	b1 96       	adiw	r30, 0x21	; 33
    4178:	20 83       	st	Z, r18
    417a:	31 83       	std	Z+1, r19	; 0x01
    417c:	42 83       	std	Z+2, r20	; 0x02
    417e:	53 83       	std	Z+3, r21	; 0x03

                /* Mark this task as waiting for a notification. */
                pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskWAITING_NOTIFICATION;
    4180:	20 91 2e 07 	lds	r18, 0x072E
    4184:	30 91 2f 07 	lds	r19, 0x072F
    4188:	8a 81       	ldd	r24, Y+2	; 0x02
    418a:	88 2f       	mov	r24, r24
    418c:	90 e0       	ldi	r25, 0x00	; 0
    418e:	82 0f       	add	r24, r18
    4190:	93 1f       	adc	r25, r19
    4192:	fc 01       	movw	r30, r24
    4194:	b5 96       	adiw	r30, 0x25	; 37
    4196:	81 e0       	ldi	r24, 0x01	; 1
    4198:	80 83       	st	Z, r24

                if( xTicksToWait > ( TickType_t ) 0 )
    419a:	8d 85       	ldd	r24, Y+13	; 0x0d
    419c:	9e 85       	ldd	r25, Y+14	; 0x0e
    419e:	00 97       	sbiw	r24, 0x00	; 0
    41a0:	39 f0       	breq	.+14     	; 0x41b0 <xTaskGenericNotifyWait+0xec>
                {
                    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    41a2:	8d 85       	ldd	r24, Y+13	; 0x0d
    41a4:	9e 85       	ldd	r25, Y+14	; 0x0e
    41a6:	61 e0       	ldi	r22, 0x01	; 1
    41a8:	0e 94 31 27 	call	0x4e62	; 0x4e62 <prvAddCurrentTaskToDelayedList>

                    /* All ports are written to allow a yield in a critical
                     * section (some will yield immediately, others wait until the
                     * critical section exits) - but it is not something that
                     * application code should ever do. */
                    portYIELD_WITHIN_API();
    41ac:	0e 94 a6 02 	call	0x54c	; 0x54c <vPortYield>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    41b0:	0f 90       	pop	r0
    41b2:	0f be       	out	0x3f, r0	; 63

        taskENTER_CRITICAL();
    41b4:	0f b6       	in	r0, 0x3f	; 63
    41b6:	f8 94       	cli
    41b8:	0f 92       	push	r0
        {
            traceTASK_NOTIFY_WAIT( uxIndexToWait );

            if( pulNotificationValue != NULL )
    41ba:	8b 85       	ldd	r24, Y+11	; 0x0b
    41bc:	9c 85       	ldd	r25, Y+12	; 0x0c
    41be:	00 97       	sbiw	r24, 0x00	; 0
    41c0:	c9 f0       	breq	.+50     	; 0x41f4 <xTaskGenericNotifyWait+0x130>
            {
                /* Output the current notification value, which may or may not
                 * have changed. */
                *pulNotificationValue = pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ];
    41c2:	20 91 2e 07 	lds	r18, 0x072E
    41c6:	30 91 2f 07 	lds	r19, 0x072F
    41ca:	8a 81       	ldd	r24, Y+2	; 0x02
    41cc:	88 2f       	mov	r24, r24
    41ce:	90 e0       	ldi	r25, 0x00	; 0
    41d0:	88 0f       	add	r24, r24
    41d2:	99 1f       	adc	r25, r25
    41d4:	88 0f       	add	r24, r24
    41d6:	99 1f       	adc	r25, r25
    41d8:	82 0f       	add	r24, r18
    41da:	93 1f       	adc	r25, r19
    41dc:	fc 01       	movw	r30, r24
    41de:	b1 96       	adiw	r30, 0x21	; 33
    41e0:	80 81       	ld	r24, Z
    41e2:	91 81       	ldd	r25, Z+1	; 0x01
    41e4:	a2 81       	ldd	r26, Z+2	; 0x02
    41e6:	b3 81       	ldd	r27, Z+3	; 0x03
    41e8:	eb 85       	ldd	r30, Y+11	; 0x0b
    41ea:	fc 85       	ldd	r31, Y+12	; 0x0c
    41ec:	80 83       	st	Z, r24
    41ee:	91 83       	std	Z+1, r25	; 0x01
    41f0:	a2 83       	std	Z+2, r26	; 0x02
    41f2:	b3 83       	std	Z+3, r27	; 0x03

            /* If ucNotifyValue is set then either the task never entered the
             * blocked state (because a notification was already pending) or the
             * task unblocked because of a notification.  Otherwise the task
             * unblocked because of a timeout. */
            if( pxCurrentTCB->ucNotifyState[ uxIndexToWait ] != taskNOTIFICATION_RECEIVED )
    41f4:	20 91 2e 07 	lds	r18, 0x072E
    41f8:	30 91 2f 07 	lds	r19, 0x072F
    41fc:	8a 81       	ldd	r24, Y+2	; 0x02
    41fe:	88 2f       	mov	r24, r24
    4200:	90 e0       	ldi	r25, 0x00	; 0
    4202:	82 0f       	add	r24, r18
    4204:	93 1f       	adc	r25, r19
    4206:	fc 01       	movw	r30, r24
    4208:	b5 96       	adiw	r30, 0x25	; 37
    420a:	80 81       	ld	r24, Z
    420c:	82 30       	cpi	r24, 0x02	; 2
    420e:	11 f0       	breq	.+4      	; 0x4214 <xTaskGenericNotifyWait+0x150>
            {
                /* A notification was not received. */
                xReturn = pdFALSE;
    4210:	19 82       	std	Y+1, r1	; 0x01
    4212:	31 c0       	rjmp	.+98     	; 0x4276 <xTaskGenericNotifyWait+0x1b2>
            }
            else
            {
                /* A notification was already pending or a notification was
                 * received while the task was waiting. */
                pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] &= ~ulBitsToClearOnExit;
    4214:	60 91 2e 07 	lds	r22, 0x072E
    4218:	70 91 2f 07 	lds	r23, 0x072F
    421c:	8a 81       	ldd	r24, Y+2	; 0x02
    421e:	08 2f       	mov	r16, r24
    4220:	10 e0       	ldi	r17, 0x00	; 0
    4222:	8a 81       	ldd	r24, Y+2	; 0x02
    4224:	88 2f       	mov	r24, r24
    4226:	90 e0       	ldi	r25, 0x00	; 0
    4228:	88 0f       	add	r24, r24
    422a:	99 1f       	adc	r25, r25
    422c:	88 0f       	add	r24, r24
    422e:	99 1f       	adc	r25, r25
    4230:	86 0f       	add	r24, r22
    4232:	97 1f       	adc	r25, r23
    4234:	fc 01       	movw	r30, r24
    4236:	b1 96       	adiw	r30, 0x21	; 33
    4238:	20 81       	ld	r18, Z
    423a:	31 81       	ldd	r19, Z+1	; 0x01
    423c:	42 81       	ldd	r20, Z+2	; 0x02
    423e:	53 81       	ldd	r21, Z+3	; 0x03
    4240:	8f 81       	ldd	r24, Y+7	; 0x07
    4242:	98 85       	ldd	r25, Y+8	; 0x08
    4244:	a9 85       	ldd	r26, Y+9	; 0x09
    4246:	ba 85       	ldd	r27, Y+10	; 0x0a
    4248:	80 95       	com	r24
    424a:	90 95       	com	r25
    424c:	a0 95       	com	r26
    424e:	b0 95       	com	r27
    4250:	28 23       	and	r18, r24
    4252:	39 23       	and	r19, r25
    4254:	4a 23       	and	r20, r26
    4256:	5b 23       	and	r21, r27
    4258:	c8 01       	movw	r24, r16
    425a:	88 0f       	add	r24, r24
    425c:	99 1f       	adc	r25, r25
    425e:	88 0f       	add	r24, r24
    4260:	99 1f       	adc	r25, r25
    4262:	86 0f       	add	r24, r22
    4264:	97 1f       	adc	r25, r23
    4266:	fc 01       	movw	r30, r24
    4268:	b1 96       	adiw	r30, 0x21	; 33
    426a:	20 83       	st	Z, r18
    426c:	31 83       	std	Z+1, r19	; 0x01
    426e:	42 83       	std	Z+2, r20	; 0x02
    4270:	53 83       	std	Z+3, r21	; 0x03
                xReturn = pdTRUE;
    4272:	81 e0       	ldi	r24, 0x01	; 1
    4274:	89 83       	std	Y+1, r24	; 0x01
            }

            pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskNOT_WAITING_NOTIFICATION;
    4276:	20 91 2e 07 	lds	r18, 0x072E
    427a:	30 91 2f 07 	lds	r19, 0x072F
    427e:	8a 81       	ldd	r24, Y+2	; 0x02
    4280:	88 2f       	mov	r24, r24
    4282:	90 e0       	ldi	r25, 0x00	; 0
    4284:	82 0f       	add	r24, r18
    4286:	93 1f       	adc	r25, r19
    4288:	fc 01       	movw	r30, r24
    428a:	b5 96       	adiw	r30, 0x25	; 37
    428c:	10 82       	st	Z, r1
        }
        taskEXIT_CRITICAL();
    428e:	0f 90       	pop	r0
    4290:	0f be       	out	0x3f, r0	; 63

        return xReturn;
    4292:	89 81       	ldd	r24, Y+1	; 0x01
    }
    4294:	2e 96       	adiw	r28, 0x0e	; 14
    4296:	0f b6       	in	r0, 0x3f	; 63
    4298:	f8 94       	cli
    429a:	de bf       	out	0x3e, r29	; 62
    429c:	0f be       	out	0x3f, r0	; 63
    429e:	cd bf       	out	0x3d, r28	; 61
    42a0:	cf 91       	pop	r28
    42a2:	df 91       	pop	r29
    42a4:	1f 91       	pop	r17
    42a6:	0f 91       	pop	r16
    42a8:	ff 90       	pop	r15
    42aa:	ef 90       	pop	r14
    42ac:	df 90       	pop	r13
    42ae:	cf 90       	pop	r12
    42b0:	08 95       	ret

000042b2 <xTaskGenericNotify>:
    BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify,
                                   UBaseType_t uxIndexToNotify,
                                   uint32_t ulValue,
                                   eNotifyAction eAction,
                                   uint32_t * pulPreviousNotificationValue )
    {
    42b2:	ef 92       	push	r14
    42b4:	ff 92       	push	r15
    42b6:	0f 93       	push	r16
    42b8:	1f 93       	push	r17
    42ba:	df 93       	push	r29
    42bc:	cf 93       	push	r28
    42be:	cd b7       	in	r28, 0x3d	; 61
    42c0:	de b7       	in	r29, 0x3e	; 62
    42c2:	64 97       	sbiw	r28, 0x14	; 20
    42c4:	0f b6       	in	r0, 0x3f	; 63
    42c6:	f8 94       	cli
    42c8:	de bf       	out	0x3e, r29	; 62
    42ca:	0f be       	out	0x3f, r0	; 63
    42cc:	cd bf       	out	0x3d, r28	; 61
    42ce:	9a 87       	std	Y+10, r25	; 0x0a
    42d0:	89 87       	std	Y+9, r24	; 0x09
    42d2:	6b 87       	std	Y+11, r22	; 0x0b
    42d4:	2c 87       	std	Y+12, r18	; 0x0c
    42d6:	3d 87       	std	Y+13, r19	; 0x0d
    42d8:	4e 87       	std	Y+14, r20	; 0x0e
    42da:	5f 87       	std	Y+15, r21	; 0x0f
    42dc:	08 8b       	std	Y+16, r16	; 0x10
    42de:	fa 8a       	std	Y+18, r15	; 0x12
    42e0:	e9 8a       	std	Y+17, r14	; 0x11
        TCB_t * pxTCB;
        BaseType_t xReturn = pdPASS;
    42e2:	81 e0       	ldi	r24, 0x01	; 1
    42e4:	8e 83       	std	Y+6, r24	; 0x06
        uint8_t ucOriginalNotifyState;

        configASSERT( uxIndexToNotify < configTASK_NOTIFICATION_ARRAY_ENTRIES );
        configASSERT( xTaskToNotify );
        pxTCB = xTaskToNotify;
    42e6:	89 85       	ldd	r24, Y+9	; 0x09
    42e8:	9a 85       	ldd	r25, Y+10	; 0x0a
    42ea:	98 87       	std	Y+8, r25	; 0x08
    42ec:	8f 83       	std	Y+7, r24	; 0x07

        taskENTER_CRITICAL();
    42ee:	0f b6       	in	r0, 0x3f	; 63
    42f0:	f8 94       	cli
    42f2:	0f 92       	push	r0
        {
            if( pulPreviousNotificationValue != NULL )
    42f4:	89 89       	ldd	r24, Y+17	; 0x11
    42f6:	9a 89       	ldd	r25, Y+18	; 0x12
    42f8:	00 97       	sbiw	r24, 0x00	; 0
    42fa:	b9 f0       	breq	.+46     	; 0x432a <xTaskGenericNotify+0x78>
            {
                *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
    42fc:	8b 85       	ldd	r24, Y+11	; 0x0b
    42fe:	88 2f       	mov	r24, r24
    4300:	90 e0       	ldi	r25, 0x00	; 0
    4302:	2f 81       	ldd	r18, Y+7	; 0x07
    4304:	38 85       	ldd	r19, Y+8	; 0x08
    4306:	88 0f       	add	r24, r24
    4308:	99 1f       	adc	r25, r25
    430a:	88 0f       	add	r24, r24
    430c:	99 1f       	adc	r25, r25
    430e:	82 0f       	add	r24, r18
    4310:	93 1f       	adc	r25, r19
    4312:	fc 01       	movw	r30, r24
    4314:	b1 96       	adiw	r30, 0x21	; 33
    4316:	80 81       	ld	r24, Z
    4318:	91 81       	ldd	r25, Z+1	; 0x01
    431a:	a2 81       	ldd	r26, Z+2	; 0x02
    431c:	b3 81       	ldd	r27, Z+3	; 0x03
    431e:	e9 89       	ldd	r30, Y+17	; 0x11
    4320:	fa 89       	ldd	r31, Y+18	; 0x12
    4322:	80 83       	st	Z, r24
    4324:	91 83       	std	Z+1, r25	; 0x01
    4326:	a2 83       	std	Z+2, r26	; 0x02
    4328:	b3 83       	std	Z+3, r27	; 0x03
            }

            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
    432a:	8b 85       	ldd	r24, Y+11	; 0x0b
    432c:	28 2f       	mov	r18, r24
    432e:	30 e0       	ldi	r19, 0x00	; 0
    4330:	8f 81       	ldd	r24, Y+7	; 0x07
    4332:	98 85       	ldd	r25, Y+8	; 0x08
    4334:	82 0f       	add	r24, r18
    4336:	93 1f       	adc	r25, r19
    4338:	fc 01       	movw	r30, r24
    433a:	b5 96       	adiw	r30, 0x25	; 37
    433c:	80 81       	ld	r24, Z
    433e:	8d 83       	std	Y+5, r24	; 0x05

            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
    4340:	8b 85       	ldd	r24, Y+11	; 0x0b
    4342:	28 2f       	mov	r18, r24
    4344:	30 e0       	ldi	r19, 0x00	; 0
    4346:	8f 81       	ldd	r24, Y+7	; 0x07
    4348:	98 85       	ldd	r25, Y+8	; 0x08
    434a:	82 0f       	add	r24, r18
    434c:	93 1f       	adc	r25, r19
    434e:	fc 01       	movw	r30, r24
    4350:	b5 96       	adiw	r30, 0x25	; 37
    4352:	82 e0       	ldi	r24, 0x02	; 2
    4354:	80 83       	st	Z, r24

            switch( eAction )
    4356:	88 89       	ldd	r24, Y+16	; 0x10
    4358:	28 2f       	mov	r18, r24
    435a:	30 e0       	ldi	r19, 0x00	; 0
    435c:	3c 8b       	std	Y+20, r19	; 0x14
    435e:	2b 8b       	std	Y+19, r18	; 0x13
    4360:	8b 89       	ldd	r24, Y+19	; 0x13
    4362:	9c 89       	ldd	r25, Y+20	; 0x14
    4364:	82 30       	cpi	r24, 0x02	; 2
    4366:	91 05       	cpc	r25, r1
    4368:	09 f4       	brne	.+2      	; 0x436c <xTaskGenericNotify+0xba>
    436a:	46 c0       	rjmp	.+140    	; 0x43f8 <xTaskGenericNotify+0x146>
    436c:	2b 89       	ldd	r18, Y+19	; 0x13
    436e:	3c 89       	ldd	r19, Y+20	; 0x14
    4370:	23 30       	cpi	r18, 0x03	; 3
    4372:	31 05       	cpc	r19, r1
    4374:	34 f4       	brge	.+12     	; 0x4382 <xTaskGenericNotify+0xd0>
    4376:	8b 89       	ldd	r24, Y+19	; 0x13
    4378:	9c 89       	ldd	r25, Y+20	; 0x14
    437a:	81 30       	cpi	r24, 0x01	; 1
    437c:	91 05       	cpc	r25, r1
    437e:	71 f0       	breq	.+28     	; 0x439c <xTaskGenericNotify+0xea>
    4380:	93 c0       	rjmp	.+294    	; 0x44a8 <xTaskGenericNotify+0x1f6>
    4382:	2b 89       	ldd	r18, Y+19	; 0x13
    4384:	3c 89       	ldd	r19, Y+20	; 0x14
    4386:	23 30       	cpi	r18, 0x03	; 3
    4388:	31 05       	cpc	r19, r1
    438a:	09 f4       	brne	.+2      	; 0x438e <xTaskGenericNotify+0xdc>
    438c:	5d c0       	rjmp	.+186    	; 0x4448 <xTaskGenericNotify+0x196>
    438e:	8b 89       	ldd	r24, Y+19	; 0x13
    4390:	9c 89       	ldd	r25, Y+20	; 0x14
    4392:	84 30       	cpi	r24, 0x04	; 4
    4394:	91 05       	cpc	r25, r1
    4396:	09 f4       	brne	.+2      	; 0x439a <xTaskGenericNotify+0xe8>
    4398:	6d c0       	rjmp	.+218    	; 0x4474 <xTaskGenericNotify+0x1c2>
    439a:	86 c0       	rjmp	.+268    	; 0x44a8 <xTaskGenericNotify+0x1f6>
            {
                case eSetBits:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;
    439c:	8b 85       	ldd	r24, Y+11	; 0x0b
    439e:	08 2f       	mov	r16, r24
    43a0:	10 e0       	ldi	r17, 0x00	; 0
    43a2:	8b 85       	ldd	r24, Y+11	; 0x0b
    43a4:	88 2f       	mov	r24, r24
    43a6:	90 e0       	ldi	r25, 0x00	; 0
    43a8:	2f 81       	ldd	r18, Y+7	; 0x07
    43aa:	38 85       	ldd	r19, Y+8	; 0x08
    43ac:	88 0f       	add	r24, r24
    43ae:	99 1f       	adc	r25, r25
    43b0:	88 0f       	add	r24, r24
    43b2:	99 1f       	adc	r25, r25
    43b4:	82 0f       	add	r24, r18
    43b6:	93 1f       	adc	r25, r19
    43b8:	fc 01       	movw	r30, r24
    43ba:	b1 96       	adiw	r30, 0x21	; 33
    43bc:	20 81       	ld	r18, Z
    43be:	31 81       	ldd	r19, Z+1	; 0x01
    43c0:	42 81       	ldd	r20, Z+2	; 0x02
    43c2:	53 81       	ldd	r21, Z+3	; 0x03
    43c4:	8c 85       	ldd	r24, Y+12	; 0x0c
    43c6:	9d 85       	ldd	r25, Y+13	; 0x0d
    43c8:	ae 85       	ldd	r26, Y+14	; 0x0e
    43ca:	bf 85       	ldd	r27, Y+15	; 0x0f
    43cc:	ba 01       	movw	r22, r20
    43ce:	a9 01       	movw	r20, r18
    43d0:	48 2b       	or	r20, r24
    43d2:	59 2b       	or	r21, r25
    43d4:	6a 2b       	or	r22, r26
    43d6:	7b 2b       	or	r23, r27
    43d8:	2f 81       	ldd	r18, Y+7	; 0x07
    43da:	38 85       	ldd	r19, Y+8	; 0x08
    43dc:	c8 01       	movw	r24, r16
    43de:	88 0f       	add	r24, r24
    43e0:	99 1f       	adc	r25, r25
    43e2:	88 0f       	add	r24, r24
    43e4:	99 1f       	adc	r25, r25
    43e6:	82 0f       	add	r24, r18
    43e8:	93 1f       	adc	r25, r19
    43ea:	fc 01       	movw	r30, r24
    43ec:	b1 96       	adiw	r30, 0x21	; 33
    43ee:	40 83       	st	Z, r20
    43f0:	51 83       	std	Z+1, r21	; 0x01
    43f2:	62 83       	std	Z+2, r22	; 0x02
    43f4:	73 83       	std	Z+3, r23	; 0x03
    43f6:	58 c0       	rjmp	.+176    	; 0x44a8 <xTaskGenericNotify+0x1f6>
                    break;

                case eIncrement:
                    ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
    43f8:	8b 85       	ldd	r24, Y+11	; 0x0b
    43fa:	08 2f       	mov	r16, r24
    43fc:	10 e0       	ldi	r17, 0x00	; 0
    43fe:	2f 81       	ldd	r18, Y+7	; 0x07
    4400:	38 85       	ldd	r19, Y+8	; 0x08
    4402:	c8 01       	movw	r24, r16
    4404:	88 0f       	add	r24, r24
    4406:	99 1f       	adc	r25, r25
    4408:	88 0f       	add	r24, r24
    440a:	99 1f       	adc	r25, r25
    440c:	82 0f       	add	r24, r18
    440e:	93 1f       	adc	r25, r19
    4410:	fc 01       	movw	r30, r24
    4412:	b1 96       	adiw	r30, 0x21	; 33
    4414:	80 81       	ld	r24, Z
    4416:	91 81       	ldd	r25, Z+1	; 0x01
    4418:	a2 81       	ldd	r26, Z+2	; 0x02
    441a:	b3 81       	ldd	r27, Z+3	; 0x03
    441c:	ac 01       	movw	r20, r24
    441e:	bd 01       	movw	r22, r26
    4420:	4f 5f       	subi	r20, 0xFF	; 255
    4422:	5f 4f       	sbci	r21, 0xFF	; 255
    4424:	6f 4f       	sbci	r22, 0xFF	; 255
    4426:	7f 4f       	sbci	r23, 0xFF	; 255
    4428:	2f 81       	ldd	r18, Y+7	; 0x07
    442a:	38 85       	ldd	r19, Y+8	; 0x08
    442c:	c8 01       	movw	r24, r16
    442e:	88 0f       	add	r24, r24
    4430:	99 1f       	adc	r25, r25
    4432:	88 0f       	add	r24, r24
    4434:	99 1f       	adc	r25, r25
    4436:	82 0f       	add	r24, r18
    4438:	93 1f       	adc	r25, r19
    443a:	fc 01       	movw	r30, r24
    443c:	b1 96       	adiw	r30, 0x21	; 33
    443e:	40 83       	st	Z, r20
    4440:	51 83       	std	Z+1, r21	; 0x01
    4442:	62 83       	std	Z+2, r22	; 0x02
    4444:	73 83       	std	Z+3, r23	; 0x03
    4446:	30 c0       	rjmp	.+96     	; 0x44a8 <xTaskGenericNotify+0x1f6>
                    break;

                case eSetValueWithOverwrite:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    4448:	8b 85       	ldd	r24, Y+11	; 0x0b
    444a:	88 2f       	mov	r24, r24
    444c:	90 e0       	ldi	r25, 0x00	; 0
    444e:	2f 81       	ldd	r18, Y+7	; 0x07
    4450:	38 85       	ldd	r19, Y+8	; 0x08
    4452:	88 0f       	add	r24, r24
    4454:	99 1f       	adc	r25, r25
    4456:	88 0f       	add	r24, r24
    4458:	99 1f       	adc	r25, r25
    445a:	82 0f       	add	r24, r18
    445c:	93 1f       	adc	r25, r19
    445e:	fc 01       	movw	r30, r24
    4460:	b1 96       	adiw	r30, 0x21	; 33
    4462:	8c 85       	ldd	r24, Y+12	; 0x0c
    4464:	9d 85       	ldd	r25, Y+13	; 0x0d
    4466:	ae 85       	ldd	r26, Y+14	; 0x0e
    4468:	bf 85       	ldd	r27, Y+15	; 0x0f
    446a:	80 83       	st	Z, r24
    446c:	91 83       	std	Z+1, r25	; 0x01
    446e:	a2 83       	std	Z+2, r26	; 0x02
    4470:	b3 83       	std	Z+3, r27	; 0x03
    4472:	1a c0       	rjmp	.+52     	; 0x44a8 <xTaskGenericNotify+0x1f6>
                    break;

                case eSetValueWithoutOverwrite:

                    if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    4474:	8d 81       	ldd	r24, Y+5	; 0x05
    4476:	82 30       	cpi	r24, 0x02	; 2
    4478:	b1 f0       	breq	.+44     	; 0x44a6 <xTaskGenericNotify+0x1f4>
                    {
                        pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    447a:	8b 85       	ldd	r24, Y+11	; 0x0b
    447c:	88 2f       	mov	r24, r24
    447e:	90 e0       	ldi	r25, 0x00	; 0
    4480:	2f 81       	ldd	r18, Y+7	; 0x07
    4482:	38 85       	ldd	r19, Y+8	; 0x08
    4484:	88 0f       	add	r24, r24
    4486:	99 1f       	adc	r25, r25
    4488:	88 0f       	add	r24, r24
    448a:	99 1f       	adc	r25, r25
    448c:	82 0f       	add	r24, r18
    448e:	93 1f       	adc	r25, r19
    4490:	fc 01       	movw	r30, r24
    4492:	b1 96       	adiw	r30, 0x21	; 33
    4494:	8c 85       	ldd	r24, Y+12	; 0x0c
    4496:	9d 85       	ldd	r25, Y+13	; 0x0d
    4498:	ae 85       	ldd	r26, Y+14	; 0x0e
    449a:	bf 85       	ldd	r27, Y+15	; 0x0f
    449c:	80 83       	st	Z, r24
    449e:	91 83       	std	Z+1, r25	; 0x01
    44a0:	a2 83       	std	Z+2, r26	; 0x02
    44a2:	b3 83       	std	Z+3, r27	; 0x03
    44a4:	01 c0       	rjmp	.+2      	; 0x44a8 <xTaskGenericNotify+0x1f6>
                    }
                    else
                    {
                        /* The value could not be written to the task. */
                        xReturn = pdFAIL;
    44a6:	1e 82       	std	Y+6, r1	; 0x06

            traceTASK_NOTIFY( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    44a8:	8d 81       	ldd	r24, Y+5	; 0x05
    44aa:	81 30       	cpi	r24, 0x01	; 1
    44ac:	09 f0       	breq	.+2      	; 0x44b0 <xTaskGenericNotify+0x1fe>
    44ae:	af c0       	rjmp	.+350    	; 0x460e <xTaskGenericNotify+0x35c>
            {
                listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    44b0:	ef 81       	ldd	r30, Y+7	; 0x07
    44b2:	f8 85       	ldd	r31, Y+8	; 0x08
    44b4:	82 85       	ldd	r24, Z+10	; 0x0a
    44b6:	93 85       	ldd	r25, Z+11	; 0x0b
    44b8:	9c 83       	std	Y+4, r25	; 0x04
    44ba:	8b 83       	std	Y+3, r24	; 0x03
    44bc:	ef 81       	ldd	r30, Y+7	; 0x07
    44be:	f8 85       	ldd	r31, Y+8	; 0x08
    44c0:	a4 81       	ldd	r26, Z+4	; 0x04
    44c2:	b5 81       	ldd	r27, Z+5	; 0x05
    44c4:	ef 81       	ldd	r30, Y+7	; 0x07
    44c6:	f8 85       	ldd	r31, Y+8	; 0x08
    44c8:	86 81       	ldd	r24, Z+6	; 0x06
    44ca:	97 81       	ldd	r25, Z+7	; 0x07
    44cc:	15 96       	adiw	r26, 0x05	; 5
    44ce:	9c 93       	st	X, r25
    44d0:	8e 93       	st	-X, r24
    44d2:	14 97       	sbiw	r26, 0x04	; 4
    44d4:	ef 81       	ldd	r30, Y+7	; 0x07
    44d6:	f8 85       	ldd	r31, Y+8	; 0x08
    44d8:	a6 81       	ldd	r26, Z+6	; 0x06
    44da:	b7 81       	ldd	r27, Z+7	; 0x07
    44dc:	ef 81       	ldd	r30, Y+7	; 0x07
    44de:	f8 85       	ldd	r31, Y+8	; 0x08
    44e0:	84 81       	ldd	r24, Z+4	; 0x04
    44e2:	95 81       	ldd	r25, Z+5	; 0x05
    44e4:	13 96       	adiw	r26, 0x03	; 3
    44e6:	9c 93       	st	X, r25
    44e8:	8e 93       	st	-X, r24
    44ea:	12 97       	sbiw	r26, 0x02	; 2
    44ec:	eb 81       	ldd	r30, Y+3	; 0x03
    44ee:	fc 81       	ldd	r31, Y+4	; 0x04
    44f0:	21 81       	ldd	r18, Z+1	; 0x01
    44f2:	32 81       	ldd	r19, Z+2	; 0x02
    44f4:	8f 81       	ldd	r24, Y+7	; 0x07
    44f6:	98 85       	ldd	r25, Y+8	; 0x08
    44f8:	02 96       	adiw	r24, 0x02	; 2
    44fa:	28 17       	cp	r18, r24
    44fc:	39 07       	cpc	r19, r25
    44fe:	41 f4       	brne	.+16     	; 0x4510 <xTaskGenericNotify+0x25e>
    4500:	ef 81       	ldd	r30, Y+7	; 0x07
    4502:	f8 85       	ldd	r31, Y+8	; 0x08
    4504:	86 81       	ldd	r24, Z+6	; 0x06
    4506:	97 81       	ldd	r25, Z+7	; 0x07
    4508:	eb 81       	ldd	r30, Y+3	; 0x03
    450a:	fc 81       	ldd	r31, Y+4	; 0x04
    450c:	92 83       	std	Z+2, r25	; 0x02
    450e:	81 83       	std	Z+1, r24	; 0x01
    4510:	ef 81       	ldd	r30, Y+7	; 0x07
    4512:	f8 85       	ldd	r31, Y+8	; 0x08
    4514:	13 86       	std	Z+11, r1	; 0x0b
    4516:	12 86       	std	Z+10, r1	; 0x0a
    4518:	eb 81       	ldd	r30, Y+3	; 0x03
    451a:	fc 81       	ldd	r31, Y+4	; 0x04
    451c:	80 81       	ld	r24, Z
    451e:	81 50       	subi	r24, 0x01	; 1
    4520:	eb 81       	ldd	r30, Y+3	; 0x03
    4522:	fc 81       	ldd	r31, Y+4	; 0x04
    4524:	80 83       	st	Z, r24
                prvAddTaskToReadyList( pxTCB );
    4526:	ef 81       	ldd	r30, Y+7	; 0x07
    4528:	f8 85       	ldd	r31, Y+8	; 0x08
    452a:	96 89       	ldd	r25, Z+22	; 0x16
    452c:	80 91 34 07 	lds	r24, 0x0734
    4530:	89 17       	cp	r24, r25
    4532:	28 f4       	brcc	.+10     	; 0x453e <xTaskGenericNotify+0x28c>
    4534:	ef 81       	ldd	r30, Y+7	; 0x07
    4536:	f8 85       	ldd	r31, Y+8	; 0x08
    4538:	86 89       	ldd	r24, Z+22	; 0x16
    453a:	80 93 34 07 	sts	0x0734, r24
    453e:	ef 81       	ldd	r30, Y+7	; 0x07
    4540:	f8 85       	ldd	r31, Y+8	; 0x08
    4542:	86 89       	ldd	r24, Z+22	; 0x16
    4544:	28 2f       	mov	r18, r24
    4546:	30 e0       	ldi	r19, 0x00	; 0
    4548:	c9 01       	movw	r24, r18
    454a:	88 0f       	add	r24, r24
    454c:	99 1f       	adc	r25, r25
    454e:	88 0f       	add	r24, r24
    4550:	99 1f       	adc	r25, r25
    4552:	88 0f       	add	r24, r24
    4554:	99 1f       	adc	r25, r25
    4556:	82 0f       	add	r24, r18
    4558:	93 1f       	adc	r25, r19
    455a:	fc 01       	movw	r30, r24
    455c:	e0 5c       	subi	r30, 0xC0	; 192
    455e:	f8 4f       	sbci	r31, 0xF8	; 248
    4560:	81 81       	ldd	r24, Z+1	; 0x01
    4562:	92 81       	ldd	r25, Z+2	; 0x02
    4564:	9a 83       	std	Y+2, r25	; 0x02
    4566:	89 83       	std	Y+1, r24	; 0x01
    4568:	ef 81       	ldd	r30, Y+7	; 0x07
    456a:	f8 85       	ldd	r31, Y+8	; 0x08
    456c:	89 81       	ldd	r24, Y+1	; 0x01
    456e:	9a 81       	ldd	r25, Y+2	; 0x02
    4570:	95 83       	std	Z+5, r25	; 0x05
    4572:	84 83       	std	Z+4, r24	; 0x04
    4574:	e9 81       	ldd	r30, Y+1	; 0x01
    4576:	fa 81       	ldd	r31, Y+2	; 0x02
    4578:	84 81       	ldd	r24, Z+4	; 0x04
    457a:	95 81       	ldd	r25, Z+5	; 0x05
    457c:	ef 81       	ldd	r30, Y+7	; 0x07
    457e:	f8 85       	ldd	r31, Y+8	; 0x08
    4580:	97 83       	std	Z+7, r25	; 0x07
    4582:	86 83       	std	Z+6, r24	; 0x06
    4584:	e9 81       	ldd	r30, Y+1	; 0x01
    4586:	fa 81       	ldd	r31, Y+2	; 0x02
    4588:	04 80       	ldd	r0, Z+4	; 0x04
    458a:	f5 81       	ldd	r31, Z+5	; 0x05
    458c:	e0 2d       	mov	r30, r0
    458e:	8f 81       	ldd	r24, Y+7	; 0x07
    4590:	98 85       	ldd	r25, Y+8	; 0x08
    4592:	02 96       	adiw	r24, 0x02	; 2
    4594:	93 83       	std	Z+3, r25	; 0x03
    4596:	82 83       	std	Z+2, r24	; 0x02
    4598:	8f 81       	ldd	r24, Y+7	; 0x07
    459a:	98 85       	ldd	r25, Y+8	; 0x08
    459c:	02 96       	adiw	r24, 0x02	; 2
    459e:	e9 81       	ldd	r30, Y+1	; 0x01
    45a0:	fa 81       	ldd	r31, Y+2	; 0x02
    45a2:	95 83       	std	Z+5, r25	; 0x05
    45a4:	84 83       	std	Z+4, r24	; 0x04
    45a6:	ef 81       	ldd	r30, Y+7	; 0x07
    45a8:	f8 85       	ldd	r31, Y+8	; 0x08
    45aa:	86 89       	ldd	r24, Z+22	; 0x16
    45ac:	28 2f       	mov	r18, r24
    45ae:	30 e0       	ldi	r19, 0x00	; 0
    45b0:	c9 01       	movw	r24, r18
    45b2:	88 0f       	add	r24, r24
    45b4:	99 1f       	adc	r25, r25
    45b6:	88 0f       	add	r24, r24
    45b8:	99 1f       	adc	r25, r25
    45ba:	88 0f       	add	r24, r24
    45bc:	99 1f       	adc	r25, r25
    45be:	82 0f       	add	r24, r18
    45c0:	93 1f       	adc	r25, r19
    45c2:	80 5c       	subi	r24, 0xC0	; 192
    45c4:	98 4f       	sbci	r25, 0xF8	; 248
    45c6:	ef 81       	ldd	r30, Y+7	; 0x07
    45c8:	f8 85       	ldd	r31, Y+8	; 0x08
    45ca:	93 87       	std	Z+11, r25	; 0x0b
    45cc:	82 87       	std	Z+10, r24	; 0x0a
    45ce:	ef 81       	ldd	r30, Y+7	; 0x07
    45d0:	f8 85       	ldd	r31, Y+8	; 0x08
    45d2:	86 89       	ldd	r24, Z+22	; 0x16
    45d4:	28 2f       	mov	r18, r24
    45d6:	30 e0       	ldi	r19, 0x00	; 0
    45d8:	c9 01       	movw	r24, r18
    45da:	88 0f       	add	r24, r24
    45dc:	99 1f       	adc	r25, r25
    45de:	88 0f       	add	r24, r24
    45e0:	99 1f       	adc	r25, r25
    45e2:	88 0f       	add	r24, r24
    45e4:	99 1f       	adc	r25, r25
    45e6:	82 0f       	add	r24, r18
    45e8:	93 1f       	adc	r25, r19
    45ea:	fc 01       	movw	r30, r24
    45ec:	e0 5c       	subi	r30, 0xC0	; 192
    45ee:	f8 4f       	sbci	r31, 0xF8	; 248
    45f0:	80 81       	ld	r24, Z
    45f2:	8f 5f       	subi	r24, 0xFF	; 255
    45f4:	80 83       	st	Z, r24
                         * earliest possible time. */
                        prvResetNextTaskUnblockTime();
                    }
                #endif

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    45f6:	ef 81       	ldd	r30, Y+7	; 0x07
    45f8:	f8 85       	ldd	r31, Y+8	; 0x08
    45fa:	96 89       	ldd	r25, Z+22	; 0x16
    45fc:	e0 91 2e 07 	lds	r30, 0x072E
    4600:	f0 91 2f 07 	lds	r31, 0x072F
    4604:	86 89       	ldd	r24, Z+22	; 0x16
    4606:	89 17       	cp	r24, r25
    4608:	10 f4       	brcc	.+4      	; 0x460e <xTaskGenericNotify+0x35c>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    taskYIELD_IF_USING_PREEMPTION();
    460a:	0e 94 a6 02 	call	0x54c	; 0x54c <vPortYield>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    460e:	0f 90       	pop	r0
    4610:	0f be       	out	0x3f, r0	; 63

        return xReturn;
    4612:	8e 81       	ldd	r24, Y+6	; 0x06
    }
    4614:	64 96       	adiw	r28, 0x14	; 20
    4616:	0f b6       	in	r0, 0x3f	; 63
    4618:	f8 94       	cli
    461a:	de bf       	out	0x3e, r29	; 62
    461c:	0f be       	out	0x3f, r0	; 63
    461e:	cd bf       	out	0x3d, r28	; 61
    4620:	cf 91       	pop	r28
    4622:	df 91       	pop	r29
    4624:	1f 91       	pop	r17
    4626:	0f 91       	pop	r16
    4628:	ff 90       	pop	r15
    462a:	ef 90       	pop	r14
    462c:	08 95       	ret

0000462e <xTaskGenericNotifyFromISR>:
                                          UBaseType_t uxIndexToNotify,
                                          uint32_t ulValue,
                                          eNotifyAction eAction,
                                          uint32_t * pulPreviousNotificationValue,
                                          BaseType_t * pxHigherPriorityTaskWoken )
    {
    462e:	cf 92       	push	r12
    4630:	df 92       	push	r13
    4632:	ef 92       	push	r14
    4634:	ff 92       	push	r15
    4636:	0f 93       	push	r16
    4638:	1f 93       	push	r17
    463a:	df 93       	push	r29
    463c:	cf 93       	push	r28
    463e:	cd b7       	in	r28, 0x3d	; 61
    4640:	de b7       	in	r29, 0x3e	; 62
    4642:	69 97       	sbiw	r28, 0x19	; 25
    4644:	0f b6       	in	r0, 0x3f	; 63
    4646:	f8 94       	cli
    4648:	de bf       	out	0x3e, r29	; 62
    464a:	0f be       	out	0x3f, r0	; 63
    464c:	cd bf       	out	0x3d, r28	; 61
    464e:	9d 87       	std	Y+13, r25	; 0x0d
    4650:	8c 87       	std	Y+12, r24	; 0x0c
    4652:	6e 87       	std	Y+14, r22	; 0x0e
    4654:	2f 87       	std	Y+15, r18	; 0x0f
    4656:	38 8b       	std	Y+16, r19	; 0x10
    4658:	49 8b       	std	Y+17, r20	; 0x11
    465a:	5a 8b       	std	Y+18, r21	; 0x12
    465c:	0b 8b       	std	Y+19, r16	; 0x13
    465e:	fd 8a       	std	Y+21, r15	; 0x15
    4660:	ec 8a       	std	Y+20, r14	; 0x14
    4662:	df 8a       	std	Y+23, r13	; 0x17
    4664:	ce 8a       	std	Y+22, r12	; 0x16
        TCB_t * pxTCB;
        uint8_t ucOriginalNotifyState;
        BaseType_t xReturn = pdPASS;
    4666:	81 e0       	ldi	r24, 0x01	; 1
    4668:	88 87       	std	Y+8, r24	; 0x08
         * simple as possible.  More information (albeit Cortex-M specific) is
         * provided on the following link:
         * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
        portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

        pxTCB = xTaskToNotify;
    466a:	8c 85       	ldd	r24, Y+12	; 0x0c
    466c:	9d 85       	ldd	r25, Y+13	; 0x0d
    466e:	9b 87       	std	Y+11, r25	; 0x0b
    4670:	8a 87       	std	Y+10, r24	; 0x0a

        uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    4672:	1f 82       	std	Y+7, r1	; 0x07
        {
            if( pulPreviousNotificationValue != NULL )
    4674:	8c 89       	ldd	r24, Y+20	; 0x14
    4676:	9d 89       	ldd	r25, Y+21	; 0x15
    4678:	00 97       	sbiw	r24, 0x00	; 0
    467a:	b9 f0       	breq	.+46     	; 0x46aa <xTaskGenericNotifyFromISR+0x7c>
            {
                *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
    467c:	8e 85       	ldd	r24, Y+14	; 0x0e
    467e:	88 2f       	mov	r24, r24
    4680:	90 e0       	ldi	r25, 0x00	; 0
    4682:	2a 85       	ldd	r18, Y+10	; 0x0a
    4684:	3b 85       	ldd	r19, Y+11	; 0x0b
    4686:	88 0f       	add	r24, r24
    4688:	99 1f       	adc	r25, r25
    468a:	88 0f       	add	r24, r24
    468c:	99 1f       	adc	r25, r25
    468e:	82 0f       	add	r24, r18
    4690:	93 1f       	adc	r25, r19
    4692:	fc 01       	movw	r30, r24
    4694:	b1 96       	adiw	r30, 0x21	; 33
    4696:	80 81       	ld	r24, Z
    4698:	91 81       	ldd	r25, Z+1	; 0x01
    469a:	a2 81       	ldd	r26, Z+2	; 0x02
    469c:	b3 81       	ldd	r27, Z+3	; 0x03
    469e:	ec 89       	ldd	r30, Y+20	; 0x14
    46a0:	fd 89       	ldd	r31, Y+21	; 0x15
    46a2:	80 83       	st	Z, r24
    46a4:	91 83       	std	Z+1, r25	; 0x01
    46a6:	a2 83       	std	Z+2, r26	; 0x02
    46a8:	b3 83       	std	Z+3, r27	; 0x03
            }

            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
    46aa:	8e 85       	ldd	r24, Y+14	; 0x0e
    46ac:	28 2f       	mov	r18, r24
    46ae:	30 e0       	ldi	r19, 0x00	; 0
    46b0:	8a 85       	ldd	r24, Y+10	; 0x0a
    46b2:	9b 85       	ldd	r25, Y+11	; 0x0b
    46b4:	82 0f       	add	r24, r18
    46b6:	93 1f       	adc	r25, r19
    46b8:	fc 01       	movw	r30, r24
    46ba:	b5 96       	adiw	r30, 0x25	; 37
    46bc:	80 81       	ld	r24, Z
    46be:	89 87       	std	Y+9, r24	; 0x09
            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
    46c0:	8e 85       	ldd	r24, Y+14	; 0x0e
    46c2:	28 2f       	mov	r18, r24
    46c4:	30 e0       	ldi	r19, 0x00	; 0
    46c6:	8a 85       	ldd	r24, Y+10	; 0x0a
    46c8:	9b 85       	ldd	r25, Y+11	; 0x0b
    46ca:	82 0f       	add	r24, r18
    46cc:	93 1f       	adc	r25, r19
    46ce:	fc 01       	movw	r30, r24
    46d0:	b5 96       	adiw	r30, 0x25	; 37
    46d2:	82 e0       	ldi	r24, 0x02	; 2
    46d4:	80 83       	st	Z, r24

            switch( eAction )
    46d6:	8b 89       	ldd	r24, Y+19	; 0x13
    46d8:	28 2f       	mov	r18, r24
    46da:	30 e0       	ldi	r19, 0x00	; 0
    46dc:	39 8f       	std	Y+25, r19	; 0x19
    46de:	28 8f       	std	Y+24, r18	; 0x18
    46e0:	88 8d       	ldd	r24, Y+24	; 0x18
    46e2:	99 8d       	ldd	r25, Y+25	; 0x19
    46e4:	82 30       	cpi	r24, 0x02	; 2
    46e6:	91 05       	cpc	r25, r1
    46e8:	09 f4       	brne	.+2      	; 0x46ec <xTaskGenericNotifyFromISR+0xbe>
    46ea:	46 c0       	rjmp	.+140    	; 0x4778 <xTaskGenericNotifyFromISR+0x14a>
    46ec:	28 8d       	ldd	r18, Y+24	; 0x18
    46ee:	39 8d       	ldd	r19, Y+25	; 0x19
    46f0:	23 30       	cpi	r18, 0x03	; 3
    46f2:	31 05       	cpc	r19, r1
    46f4:	34 f4       	brge	.+12     	; 0x4702 <xTaskGenericNotifyFromISR+0xd4>
    46f6:	88 8d       	ldd	r24, Y+24	; 0x18
    46f8:	99 8d       	ldd	r25, Y+25	; 0x19
    46fa:	81 30       	cpi	r24, 0x01	; 1
    46fc:	91 05       	cpc	r25, r1
    46fe:	71 f0       	breq	.+28     	; 0x471c <xTaskGenericNotifyFromISR+0xee>
    4700:	93 c0       	rjmp	.+294    	; 0x4828 <xTaskGenericNotifyFromISR+0x1fa>
    4702:	28 8d       	ldd	r18, Y+24	; 0x18
    4704:	39 8d       	ldd	r19, Y+25	; 0x19
    4706:	23 30       	cpi	r18, 0x03	; 3
    4708:	31 05       	cpc	r19, r1
    470a:	09 f4       	brne	.+2      	; 0x470e <xTaskGenericNotifyFromISR+0xe0>
    470c:	5d c0       	rjmp	.+186    	; 0x47c8 <xTaskGenericNotifyFromISR+0x19a>
    470e:	88 8d       	ldd	r24, Y+24	; 0x18
    4710:	99 8d       	ldd	r25, Y+25	; 0x19
    4712:	84 30       	cpi	r24, 0x04	; 4
    4714:	91 05       	cpc	r25, r1
    4716:	09 f4       	brne	.+2      	; 0x471a <xTaskGenericNotifyFromISR+0xec>
    4718:	6d c0       	rjmp	.+218    	; 0x47f4 <xTaskGenericNotifyFromISR+0x1c6>
    471a:	86 c0       	rjmp	.+268    	; 0x4828 <xTaskGenericNotifyFromISR+0x1fa>
            {
                case eSetBits:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;
    471c:	8e 85       	ldd	r24, Y+14	; 0x0e
    471e:	08 2f       	mov	r16, r24
    4720:	10 e0       	ldi	r17, 0x00	; 0
    4722:	8e 85       	ldd	r24, Y+14	; 0x0e
    4724:	88 2f       	mov	r24, r24
    4726:	90 e0       	ldi	r25, 0x00	; 0
    4728:	2a 85       	ldd	r18, Y+10	; 0x0a
    472a:	3b 85       	ldd	r19, Y+11	; 0x0b
    472c:	88 0f       	add	r24, r24
    472e:	99 1f       	adc	r25, r25
    4730:	88 0f       	add	r24, r24
    4732:	99 1f       	adc	r25, r25
    4734:	82 0f       	add	r24, r18
    4736:	93 1f       	adc	r25, r19
    4738:	fc 01       	movw	r30, r24
    473a:	b1 96       	adiw	r30, 0x21	; 33
    473c:	20 81       	ld	r18, Z
    473e:	31 81       	ldd	r19, Z+1	; 0x01
    4740:	42 81       	ldd	r20, Z+2	; 0x02
    4742:	53 81       	ldd	r21, Z+3	; 0x03
    4744:	8f 85       	ldd	r24, Y+15	; 0x0f
    4746:	98 89       	ldd	r25, Y+16	; 0x10
    4748:	a9 89       	ldd	r26, Y+17	; 0x11
    474a:	ba 89       	ldd	r27, Y+18	; 0x12
    474c:	ba 01       	movw	r22, r20
    474e:	a9 01       	movw	r20, r18
    4750:	48 2b       	or	r20, r24
    4752:	59 2b       	or	r21, r25
    4754:	6a 2b       	or	r22, r26
    4756:	7b 2b       	or	r23, r27
    4758:	2a 85       	ldd	r18, Y+10	; 0x0a
    475a:	3b 85       	ldd	r19, Y+11	; 0x0b
    475c:	c8 01       	movw	r24, r16
    475e:	88 0f       	add	r24, r24
    4760:	99 1f       	adc	r25, r25
    4762:	88 0f       	add	r24, r24
    4764:	99 1f       	adc	r25, r25
    4766:	82 0f       	add	r24, r18
    4768:	93 1f       	adc	r25, r19
    476a:	fc 01       	movw	r30, r24
    476c:	b1 96       	adiw	r30, 0x21	; 33
    476e:	40 83       	st	Z, r20
    4770:	51 83       	std	Z+1, r21	; 0x01
    4772:	62 83       	std	Z+2, r22	; 0x02
    4774:	73 83       	std	Z+3, r23	; 0x03
    4776:	58 c0       	rjmp	.+176    	; 0x4828 <xTaskGenericNotifyFromISR+0x1fa>
                    break;

                case eIncrement:
                    ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
    4778:	8e 85       	ldd	r24, Y+14	; 0x0e
    477a:	08 2f       	mov	r16, r24
    477c:	10 e0       	ldi	r17, 0x00	; 0
    477e:	2a 85       	ldd	r18, Y+10	; 0x0a
    4780:	3b 85       	ldd	r19, Y+11	; 0x0b
    4782:	c8 01       	movw	r24, r16
    4784:	88 0f       	add	r24, r24
    4786:	99 1f       	adc	r25, r25
    4788:	88 0f       	add	r24, r24
    478a:	99 1f       	adc	r25, r25
    478c:	82 0f       	add	r24, r18
    478e:	93 1f       	adc	r25, r19
    4790:	fc 01       	movw	r30, r24
    4792:	b1 96       	adiw	r30, 0x21	; 33
    4794:	80 81       	ld	r24, Z
    4796:	91 81       	ldd	r25, Z+1	; 0x01
    4798:	a2 81       	ldd	r26, Z+2	; 0x02
    479a:	b3 81       	ldd	r27, Z+3	; 0x03
    479c:	ac 01       	movw	r20, r24
    479e:	bd 01       	movw	r22, r26
    47a0:	4f 5f       	subi	r20, 0xFF	; 255
    47a2:	5f 4f       	sbci	r21, 0xFF	; 255
    47a4:	6f 4f       	sbci	r22, 0xFF	; 255
    47a6:	7f 4f       	sbci	r23, 0xFF	; 255
    47a8:	2a 85       	ldd	r18, Y+10	; 0x0a
    47aa:	3b 85       	ldd	r19, Y+11	; 0x0b
    47ac:	c8 01       	movw	r24, r16
    47ae:	88 0f       	add	r24, r24
    47b0:	99 1f       	adc	r25, r25
    47b2:	88 0f       	add	r24, r24
    47b4:	99 1f       	adc	r25, r25
    47b6:	82 0f       	add	r24, r18
    47b8:	93 1f       	adc	r25, r19
    47ba:	fc 01       	movw	r30, r24
    47bc:	b1 96       	adiw	r30, 0x21	; 33
    47be:	40 83       	st	Z, r20
    47c0:	51 83       	std	Z+1, r21	; 0x01
    47c2:	62 83       	std	Z+2, r22	; 0x02
    47c4:	73 83       	std	Z+3, r23	; 0x03
    47c6:	30 c0       	rjmp	.+96     	; 0x4828 <xTaskGenericNotifyFromISR+0x1fa>
                    break;

                case eSetValueWithOverwrite:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    47c8:	8e 85       	ldd	r24, Y+14	; 0x0e
    47ca:	88 2f       	mov	r24, r24
    47cc:	90 e0       	ldi	r25, 0x00	; 0
    47ce:	2a 85       	ldd	r18, Y+10	; 0x0a
    47d0:	3b 85       	ldd	r19, Y+11	; 0x0b
    47d2:	88 0f       	add	r24, r24
    47d4:	99 1f       	adc	r25, r25
    47d6:	88 0f       	add	r24, r24
    47d8:	99 1f       	adc	r25, r25
    47da:	82 0f       	add	r24, r18
    47dc:	93 1f       	adc	r25, r19
    47de:	fc 01       	movw	r30, r24
    47e0:	b1 96       	adiw	r30, 0x21	; 33
    47e2:	8f 85       	ldd	r24, Y+15	; 0x0f
    47e4:	98 89       	ldd	r25, Y+16	; 0x10
    47e6:	a9 89       	ldd	r26, Y+17	; 0x11
    47e8:	ba 89       	ldd	r27, Y+18	; 0x12
    47ea:	80 83       	st	Z, r24
    47ec:	91 83       	std	Z+1, r25	; 0x01
    47ee:	a2 83       	std	Z+2, r26	; 0x02
    47f0:	b3 83       	std	Z+3, r27	; 0x03
    47f2:	1a c0       	rjmp	.+52     	; 0x4828 <xTaskGenericNotifyFromISR+0x1fa>
                    break;

                case eSetValueWithoutOverwrite:

                    if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    47f4:	89 85       	ldd	r24, Y+9	; 0x09
    47f6:	82 30       	cpi	r24, 0x02	; 2
    47f8:	b1 f0       	breq	.+44     	; 0x4826 <xTaskGenericNotifyFromISR+0x1f8>
                    {
                        pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    47fa:	8e 85       	ldd	r24, Y+14	; 0x0e
    47fc:	88 2f       	mov	r24, r24
    47fe:	90 e0       	ldi	r25, 0x00	; 0
    4800:	2a 85       	ldd	r18, Y+10	; 0x0a
    4802:	3b 85       	ldd	r19, Y+11	; 0x0b
    4804:	88 0f       	add	r24, r24
    4806:	99 1f       	adc	r25, r25
    4808:	88 0f       	add	r24, r24
    480a:	99 1f       	adc	r25, r25
    480c:	82 0f       	add	r24, r18
    480e:	93 1f       	adc	r25, r19
    4810:	fc 01       	movw	r30, r24
    4812:	b1 96       	adiw	r30, 0x21	; 33
    4814:	8f 85       	ldd	r24, Y+15	; 0x0f
    4816:	98 89       	ldd	r25, Y+16	; 0x10
    4818:	a9 89       	ldd	r26, Y+17	; 0x11
    481a:	ba 89       	ldd	r27, Y+18	; 0x12
    481c:	80 83       	st	Z, r24
    481e:	91 83       	std	Z+1, r25	; 0x01
    4820:	a2 83       	std	Z+2, r26	; 0x02
    4822:	b3 83       	std	Z+3, r27	; 0x03
    4824:	01 c0       	rjmp	.+2      	; 0x4828 <xTaskGenericNotifyFromISR+0x1fa>
                    }
                    else
                    {
                        /* The value could not be written to the task. */
                        xReturn = pdFAIL;
    4826:	18 86       	std	Y+8, r1	; 0x08

            traceTASK_NOTIFY_FROM_ISR( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    4828:	89 85       	ldd	r24, Y+9	; 0x09
    482a:	81 30       	cpi	r24, 0x01	; 1
    482c:	09 f0       	breq	.+2      	; 0x4830 <xTaskGenericNotifyFromISR+0x202>
    482e:	ee c0       	rjmp	.+476    	; 0x4a0c <xTaskGenericNotifyFromISR+0x3de>
            {
                /* The task should not have been on an event list. */
                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

                if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    4830:	80 91 3f 07 	lds	r24, 0x073F
    4834:	88 23       	and	r24, r24
    4836:	09 f0       	breq	.+2      	; 0x483a <xTaskGenericNotifyFromISR+0x20c>
    4838:	a4 c0       	rjmp	.+328    	; 0x4982 <xTaskGenericNotifyFromISR+0x354>
                {
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    483a:	ea 85       	ldd	r30, Y+10	; 0x0a
    483c:	fb 85       	ldd	r31, Y+11	; 0x0b
    483e:	82 85       	ldd	r24, Z+10	; 0x0a
    4840:	93 85       	ldd	r25, Z+11	; 0x0b
    4842:	9e 83       	std	Y+6, r25	; 0x06
    4844:	8d 83       	std	Y+5, r24	; 0x05
    4846:	ea 85       	ldd	r30, Y+10	; 0x0a
    4848:	fb 85       	ldd	r31, Y+11	; 0x0b
    484a:	a4 81       	ldd	r26, Z+4	; 0x04
    484c:	b5 81       	ldd	r27, Z+5	; 0x05
    484e:	ea 85       	ldd	r30, Y+10	; 0x0a
    4850:	fb 85       	ldd	r31, Y+11	; 0x0b
    4852:	86 81       	ldd	r24, Z+6	; 0x06
    4854:	97 81       	ldd	r25, Z+7	; 0x07
    4856:	15 96       	adiw	r26, 0x05	; 5
    4858:	9c 93       	st	X, r25
    485a:	8e 93       	st	-X, r24
    485c:	14 97       	sbiw	r26, 0x04	; 4
    485e:	ea 85       	ldd	r30, Y+10	; 0x0a
    4860:	fb 85       	ldd	r31, Y+11	; 0x0b
    4862:	a6 81       	ldd	r26, Z+6	; 0x06
    4864:	b7 81       	ldd	r27, Z+7	; 0x07
    4866:	ea 85       	ldd	r30, Y+10	; 0x0a
    4868:	fb 85       	ldd	r31, Y+11	; 0x0b
    486a:	84 81       	ldd	r24, Z+4	; 0x04
    486c:	95 81       	ldd	r25, Z+5	; 0x05
    486e:	13 96       	adiw	r26, 0x03	; 3
    4870:	9c 93       	st	X, r25
    4872:	8e 93       	st	-X, r24
    4874:	12 97       	sbiw	r26, 0x02	; 2
    4876:	ed 81       	ldd	r30, Y+5	; 0x05
    4878:	fe 81       	ldd	r31, Y+6	; 0x06
    487a:	21 81       	ldd	r18, Z+1	; 0x01
    487c:	32 81       	ldd	r19, Z+2	; 0x02
    487e:	8a 85       	ldd	r24, Y+10	; 0x0a
    4880:	9b 85       	ldd	r25, Y+11	; 0x0b
    4882:	02 96       	adiw	r24, 0x02	; 2
    4884:	28 17       	cp	r18, r24
    4886:	39 07       	cpc	r19, r25
    4888:	41 f4       	brne	.+16     	; 0x489a <xTaskGenericNotifyFromISR+0x26c>
    488a:	ea 85       	ldd	r30, Y+10	; 0x0a
    488c:	fb 85       	ldd	r31, Y+11	; 0x0b
    488e:	86 81       	ldd	r24, Z+6	; 0x06
    4890:	97 81       	ldd	r25, Z+7	; 0x07
    4892:	ed 81       	ldd	r30, Y+5	; 0x05
    4894:	fe 81       	ldd	r31, Y+6	; 0x06
    4896:	92 83       	std	Z+2, r25	; 0x02
    4898:	81 83       	std	Z+1, r24	; 0x01
    489a:	ea 85       	ldd	r30, Y+10	; 0x0a
    489c:	fb 85       	ldd	r31, Y+11	; 0x0b
    489e:	13 86       	std	Z+11, r1	; 0x0b
    48a0:	12 86       	std	Z+10, r1	; 0x0a
    48a2:	ed 81       	ldd	r30, Y+5	; 0x05
    48a4:	fe 81       	ldd	r31, Y+6	; 0x06
    48a6:	80 81       	ld	r24, Z
    48a8:	81 50       	subi	r24, 0x01	; 1
    48aa:	ed 81       	ldd	r30, Y+5	; 0x05
    48ac:	fe 81       	ldd	r31, Y+6	; 0x06
    48ae:	80 83       	st	Z, r24
                    prvAddTaskToReadyList( pxTCB );
    48b0:	ea 85       	ldd	r30, Y+10	; 0x0a
    48b2:	fb 85       	ldd	r31, Y+11	; 0x0b
    48b4:	96 89       	ldd	r25, Z+22	; 0x16
    48b6:	80 91 34 07 	lds	r24, 0x0734
    48ba:	89 17       	cp	r24, r25
    48bc:	28 f4       	brcc	.+10     	; 0x48c8 <xTaskGenericNotifyFromISR+0x29a>
    48be:	ea 85       	ldd	r30, Y+10	; 0x0a
    48c0:	fb 85       	ldd	r31, Y+11	; 0x0b
    48c2:	86 89       	ldd	r24, Z+22	; 0x16
    48c4:	80 93 34 07 	sts	0x0734, r24
    48c8:	ea 85       	ldd	r30, Y+10	; 0x0a
    48ca:	fb 85       	ldd	r31, Y+11	; 0x0b
    48cc:	86 89       	ldd	r24, Z+22	; 0x16
    48ce:	28 2f       	mov	r18, r24
    48d0:	30 e0       	ldi	r19, 0x00	; 0
    48d2:	c9 01       	movw	r24, r18
    48d4:	88 0f       	add	r24, r24
    48d6:	99 1f       	adc	r25, r25
    48d8:	88 0f       	add	r24, r24
    48da:	99 1f       	adc	r25, r25
    48dc:	88 0f       	add	r24, r24
    48de:	99 1f       	adc	r25, r25
    48e0:	82 0f       	add	r24, r18
    48e2:	93 1f       	adc	r25, r19
    48e4:	fc 01       	movw	r30, r24
    48e6:	e0 5c       	subi	r30, 0xC0	; 192
    48e8:	f8 4f       	sbci	r31, 0xF8	; 248
    48ea:	81 81       	ldd	r24, Z+1	; 0x01
    48ec:	92 81       	ldd	r25, Z+2	; 0x02
    48ee:	9c 83       	std	Y+4, r25	; 0x04
    48f0:	8b 83       	std	Y+3, r24	; 0x03
    48f2:	ea 85       	ldd	r30, Y+10	; 0x0a
    48f4:	fb 85       	ldd	r31, Y+11	; 0x0b
    48f6:	8b 81       	ldd	r24, Y+3	; 0x03
    48f8:	9c 81       	ldd	r25, Y+4	; 0x04
    48fa:	95 83       	std	Z+5, r25	; 0x05
    48fc:	84 83       	std	Z+4, r24	; 0x04
    48fe:	eb 81       	ldd	r30, Y+3	; 0x03
    4900:	fc 81       	ldd	r31, Y+4	; 0x04
    4902:	84 81       	ldd	r24, Z+4	; 0x04
    4904:	95 81       	ldd	r25, Z+5	; 0x05
    4906:	ea 85       	ldd	r30, Y+10	; 0x0a
    4908:	fb 85       	ldd	r31, Y+11	; 0x0b
    490a:	97 83       	std	Z+7, r25	; 0x07
    490c:	86 83       	std	Z+6, r24	; 0x06
    490e:	eb 81       	ldd	r30, Y+3	; 0x03
    4910:	fc 81       	ldd	r31, Y+4	; 0x04
    4912:	04 80       	ldd	r0, Z+4	; 0x04
    4914:	f5 81       	ldd	r31, Z+5	; 0x05
    4916:	e0 2d       	mov	r30, r0
    4918:	8a 85       	ldd	r24, Y+10	; 0x0a
    491a:	9b 85       	ldd	r25, Y+11	; 0x0b
    491c:	02 96       	adiw	r24, 0x02	; 2
    491e:	93 83       	std	Z+3, r25	; 0x03
    4920:	82 83       	std	Z+2, r24	; 0x02
    4922:	8a 85       	ldd	r24, Y+10	; 0x0a
    4924:	9b 85       	ldd	r25, Y+11	; 0x0b
    4926:	02 96       	adiw	r24, 0x02	; 2
    4928:	eb 81       	ldd	r30, Y+3	; 0x03
    492a:	fc 81       	ldd	r31, Y+4	; 0x04
    492c:	95 83       	std	Z+5, r25	; 0x05
    492e:	84 83       	std	Z+4, r24	; 0x04
    4930:	ea 85       	ldd	r30, Y+10	; 0x0a
    4932:	fb 85       	ldd	r31, Y+11	; 0x0b
    4934:	86 89       	ldd	r24, Z+22	; 0x16
    4936:	28 2f       	mov	r18, r24
    4938:	30 e0       	ldi	r19, 0x00	; 0
    493a:	c9 01       	movw	r24, r18
    493c:	88 0f       	add	r24, r24
    493e:	99 1f       	adc	r25, r25
    4940:	88 0f       	add	r24, r24
    4942:	99 1f       	adc	r25, r25
    4944:	88 0f       	add	r24, r24
    4946:	99 1f       	adc	r25, r25
    4948:	82 0f       	add	r24, r18
    494a:	93 1f       	adc	r25, r19
    494c:	80 5c       	subi	r24, 0xC0	; 192
    494e:	98 4f       	sbci	r25, 0xF8	; 248
    4950:	ea 85       	ldd	r30, Y+10	; 0x0a
    4952:	fb 85       	ldd	r31, Y+11	; 0x0b
    4954:	93 87       	std	Z+11, r25	; 0x0b
    4956:	82 87       	std	Z+10, r24	; 0x0a
    4958:	ea 85       	ldd	r30, Y+10	; 0x0a
    495a:	fb 85       	ldd	r31, Y+11	; 0x0b
    495c:	86 89       	ldd	r24, Z+22	; 0x16
    495e:	28 2f       	mov	r18, r24
    4960:	30 e0       	ldi	r19, 0x00	; 0
    4962:	c9 01       	movw	r24, r18
    4964:	88 0f       	add	r24, r24
    4966:	99 1f       	adc	r25, r25
    4968:	88 0f       	add	r24, r24
    496a:	99 1f       	adc	r25, r25
    496c:	88 0f       	add	r24, r24
    496e:	99 1f       	adc	r25, r25
    4970:	82 0f       	add	r24, r18
    4972:	93 1f       	adc	r25, r19
    4974:	fc 01       	movw	r30, r24
    4976:	e0 5c       	subi	r30, 0xC0	; 192
    4978:	f8 4f       	sbci	r31, 0xF8	; 248
    497a:	80 81       	ld	r24, Z
    497c:	8f 5f       	subi	r24, 0xFF	; 255
    497e:	80 83       	st	Z, r24
    4980:	30 c0       	rjmp	.+96     	; 0x49e2 <xTaskGenericNotifyFromISR+0x3b4>
                }
                else
                {
                    /* The delayed and ready lists cannot be accessed, so hold
                     * this task pending until the scheduler is resumed. */
                    listINSERT_END( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    4982:	80 91 7b 07 	lds	r24, 0x077B
    4986:	90 91 7c 07 	lds	r25, 0x077C
    498a:	9a 83       	std	Y+2, r25	; 0x02
    498c:	89 83       	std	Y+1, r24	; 0x01
    498e:	ea 85       	ldd	r30, Y+10	; 0x0a
    4990:	fb 85       	ldd	r31, Y+11	; 0x0b
    4992:	89 81       	ldd	r24, Y+1	; 0x01
    4994:	9a 81       	ldd	r25, Y+2	; 0x02
    4996:	97 87       	std	Z+15, r25	; 0x0f
    4998:	86 87       	std	Z+14, r24	; 0x0e
    499a:	e9 81       	ldd	r30, Y+1	; 0x01
    499c:	fa 81       	ldd	r31, Y+2	; 0x02
    499e:	84 81       	ldd	r24, Z+4	; 0x04
    49a0:	95 81       	ldd	r25, Z+5	; 0x05
    49a2:	ea 85       	ldd	r30, Y+10	; 0x0a
    49a4:	fb 85       	ldd	r31, Y+11	; 0x0b
    49a6:	91 8b       	std	Z+17, r25	; 0x11
    49a8:	80 8b       	std	Z+16, r24	; 0x10
    49aa:	e9 81       	ldd	r30, Y+1	; 0x01
    49ac:	fa 81       	ldd	r31, Y+2	; 0x02
    49ae:	04 80       	ldd	r0, Z+4	; 0x04
    49b0:	f5 81       	ldd	r31, Z+5	; 0x05
    49b2:	e0 2d       	mov	r30, r0
    49b4:	8a 85       	ldd	r24, Y+10	; 0x0a
    49b6:	9b 85       	ldd	r25, Y+11	; 0x0b
    49b8:	0c 96       	adiw	r24, 0x0c	; 12
    49ba:	93 83       	std	Z+3, r25	; 0x03
    49bc:	82 83       	std	Z+2, r24	; 0x02
    49be:	8a 85       	ldd	r24, Y+10	; 0x0a
    49c0:	9b 85       	ldd	r25, Y+11	; 0x0b
    49c2:	0c 96       	adiw	r24, 0x0c	; 12
    49c4:	e9 81       	ldd	r30, Y+1	; 0x01
    49c6:	fa 81       	ldd	r31, Y+2	; 0x02
    49c8:	95 83       	std	Z+5, r25	; 0x05
    49ca:	84 83       	std	Z+4, r24	; 0x04
    49cc:	ea 85       	ldd	r30, Y+10	; 0x0a
    49ce:	fb 85       	ldd	r31, Y+11	; 0x0b
    49d0:	8a e7       	ldi	r24, 0x7A	; 122
    49d2:	97 e0       	ldi	r25, 0x07	; 7
    49d4:	95 8b       	std	Z+21, r25	; 0x15
    49d6:	84 8b       	std	Z+20, r24	; 0x14
    49d8:	80 91 7a 07 	lds	r24, 0x077A
    49dc:	8f 5f       	subi	r24, 0xFF	; 255
    49de:	80 93 7a 07 	sts	0x077A, r24
                }

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    49e2:	ea 85       	ldd	r30, Y+10	; 0x0a
    49e4:	fb 85       	ldd	r31, Y+11	; 0x0b
    49e6:	96 89       	ldd	r25, Z+22	; 0x16
    49e8:	e0 91 2e 07 	lds	r30, 0x072E
    49ec:	f0 91 2f 07 	lds	r31, 0x072F
    49f0:	86 89       	ldd	r24, Z+22	; 0x16
    49f2:	89 17       	cp	r24, r25
    49f4:	58 f4       	brcc	.+22     	; 0x4a0c <xTaskGenericNotifyFromISR+0x3de>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    if( pxHigherPriorityTaskWoken != NULL )
    49f6:	8e 89       	ldd	r24, Y+22	; 0x16
    49f8:	9f 89       	ldd	r25, Y+23	; 0x17
    49fa:	00 97       	sbiw	r24, 0x00	; 0
    49fc:	21 f0       	breq	.+8      	; 0x4a06 <xTaskGenericNotifyFromISR+0x3d8>
                    {
                        *pxHigherPriorityTaskWoken = pdTRUE;
    49fe:	ee 89       	ldd	r30, Y+22	; 0x16
    4a00:	ff 89       	ldd	r31, Y+23	; 0x17
    4a02:	81 e0       	ldi	r24, 0x01	; 1
    4a04:	80 83       	st	Z, r24
                    }

                    /* Mark that a yield is pending in case the user is not
                     * using the "xHigherPriorityTaskWoken" parameter to an ISR
                     * safe FreeRTOS function. */
                    xYieldPending = pdTRUE;
    4a06:	81 e0       	ldi	r24, 0x01	; 1
    4a08:	80 93 38 07 	sts	0x0738, r24
                }
            }
        }
        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

        return xReturn;
    4a0c:	88 85       	ldd	r24, Y+8	; 0x08
    }
    4a0e:	69 96       	adiw	r28, 0x19	; 25
    4a10:	0f b6       	in	r0, 0x3f	; 63
    4a12:	f8 94       	cli
    4a14:	de bf       	out	0x3e, r29	; 62
    4a16:	0f be       	out	0x3f, r0	; 63
    4a18:	cd bf       	out	0x3d, r28	; 61
    4a1a:	cf 91       	pop	r28
    4a1c:	df 91       	pop	r29
    4a1e:	1f 91       	pop	r17
    4a20:	0f 91       	pop	r16
    4a22:	ff 90       	pop	r15
    4a24:	ef 90       	pop	r14
    4a26:	df 90       	pop	r13
    4a28:	cf 90       	pop	r12
    4a2a:	08 95       	ret

00004a2c <vTaskGenericNotifyGiveFromISR>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    void vTaskGenericNotifyGiveFromISR( TaskHandle_t xTaskToNotify,
                                        UBaseType_t uxIndexToNotify,
                                        BaseType_t * pxHigherPriorityTaskWoken )
    {
    4a2c:	0f 93       	push	r16
    4a2e:	1f 93       	push	r17
    4a30:	df 93       	push	r29
    4a32:	cf 93       	push	r28
    4a34:	cd b7       	in	r28, 0x3d	; 61
    4a36:	de b7       	in	r29, 0x3e	; 62
    4a38:	2f 97       	sbiw	r28, 0x0f	; 15
    4a3a:	0f b6       	in	r0, 0x3f	; 63
    4a3c:	f8 94       	cli
    4a3e:	de bf       	out	0x3e, r29	; 62
    4a40:	0f be       	out	0x3f, r0	; 63
    4a42:	cd bf       	out	0x3d, r28	; 61
    4a44:	9c 87       	std	Y+12, r25	; 0x0c
    4a46:	8b 87       	std	Y+11, r24	; 0x0b
    4a48:	6d 87       	std	Y+13, r22	; 0x0d
    4a4a:	5f 87       	std	Y+15, r21	; 0x0f
    4a4c:	4e 87       	std	Y+14, r20	; 0x0e
         * simple as possible.  More information (albeit Cortex-M specific) is
         * provided on the following link:
         * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
        portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

        pxTCB = xTaskToNotify;
    4a4e:	8b 85       	ldd	r24, Y+11	; 0x0b
    4a50:	9c 85       	ldd	r25, Y+12	; 0x0c
    4a52:	9a 87       	std	Y+10, r25	; 0x0a
    4a54:	89 87       	std	Y+9, r24	; 0x09

        uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    4a56:	1f 82       	std	Y+7, r1	; 0x07
        {
            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
    4a58:	8d 85       	ldd	r24, Y+13	; 0x0d
    4a5a:	28 2f       	mov	r18, r24
    4a5c:	30 e0       	ldi	r19, 0x00	; 0
    4a5e:	89 85       	ldd	r24, Y+9	; 0x09
    4a60:	9a 85       	ldd	r25, Y+10	; 0x0a
    4a62:	82 0f       	add	r24, r18
    4a64:	93 1f       	adc	r25, r19
    4a66:	fc 01       	movw	r30, r24
    4a68:	b5 96       	adiw	r30, 0x25	; 37
    4a6a:	80 81       	ld	r24, Z
    4a6c:	88 87       	std	Y+8, r24	; 0x08
            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
    4a6e:	8d 85       	ldd	r24, Y+13	; 0x0d
    4a70:	28 2f       	mov	r18, r24
    4a72:	30 e0       	ldi	r19, 0x00	; 0
    4a74:	89 85       	ldd	r24, Y+9	; 0x09
    4a76:	9a 85       	ldd	r25, Y+10	; 0x0a
    4a78:	82 0f       	add	r24, r18
    4a7a:	93 1f       	adc	r25, r19
    4a7c:	fc 01       	movw	r30, r24
    4a7e:	b5 96       	adiw	r30, 0x25	; 37
    4a80:	82 e0       	ldi	r24, 0x02	; 2
    4a82:	80 83       	st	Z, r24

            /* 'Giving' is equivalent to incrementing a count in a counting
             * semaphore. */
            ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
    4a84:	8d 85       	ldd	r24, Y+13	; 0x0d
    4a86:	08 2f       	mov	r16, r24
    4a88:	10 e0       	ldi	r17, 0x00	; 0
    4a8a:	29 85       	ldd	r18, Y+9	; 0x09
    4a8c:	3a 85       	ldd	r19, Y+10	; 0x0a
    4a8e:	c8 01       	movw	r24, r16
    4a90:	88 0f       	add	r24, r24
    4a92:	99 1f       	adc	r25, r25
    4a94:	88 0f       	add	r24, r24
    4a96:	99 1f       	adc	r25, r25
    4a98:	82 0f       	add	r24, r18
    4a9a:	93 1f       	adc	r25, r19
    4a9c:	fc 01       	movw	r30, r24
    4a9e:	b1 96       	adiw	r30, 0x21	; 33
    4aa0:	80 81       	ld	r24, Z
    4aa2:	91 81       	ldd	r25, Z+1	; 0x01
    4aa4:	a2 81       	ldd	r26, Z+2	; 0x02
    4aa6:	b3 81       	ldd	r27, Z+3	; 0x03
    4aa8:	ac 01       	movw	r20, r24
    4aaa:	bd 01       	movw	r22, r26
    4aac:	4f 5f       	subi	r20, 0xFF	; 255
    4aae:	5f 4f       	sbci	r21, 0xFF	; 255
    4ab0:	6f 4f       	sbci	r22, 0xFF	; 255
    4ab2:	7f 4f       	sbci	r23, 0xFF	; 255
    4ab4:	29 85       	ldd	r18, Y+9	; 0x09
    4ab6:	3a 85       	ldd	r19, Y+10	; 0x0a
    4ab8:	c8 01       	movw	r24, r16
    4aba:	88 0f       	add	r24, r24
    4abc:	99 1f       	adc	r25, r25
    4abe:	88 0f       	add	r24, r24
    4ac0:	99 1f       	adc	r25, r25
    4ac2:	82 0f       	add	r24, r18
    4ac4:	93 1f       	adc	r25, r19
    4ac6:	fc 01       	movw	r30, r24
    4ac8:	b1 96       	adiw	r30, 0x21	; 33
    4aca:	40 83       	st	Z, r20
    4acc:	51 83       	std	Z+1, r21	; 0x01
    4ace:	62 83       	std	Z+2, r22	; 0x02
    4ad0:	73 83       	std	Z+3, r23	; 0x03

            traceTASK_NOTIFY_GIVE_FROM_ISR( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    4ad2:	88 85       	ldd	r24, Y+8	; 0x08
    4ad4:	81 30       	cpi	r24, 0x01	; 1
    4ad6:	09 f0       	breq	.+2      	; 0x4ada <vTaskGenericNotifyGiveFromISR+0xae>
    4ad8:	ee c0       	rjmp	.+476    	; 0x4cb6 <vTaskGenericNotifyGiveFromISR+0x28a>
            {
                /* The task should not have been on an event list. */
                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

                if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    4ada:	80 91 3f 07 	lds	r24, 0x073F
    4ade:	88 23       	and	r24, r24
    4ae0:	09 f0       	breq	.+2      	; 0x4ae4 <vTaskGenericNotifyGiveFromISR+0xb8>
    4ae2:	a4 c0       	rjmp	.+328    	; 0x4c2c <vTaskGenericNotifyGiveFromISR+0x200>
                {
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    4ae4:	e9 85       	ldd	r30, Y+9	; 0x09
    4ae6:	fa 85       	ldd	r31, Y+10	; 0x0a
    4ae8:	82 85       	ldd	r24, Z+10	; 0x0a
    4aea:	93 85       	ldd	r25, Z+11	; 0x0b
    4aec:	9e 83       	std	Y+6, r25	; 0x06
    4aee:	8d 83       	std	Y+5, r24	; 0x05
    4af0:	e9 85       	ldd	r30, Y+9	; 0x09
    4af2:	fa 85       	ldd	r31, Y+10	; 0x0a
    4af4:	a4 81       	ldd	r26, Z+4	; 0x04
    4af6:	b5 81       	ldd	r27, Z+5	; 0x05
    4af8:	e9 85       	ldd	r30, Y+9	; 0x09
    4afa:	fa 85       	ldd	r31, Y+10	; 0x0a
    4afc:	86 81       	ldd	r24, Z+6	; 0x06
    4afe:	97 81       	ldd	r25, Z+7	; 0x07
    4b00:	15 96       	adiw	r26, 0x05	; 5
    4b02:	9c 93       	st	X, r25
    4b04:	8e 93       	st	-X, r24
    4b06:	14 97       	sbiw	r26, 0x04	; 4
    4b08:	e9 85       	ldd	r30, Y+9	; 0x09
    4b0a:	fa 85       	ldd	r31, Y+10	; 0x0a
    4b0c:	a6 81       	ldd	r26, Z+6	; 0x06
    4b0e:	b7 81       	ldd	r27, Z+7	; 0x07
    4b10:	e9 85       	ldd	r30, Y+9	; 0x09
    4b12:	fa 85       	ldd	r31, Y+10	; 0x0a
    4b14:	84 81       	ldd	r24, Z+4	; 0x04
    4b16:	95 81       	ldd	r25, Z+5	; 0x05
    4b18:	13 96       	adiw	r26, 0x03	; 3
    4b1a:	9c 93       	st	X, r25
    4b1c:	8e 93       	st	-X, r24
    4b1e:	12 97       	sbiw	r26, 0x02	; 2
    4b20:	ed 81       	ldd	r30, Y+5	; 0x05
    4b22:	fe 81       	ldd	r31, Y+6	; 0x06
    4b24:	21 81       	ldd	r18, Z+1	; 0x01
    4b26:	32 81       	ldd	r19, Z+2	; 0x02
    4b28:	89 85       	ldd	r24, Y+9	; 0x09
    4b2a:	9a 85       	ldd	r25, Y+10	; 0x0a
    4b2c:	02 96       	adiw	r24, 0x02	; 2
    4b2e:	28 17       	cp	r18, r24
    4b30:	39 07       	cpc	r19, r25
    4b32:	41 f4       	brne	.+16     	; 0x4b44 <vTaskGenericNotifyGiveFromISR+0x118>
    4b34:	e9 85       	ldd	r30, Y+9	; 0x09
    4b36:	fa 85       	ldd	r31, Y+10	; 0x0a
    4b38:	86 81       	ldd	r24, Z+6	; 0x06
    4b3a:	97 81       	ldd	r25, Z+7	; 0x07
    4b3c:	ed 81       	ldd	r30, Y+5	; 0x05
    4b3e:	fe 81       	ldd	r31, Y+6	; 0x06
    4b40:	92 83       	std	Z+2, r25	; 0x02
    4b42:	81 83       	std	Z+1, r24	; 0x01
    4b44:	e9 85       	ldd	r30, Y+9	; 0x09
    4b46:	fa 85       	ldd	r31, Y+10	; 0x0a
    4b48:	13 86       	std	Z+11, r1	; 0x0b
    4b4a:	12 86       	std	Z+10, r1	; 0x0a
    4b4c:	ed 81       	ldd	r30, Y+5	; 0x05
    4b4e:	fe 81       	ldd	r31, Y+6	; 0x06
    4b50:	80 81       	ld	r24, Z
    4b52:	81 50       	subi	r24, 0x01	; 1
    4b54:	ed 81       	ldd	r30, Y+5	; 0x05
    4b56:	fe 81       	ldd	r31, Y+6	; 0x06
    4b58:	80 83       	st	Z, r24
                    prvAddTaskToReadyList( pxTCB );
    4b5a:	e9 85       	ldd	r30, Y+9	; 0x09
    4b5c:	fa 85       	ldd	r31, Y+10	; 0x0a
    4b5e:	96 89       	ldd	r25, Z+22	; 0x16
    4b60:	80 91 34 07 	lds	r24, 0x0734
    4b64:	89 17       	cp	r24, r25
    4b66:	28 f4       	brcc	.+10     	; 0x4b72 <vTaskGenericNotifyGiveFromISR+0x146>
    4b68:	e9 85       	ldd	r30, Y+9	; 0x09
    4b6a:	fa 85       	ldd	r31, Y+10	; 0x0a
    4b6c:	86 89       	ldd	r24, Z+22	; 0x16
    4b6e:	80 93 34 07 	sts	0x0734, r24
    4b72:	e9 85       	ldd	r30, Y+9	; 0x09
    4b74:	fa 85       	ldd	r31, Y+10	; 0x0a
    4b76:	86 89       	ldd	r24, Z+22	; 0x16
    4b78:	28 2f       	mov	r18, r24
    4b7a:	30 e0       	ldi	r19, 0x00	; 0
    4b7c:	c9 01       	movw	r24, r18
    4b7e:	88 0f       	add	r24, r24
    4b80:	99 1f       	adc	r25, r25
    4b82:	88 0f       	add	r24, r24
    4b84:	99 1f       	adc	r25, r25
    4b86:	88 0f       	add	r24, r24
    4b88:	99 1f       	adc	r25, r25
    4b8a:	82 0f       	add	r24, r18
    4b8c:	93 1f       	adc	r25, r19
    4b8e:	fc 01       	movw	r30, r24
    4b90:	e0 5c       	subi	r30, 0xC0	; 192
    4b92:	f8 4f       	sbci	r31, 0xF8	; 248
    4b94:	81 81       	ldd	r24, Z+1	; 0x01
    4b96:	92 81       	ldd	r25, Z+2	; 0x02
    4b98:	9c 83       	std	Y+4, r25	; 0x04
    4b9a:	8b 83       	std	Y+3, r24	; 0x03
    4b9c:	e9 85       	ldd	r30, Y+9	; 0x09
    4b9e:	fa 85       	ldd	r31, Y+10	; 0x0a
    4ba0:	8b 81       	ldd	r24, Y+3	; 0x03
    4ba2:	9c 81       	ldd	r25, Y+4	; 0x04
    4ba4:	95 83       	std	Z+5, r25	; 0x05
    4ba6:	84 83       	std	Z+4, r24	; 0x04
    4ba8:	eb 81       	ldd	r30, Y+3	; 0x03
    4baa:	fc 81       	ldd	r31, Y+4	; 0x04
    4bac:	84 81       	ldd	r24, Z+4	; 0x04
    4bae:	95 81       	ldd	r25, Z+5	; 0x05
    4bb0:	e9 85       	ldd	r30, Y+9	; 0x09
    4bb2:	fa 85       	ldd	r31, Y+10	; 0x0a
    4bb4:	97 83       	std	Z+7, r25	; 0x07
    4bb6:	86 83       	std	Z+6, r24	; 0x06
    4bb8:	eb 81       	ldd	r30, Y+3	; 0x03
    4bba:	fc 81       	ldd	r31, Y+4	; 0x04
    4bbc:	04 80       	ldd	r0, Z+4	; 0x04
    4bbe:	f5 81       	ldd	r31, Z+5	; 0x05
    4bc0:	e0 2d       	mov	r30, r0
    4bc2:	89 85       	ldd	r24, Y+9	; 0x09
    4bc4:	9a 85       	ldd	r25, Y+10	; 0x0a
    4bc6:	02 96       	adiw	r24, 0x02	; 2
    4bc8:	93 83       	std	Z+3, r25	; 0x03
    4bca:	82 83       	std	Z+2, r24	; 0x02
    4bcc:	89 85       	ldd	r24, Y+9	; 0x09
    4bce:	9a 85       	ldd	r25, Y+10	; 0x0a
    4bd0:	02 96       	adiw	r24, 0x02	; 2
    4bd2:	eb 81       	ldd	r30, Y+3	; 0x03
    4bd4:	fc 81       	ldd	r31, Y+4	; 0x04
    4bd6:	95 83       	std	Z+5, r25	; 0x05
    4bd8:	84 83       	std	Z+4, r24	; 0x04
    4bda:	e9 85       	ldd	r30, Y+9	; 0x09
    4bdc:	fa 85       	ldd	r31, Y+10	; 0x0a
    4bde:	86 89       	ldd	r24, Z+22	; 0x16
    4be0:	28 2f       	mov	r18, r24
    4be2:	30 e0       	ldi	r19, 0x00	; 0
    4be4:	c9 01       	movw	r24, r18
    4be6:	88 0f       	add	r24, r24
    4be8:	99 1f       	adc	r25, r25
    4bea:	88 0f       	add	r24, r24
    4bec:	99 1f       	adc	r25, r25
    4bee:	88 0f       	add	r24, r24
    4bf0:	99 1f       	adc	r25, r25
    4bf2:	82 0f       	add	r24, r18
    4bf4:	93 1f       	adc	r25, r19
    4bf6:	80 5c       	subi	r24, 0xC0	; 192
    4bf8:	98 4f       	sbci	r25, 0xF8	; 248
    4bfa:	e9 85       	ldd	r30, Y+9	; 0x09
    4bfc:	fa 85       	ldd	r31, Y+10	; 0x0a
    4bfe:	93 87       	std	Z+11, r25	; 0x0b
    4c00:	82 87       	std	Z+10, r24	; 0x0a
    4c02:	e9 85       	ldd	r30, Y+9	; 0x09
    4c04:	fa 85       	ldd	r31, Y+10	; 0x0a
    4c06:	86 89       	ldd	r24, Z+22	; 0x16
    4c08:	28 2f       	mov	r18, r24
    4c0a:	30 e0       	ldi	r19, 0x00	; 0
    4c0c:	c9 01       	movw	r24, r18
    4c0e:	88 0f       	add	r24, r24
    4c10:	99 1f       	adc	r25, r25
    4c12:	88 0f       	add	r24, r24
    4c14:	99 1f       	adc	r25, r25
    4c16:	88 0f       	add	r24, r24
    4c18:	99 1f       	adc	r25, r25
    4c1a:	82 0f       	add	r24, r18
    4c1c:	93 1f       	adc	r25, r19
    4c1e:	fc 01       	movw	r30, r24
    4c20:	e0 5c       	subi	r30, 0xC0	; 192
    4c22:	f8 4f       	sbci	r31, 0xF8	; 248
    4c24:	80 81       	ld	r24, Z
    4c26:	8f 5f       	subi	r24, 0xFF	; 255
    4c28:	80 83       	st	Z, r24
    4c2a:	30 c0       	rjmp	.+96     	; 0x4c8c <vTaskGenericNotifyGiveFromISR+0x260>
                }
                else
                {
                    /* The delayed and ready lists cannot be accessed, so hold
                     * this task pending until the scheduler is resumed. */
                    listINSERT_END( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    4c2c:	80 91 7b 07 	lds	r24, 0x077B
    4c30:	90 91 7c 07 	lds	r25, 0x077C
    4c34:	9a 83       	std	Y+2, r25	; 0x02
    4c36:	89 83       	std	Y+1, r24	; 0x01
    4c38:	e9 85       	ldd	r30, Y+9	; 0x09
    4c3a:	fa 85       	ldd	r31, Y+10	; 0x0a
    4c3c:	89 81       	ldd	r24, Y+1	; 0x01
    4c3e:	9a 81       	ldd	r25, Y+2	; 0x02
    4c40:	97 87       	std	Z+15, r25	; 0x0f
    4c42:	86 87       	std	Z+14, r24	; 0x0e
    4c44:	e9 81       	ldd	r30, Y+1	; 0x01
    4c46:	fa 81       	ldd	r31, Y+2	; 0x02
    4c48:	84 81       	ldd	r24, Z+4	; 0x04
    4c4a:	95 81       	ldd	r25, Z+5	; 0x05
    4c4c:	e9 85       	ldd	r30, Y+9	; 0x09
    4c4e:	fa 85       	ldd	r31, Y+10	; 0x0a
    4c50:	91 8b       	std	Z+17, r25	; 0x11
    4c52:	80 8b       	std	Z+16, r24	; 0x10
    4c54:	e9 81       	ldd	r30, Y+1	; 0x01
    4c56:	fa 81       	ldd	r31, Y+2	; 0x02
    4c58:	04 80       	ldd	r0, Z+4	; 0x04
    4c5a:	f5 81       	ldd	r31, Z+5	; 0x05
    4c5c:	e0 2d       	mov	r30, r0
    4c5e:	89 85       	ldd	r24, Y+9	; 0x09
    4c60:	9a 85       	ldd	r25, Y+10	; 0x0a
    4c62:	0c 96       	adiw	r24, 0x0c	; 12
    4c64:	93 83       	std	Z+3, r25	; 0x03
    4c66:	82 83       	std	Z+2, r24	; 0x02
    4c68:	89 85       	ldd	r24, Y+9	; 0x09
    4c6a:	9a 85       	ldd	r25, Y+10	; 0x0a
    4c6c:	0c 96       	adiw	r24, 0x0c	; 12
    4c6e:	e9 81       	ldd	r30, Y+1	; 0x01
    4c70:	fa 81       	ldd	r31, Y+2	; 0x02
    4c72:	95 83       	std	Z+5, r25	; 0x05
    4c74:	84 83       	std	Z+4, r24	; 0x04
    4c76:	e9 85       	ldd	r30, Y+9	; 0x09
    4c78:	fa 85       	ldd	r31, Y+10	; 0x0a
    4c7a:	8a e7       	ldi	r24, 0x7A	; 122
    4c7c:	97 e0       	ldi	r25, 0x07	; 7
    4c7e:	95 8b       	std	Z+21, r25	; 0x15
    4c80:	84 8b       	std	Z+20, r24	; 0x14
    4c82:	80 91 7a 07 	lds	r24, 0x077A
    4c86:	8f 5f       	subi	r24, 0xFF	; 255
    4c88:	80 93 7a 07 	sts	0x077A, r24
                }

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    4c8c:	e9 85       	ldd	r30, Y+9	; 0x09
    4c8e:	fa 85       	ldd	r31, Y+10	; 0x0a
    4c90:	96 89       	ldd	r25, Z+22	; 0x16
    4c92:	e0 91 2e 07 	lds	r30, 0x072E
    4c96:	f0 91 2f 07 	lds	r31, 0x072F
    4c9a:	86 89       	ldd	r24, Z+22	; 0x16
    4c9c:	89 17       	cp	r24, r25
    4c9e:	58 f4       	brcc	.+22     	; 0x4cb6 <vTaskGenericNotifyGiveFromISR+0x28a>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    if( pxHigherPriorityTaskWoken != NULL )
    4ca0:	8e 85       	ldd	r24, Y+14	; 0x0e
    4ca2:	9f 85       	ldd	r25, Y+15	; 0x0f
    4ca4:	00 97       	sbiw	r24, 0x00	; 0
    4ca6:	21 f0       	breq	.+8      	; 0x4cb0 <vTaskGenericNotifyGiveFromISR+0x284>
                    {
                        *pxHigherPriorityTaskWoken = pdTRUE;
    4ca8:	ee 85       	ldd	r30, Y+14	; 0x0e
    4caa:	ff 85       	ldd	r31, Y+15	; 0x0f
    4cac:	81 e0       	ldi	r24, 0x01	; 1
    4cae:	80 83       	st	Z, r24
                    }

                    /* Mark that a yield is pending in case the user is not
                     * using the "xHigherPriorityTaskWoken" parameter in an ISR
                     * safe FreeRTOS function. */
                    xYieldPending = pdTRUE;
    4cb0:	81 e0       	ldi	r24, 0x01	; 1
    4cb2:	80 93 38 07 	sts	0x0738, r24
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
    }
    4cb6:	2f 96       	adiw	r28, 0x0f	; 15
    4cb8:	0f b6       	in	r0, 0x3f	; 63
    4cba:	f8 94       	cli
    4cbc:	de bf       	out	0x3e, r29	; 62
    4cbe:	0f be       	out	0x3f, r0	; 63
    4cc0:	cd bf       	out	0x3d, r28	; 61
    4cc2:	cf 91       	pop	r28
    4cc4:	df 91       	pop	r29
    4cc6:	1f 91       	pop	r17
    4cc8:	0f 91       	pop	r16
    4cca:	08 95       	ret

00004ccc <xTaskGenericNotifyStateClear>:

#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    BaseType_t xTaskGenericNotifyStateClear( TaskHandle_t xTask,
                                             UBaseType_t uxIndexToClear )
    {
    4ccc:	df 93       	push	r29
    4cce:	cf 93       	push	r28
    4cd0:	cd b7       	in	r28, 0x3d	; 61
    4cd2:	de b7       	in	r29, 0x3e	; 62
    4cd4:	28 97       	sbiw	r28, 0x08	; 8
    4cd6:	0f b6       	in	r0, 0x3f	; 63
    4cd8:	f8 94       	cli
    4cda:	de bf       	out	0x3e, r29	; 62
    4cdc:	0f be       	out	0x3f, r0	; 63
    4cde:	cd bf       	out	0x3d, r28	; 61
    4ce0:	9d 83       	std	Y+5, r25	; 0x05
    4ce2:	8c 83       	std	Y+4, r24	; 0x04
    4ce4:	6e 83       	std	Y+6, r22	; 0x06

        configASSERT( uxIndexToClear < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        /* If null is passed in here then it is the calling task that is having
         * its notification state cleared. */
        pxTCB = prvGetTCBFromHandle( xTask );
    4ce6:	8c 81       	ldd	r24, Y+4	; 0x04
    4ce8:	9d 81       	ldd	r25, Y+5	; 0x05
    4cea:	00 97       	sbiw	r24, 0x00	; 0
    4cec:	39 f4       	brne	.+14     	; 0x4cfc <xTaskGenericNotifyStateClear+0x30>
    4cee:	80 91 2e 07 	lds	r24, 0x072E
    4cf2:	90 91 2f 07 	lds	r25, 0x072F
    4cf6:	98 87       	std	Y+8, r25	; 0x08
    4cf8:	8f 83       	std	Y+7, r24	; 0x07
    4cfa:	04 c0       	rjmp	.+8      	; 0x4d04 <xTaskGenericNotifyStateClear+0x38>
    4cfc:	8c 81       	ldd	r24, Y+4	; 0x04
    4cfe:	9d 81       	ldd	r25, Y+5	; 0x05
    4d00:	98 87       	std	Y+8, r25	; 0x08
    4d02:	8f 83       	std	Y+7, r24	; 0x07
    4d04:	8f 81       	ldd	r24, Y+7	; 0x07
    4d06:	98 85       	ldd	r25, Y+8	; 0x08
    4d08:	9b 83       	std	Y+3, r25	; 0x03
    4d0a:	8a 83       	std	Y+2, r24	; 0x02

        taskENTER_CRITICAL();
    4d0c:	0f b6       	in	r0, 0x3f	; 63
    4d0e:	f8 94       	cli
    4d10:	0f 92       	push	r0
        {
            if( pxTCB->ucNotifyState[ uxIndexToClear ] == taskNOTIFICATION_RECEIVED )
    4d12:	8e 81       	ldd	r24, Y+6	; 0x06
    4d14:	28 2f       	mov	r18, r24
    4d16:	30 e0       	ldi	r19, 0x00	; 0
    4d18:	8a 81       	ldd	r24, Y+2	; 0x02
    4d1a:	9b 81       	ldd	r25, Y+3	; 0x03
    4d1c:	82 0f       	add	r24, r18
    4d1e:	93 1f       	adc	r25, r19
    4d20:	fc 01       	movw	r30, r24
    4d22:	b5 96       	adiw	r30, 0x25	; 37
    4d24:	80 81       	ld	r24, Z
    4d26:	82 30       	cpi	r24, 0x02	; 2
    4d28:	69 f4       	brne	.+26     	; 0x4d44 <xTaskGenericNotifyStateClear+0x78>
            {
                pxTCB->ucNotifyState[ uxIndexToClear ] = taskNOT_WAITING_NOTIFICATION;
    4d2a:	8e 81       	ldd	r24, Y+6	; 0x06
    4d2c:	28 2f       	mov	r18, r24
    4d2e:	30 e0       	ldi	r19, 0x00	; 0
    4d30:	8a 81       	ldd	r24, Y+2	; 0x02
    4d32:	9b 81       	ldd	r25, Y+3	; 0x03
    4d34:	82 0f       	add	r24, r18
    4d36:	93 1f       	adc	r25, r19
    4d38:	fc 01       	movw	r30, r24
    4d3a:	b5 96       	adiw	r30, 0x25	; 37
    4d3c:	10 82       	st	Z, r1
                xReturn = pdPASS;
    4d3e:	81 e0       	ldi	r24, 0x01	; 1
    4d40:	89 83       	std	Y+1, r24	; 0x01
    4d42:	01 c0       	rjmp	.+2      	; 0x4d46 <xTaskGenericNotifyStateClear+0x7a>
            }
            else
            {
                xReturn = pdFAIL;
    4d44:	19 82       	std	Y+1, r1	; 0x01
            }
        }
        taskEXIT_CRITICAL();
    4d46:	0f 90       	pop	r0
    4d48:	0f be       	out	0x3f, r0	; 63

        return xReturn;
    4d4a:	89 81       	ldd	r24, Y+1	; 0x01
    }
    4d4c:	28 96       	adiw	r28, 0x08	; 8
    4d4e:	0f b6       	in	r0, 0x3f	; 63
    4d50:	f8 94       	cli
    4d52:	de bf       	out	0x3e, r29	; 62
    4d54:	0f be       	out	0x3f, r0	; 63
    4d56:	cd bf       	out	0x3d, r28	; 61
    4d58:	cf 91       	pop	r28
    4d5a:	df 91       	pop	r29
    4d5c:	08 95       	ret

00004d5e <ulTaskGenericNotifyValueClear>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    uint32_t ulTaskGenericNotifyValueClear( TaskHandle_t xTask,
                                            UBaseType_t uxIndexToClear,
                                            uint32_t ulBitsToClear )
    {
    4d5e:	0f 93       	push	r16
    4d60:	1f 93       	push	r17
    4d62:	df 93       	push	r29
    4d64:	cf 93       	push	r28
    4d66:	cd b7       	in	r28, 0x3d	; 61
    4d68:	de b7       	in	r29, 0x3e	; 62
    4d6a:	2f 97       	sbiw	r28, 0x0f	; 15
    4d6c:	0f b6       	in	r0, 0x3f	; 63
    4d6e:	f8 94       	cli
    4d70:	de bf       	out	0x3e, r29	; 62
    4d72:	0f be       	out	0x3f, r0	; 63
    4d74:	cd bf       	out	0x3d, r28	; 61
    4d76:	98 87       	std	Y+8, r25	; 0x08
    4d78:	8f 83       	std	Y+7, r24	; 0x07
    4d7a:	69 87       	std	Y+9, r22	; 0x09
    4d7c:	2a 87       	std	Y+10, r18	; 0x0a
    4d7e:	3b 87       	std	Y+11, r19	; 0x0b
    4d80:	4c 87       	std	Y+12, r20	; 0x0c
    4d82:	5d 87       	std	Y+13, r21	; 0x0d
        TCB_t * pxTCB;
        uint32_t ulReturn;

        /* If null is passed in here then it is the calling task that is having
         * its notification state cleared. */
        pxTCB = prvGetTCBFromHandle( xTask );
    4d84:	8f 81       	ldd	r24, Y+7	; 0x07
    4d86:	98 85       	ldd	r25, Y+8	; 0x08
    4d88:	00 97       	sbiw	r24, 0x00	; 0
    4d8a:	39 f4       	brne	.+14     	; 0x4d9a <ulTaskGenericNotifyValueClear+0x3c>
    4d8c:	80 91 2e 07 	lds	r24, 0x072E
    4d90:	90 91 2f 07 	lds	r25, 0x072F
    4d94:	9f 87       	std	Y+15, r25	; 0x0f
    4d96:	8e 87       	std	Y+14, r24	; 0x0e
    4d98:	04 c0       	rjmp	.+8      	; 0x4da2 <ulTaskGenericNotifyValueClear+0x44>
    4d9a:	8f 81       	ldd	r24, Y+7	; 0x07
    4d9c:	98 85       	ldd	r25, Y+8	; 0x08
    4d9e:	9f 87       	std	Y+15, r25	; 0x0f
    4da0:	8e 87       	std	Y+14, r24	; 0x0e
    4da2:	8e 85       	ldd	r24, Y+14	; 0x0e
    4da4:	9f 85       	ldd	r25, Y+15	; 0x0f
    4da6:	9e 83       	std	Y+6, r25	; 0x06
    4da8:	8d 83       	std	Y+5, r24	; 0x05

        taskENTER_CRITICAL();
    4daa:	0f b6       	in	r0, 0x3f	; 63
    4dac:	f8 94       	cli
    4dae:	0f 92       	push	r0
        {
            /* Return the notification as it was before the bits were cleared,
             * then clear the bit mask. */
            ulReturn = pxTCB->ulNotifiedValue[ uxIndexToClear ];
    4db0:	89 85       	ldd	r24, Y+9	; 0x09
    4db2:	88 2f       	mov	r24, r24
    4db4:	90 e0       	ldi	r25, 0x00	; 0
    4db6:	2d 81       	ldd	r18, Y+5	; 0x05
    4db8:	3e 81       	ldd	r19, Y+6	; 0x06
    4dba:	88 0f       	add	r24, r24
    4dbc:	99 1f       	adc	r25, r25
    4dbe:	88 0f       	add	r24, r24
    4dc0:	99 1f       	adc	r25, r25
    4dc2:	82 0f       	add	r24, r18
    4dc4:	93 1f       	adc	r25, r19
    4dc6:	fc 01       	movw	r30, r24
    4dc8:	b1 96       	adiw	r30, 0x21	; 33
    4dca:	80 81       	ld	r24, Z
    4dcc:	91 81       	ldd	r25, Z+1	; 0x01
    4dce:	a2 81       	ldd	r26, Z+2	; 0x02
    4dd0:	b3 81       	ldd	r27, Z+3	; 0x03
    4dd2:	89 83       	std	Y+1, r24	; 0x01
    4dd4:	9a 83       	std	Y+2, r25	; 0x02
    4dd6:	ab 83       	std	Y+3, r26	; 0x03
    4dd8:	bc 83       	std	Y+4, r27	; 0x04
            pxTCB->ulNotifiedValue[ uxIndexToClear ] &= ~ulBitsToClear;
    4dda:	89 85       	ldd	r24, Y+9	; 0x09
    4ddc:	08 2f       	mov	r16, r24
    4dde:	10 e0       	ldi	r17, 0x00	; 0
    4de0:	89 85       	ldd	r24, Y+9	; 0x09
    4de2:	88 2f       	mov	r24, r24
    4de4:	90 e0       	ldi	r25, 0x00	; 0
    4de6:	2d 81       	ldd	r18, Y+5	; 0x05
    4de8:	3e 81       	ldd	r19, Y+6	; 0x06
    4dea:	88 0f       	add	r24, r24
    4dec:	99 1f       	adc	r25, r25
    4dee:	88 0f       	add	r24, r24
    4df0:	99 1f       	adc	r25, r25
    4df2:	82 0f       	add	r24, r18
    4df4:	93 1f       	adc	r25, r19
    4df6:	fc 01       	movw	r30, r24
    4df8:	b1 96       	adiw	r30, 0x21	; 33
    4dfa:	20 81       	ld	r18, Z
    4dfc:	31 81       	ldd	r19, Z+1	; 0x01
    4dfe:	42 81       	ldd	r20, Z+2	; 0x02
    4e00:	53 81       	ldd	r21, Z+3	; 0x03
    4e02:	8a 85       	ldd	r24, Y+10	; 0x0a
    4e04:	9b 85       	ldd	r25, Y+11	; 0x0b
    4e06:	ac 85       	ldd	r26, Y+12	; 0x0c
    4e08:	bd 85       	ldd	r27, Y+13	; 0x0d
    4e0a:	80 95       	com	r24
    4e0c:	90 95       	com	r25
    4e0e:	a0 95       	com	r26
    4e10:	b0 95       	com	r27
    4e12:	ba 01       	movw	r22, r20
    4e14:	a9 01       	movw	r20, r18
    4e16:	48 23       	and	r20, r24
    4e18:	59 23       	and	r21, r25
    4e1a:	6a 23       	and	r22, r26
    4e1c:	7b 23       	and	r23, r27
    4e1e:	2d 81       	ldd	r18, Y+5	; 0x05
    4e20:	3e 81       	ldd	r19, Y+6	; 0x06
    4e22:	c8 01       	movw	r24, r16
    4e24:	88 0f       	add	r24, r24
    4e26:	99 1f       	adc	r25, r25
    4e28:	88 0f       	add	r24, r24
    4e2a:	99 1f       	adc	r25, r25
    4e2c:	82 0f       	add	r24, r18
    4e2e:	93 1f       	adc	r25, r19
    4e30:	fc 01       	movw	r30, r24
    4e32:	b1 96       	adiw	r30, 0x21	; 33
    4e34:	40 83       	st	Z, r20
    4e36:	51 83       	std	Z+1, r21	; 0x01
    4e38:	62 83       	std	Z+2, r22	; 0x02
    4e3a:	73 83       	std	Z+3, r23	; 0x03
        }
        taskEXIT_CRITICAL();
    4e3c:	0f 90       	pop	r0
    4e3e:	0f be       	out	0x3f, r0	; 63

        return ulReturn;
    4e40:	89 81       	ldd	r24, Y+1	; 0x01
    4e42:	9a 81       	ldd	r25, Y+2	; 0x02
    4e44:	ab 81       	ldd	r26, Y+3	; 0x03
    4e46:	bc 81       	ldd	r27, Y+4	; 0x04
    }
    4e48:	bc 01       	movw	r22, r24
    4e4a:	cd 01       	movw	r24, r26
    4e4c:	2f 96       	adiw	r28, 0x0f	; 15
    4e4e:	0f b6       	in	r0, 0x3f	; 63
    4e50:	f8 94       	cli
    4e52:	de bf       	out	0x3e, r29	; 62
    4e54:	0f be       	out	0x3f, r0	; 63
    4e56:	cd bf       	out	0x3d, r28	; 61
    4e58:	cf 91       	pop	r28
    4e5a:	df 91       	pop	r29
    4e5c:	1f 91       	pop	r17
    4e5e:	0f 91       	pop	r16
    4e60:	08 95       	ret

00004e62 <prvAddCurrentTaskToDelayedList>:
#endif /* if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( INCLUDE_xTaskGetIdleTaskHandle == 1 ) ) */
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait,
                                            const BaseType_t xCanBlockIndefinitely )
{
    4e62:	df 93       	push	r29
    4e64:	cf 93       	push	r28
    4e66:	cd b7       	in	r28, 0x3d	; 61
    4e68:	de b7       	in	r29, 0x3e	; 62
    4e6a:	27 97       	sbiw	r28, 0x07	; 7
    4e6c:	0f b6       	in	r0, 0x3f	; 63
    4e6e:	f8 94       	cli
    4e70:	de bf       	out	0x3e, r29	; 62
    4e72:	0f be       	out	0x3f, r0	; 63
    4e74:	cd bf       	out	0x3d, r28	; 61
    4e76:	9e 83       	std	Y+6, r25	; 0x06
    4e78:	8d 83       	std	Y+5, r24	; 0x05
    4e7a:	6f 83       	std	Y+7, r22	; 0x07
    TickType_t xTimeToWake;
    const TickType_t xConstTickCount = xTickCount;
    4e7c:	80 91 32 07 	lds	r24, 0x0732
    4e80:	90 91 33 07 	lds	r25, 0x0733
    4e84:	9a 83       	std	Y+2, r25	; 0x02
    4e86:	89 83       	std	Y+1, r24	; 0x01
        }
    #endif

    /* Remove the task from the ready list before adding it to the blocked list
     * as the same list item is used for both lists. */
    if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    4e88:	80 91 2e 07 	lds	r24, 0x072E
    4e8c:	90 91 2f 07 	lds	r25, 0x072F
    4e90:	02 96       	adiw	r24, 0x02	; 2
    4e92:	0e 94 c9 0a 	call	0x1592	; 0x1592 <uxListRemove>
    #else /* INCLUDE_vTaskSuspend */
        {
            /* Calculate the time at which the task should be woken if the event
             * does not occur.  This may overflow but this doesn't matter, the kernel
             * will manage it correctly. */
            xTimeToWake = xConstTickCount + xTicksToWait;
    4e96:	29 81       	ldd	r18, Y+1	; 0x01
    4e98:	3a 81       	ldd	r19, Y+2	; 0x02
    4e9a:	8d 81       	ldd	r24, Y+5	; 0x05
    4e9c:	9e 81       	ldd	r25, Y+6	; 0x06
    4e9e:	82 0f       	add	r24, r18
    4ea0:	93 1f       	adc	r25, r19
    4ea2:	9c 83       	std	Y+4, r25	; 0x04
    4ea4:	8b 83       	std	Y+3, r24	; 0x03

            /* The list item will be inserted in wake time order. */
            listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    4ea6:	e0 91 2e 07 	lds	r30, 0x072E
    4eaa:	f0 91 2f 07 	lds	r31, 0x072F
    4eae:	8b 81       	ldd	r24, Y+3	; 0x03
    4eb0:	9c 81       	ldd	r25, Y+4	; 0x04
    4eb2:	93 83       	std	Z+3, r25	; 0x03
    4eb4:	82 83       	std	Z+2, r24	; 0x02

            if( xTimeToWake < xConstTickCount )
    4eb6:	2b 81       	ldd	r18, Y+3	; 0x03
    4eb8:	3c 81       	ldd	r19, Y+4	; 0x04
    4eba:	89 81       	ldd	r24, Y+1	; 0x01
    4ebc:	9a 81       	ldd	r25, Y+2	; 0x02
    4ebe:	28 17       	cp	r18, r24
    4ec0:	39 07       	cpc	r19, r25
    4ec2:	70 f4       	brcc	.+28     	; 0x4ee0 <prvAddCurrentTaskToDelayedList+0x7e>
            {
                /* Wake time has overflowed.  Place this item in the overflow list. */
                vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    4ec4:	80 91 78 07 	lds	r24, 0x0778
    4ec8:	90 91 79 07 	lds	r25, 0x0779
    4ecc:	20 91 2e 07 	lds	r18, 0x072E
    4ed0:	30 91 2f 07 	lds	r19, 0x072F
    4ed4:	2e 5f       	subi	r18, 0xFE	; 254
    4ed6:	3f 4f       	sbci	r19, 0xFF	; 255
    4ed8:	b9 01       	movw	r22, r18
    4eda:	0e 94 5d 0a 	call	0x14ba	; 0x14ba <vListInsert>
    4ede:	1e c0       	rjmp	.+60     	; 0x4f1c <prvAddCurrentTaskToDelayedList+0xba>
            }
            else
            {
                /* The wake time has not overflowed, so the current block list is used. */
                vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    4ee0:	40 91 76 07 	lds	r20, 0x0776
    4ee4:	50 91 77 07 	lds	r21, 0x0777
    4ee8:	80 91 2e 07 	lds	r24, 0x072E
    4eec:	90 91 2f 07 	lds	r25, 0x072F
    4ef0:	9c 01       	movw	r18, r24
    4ef2:	2e 5f       	subi	r18, 0xFE	; 254
    4ef4:	3f 4f       	sbci	r19, 0xFF	; 255
    4ef6:	ca 01       	movw	r24, r20
    4ef8:	b9 01       	movw	r22, r18
    4efa:	0e 94 5d 0a 	call	0x14ba	; 0x14ba <vListInsert>

                /* If the task entering the blocked state was placed at the head of the
                 * list of blocked tasks then xNextTaskUnblockTime needs to be updated
                 * too. */
                if( xTimeToWake < xNextTaskUnblockTime )
    4efe:	20 91 3b 07 	lds	r18, 0x073B
    4f02:	30 91 3c 07 	lds	r19, 0x073C
    4f06:	8b 81       	ldd	r24, Y+3	; 0x03
    4f08:	9c 81       	ldd	r25, Y+4	; 0x04
    4f0a:	82 17       	cp	r24, r18
    4f0c:	93 07       	cpc	r25, r19
    4f0e:	30 f4       	brcc	.+12     	; 0x4f1c <prvAddCurrentTaskToDelayedList+0xba>
                {
                    xNextTaskUnblockTime = xTimeToWake;
    4f10:	8b 81       	ldd	r24, Y+3	; 0x03
    4f12:	9c 81       	ldd	r25, Y+4	; 0x04
    4f14:	90 93 3c 07 	sts	0x073C, r25
    4f18:	80 93 3b 07 	sts	0x073B, r24

            /* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
            ( void ) xCanBlockIndefinitely;
        }
    #endif /* INCLUDE_vTaskSuspend */
}
    4f1c:	27 96       	adiw	r28, 0x07	; 7
    4f1e:	0f b6       	in	r0, 0x3f	; 63
    4f20:	f8 94       	cli
    4f22:	de bf       	out	0x3e, r29	; 62
    4f24:	0f be       	out	0x3f, r0	; 63
    4f26:	cd bf       	out	0x3d, r28	; 61
    4f28:	cf 91       	pop	r28
    4f2a:	df 91       	pop	r29
    4f2c:	08 95       	ret

00004f2e <main>:
TaskHandle_t task2ptr;



int main(void)
{
    4f2e:	ef 92       	push	r14
    4f30:	ff 92       	push	r15
    4f32:	0f 93       	push	r16
    4f34:	df 93       	push	r29
    4f36:	cf 93       	push	r28
    4f38:	cd b7       	in	r28, 0x3d	; 61
    4f3a:	de b7       	in	r29, 0x3e	; 62
	DDRC  = 0xFF;	// Configure all PORTC pins as output pins
    4f3c:	e4 e3       	ldi	r30, 0x34	; 52
    4f3e:	f0 e0       	ldi	r31, 0x00	; 0
    4f40:	8f ef       	ldi	r24, 0xFF	; 255
    4f42:	80 83       	st	Z, r24

	xTaskCreate(Task1_Func,"first",configMINIMAL_STACK_SIZE,NULL,1,&task1ptr);
    4f44:	83 ec       	ldi	r24, 0xC3	; 195
    4f46:	97 e2       	ldi	r25, 0x27	; 39
    4f48:	25 e0       	ldi	r18, 0x05	; 5
    4f4a:	31 e0       	ldi	r19, 0x01	; 1
    4f4c:	ee e8       	ldi	r30, 0x8E	; 142
    4f4e:	f7 e0       	ldi	r31, 0x07	; 7
    4f50:	b9 01       	movw	r22, r18
    4f52:	45 e5       	ldi	r20, 0x55	; 85
    4f54:	50 e0       	ldi	r21, 0x00	; 0
    4f56:	20 e0       	ldi	r18, 0x00	; 0
    4f58:	30 e0       	ldi	r19, 0x00	; 0
    4f5a:	01 e0       	ldi	r16, 0x01	; 1
    4f5c:	7f 01       	movw	r14, r30
    4f5e:	0e 94 28 14 	call	0x2850	; 0x2850 <xTaskCreate>
	xTaskCreate(Task2_Func,"second",configMINIMAL_STACK_SIZE,NULL,1,&task2ptr);
    4f62:	87 ed       	ldi	r24, 0xD7	; 215
    4f64:	97 e2       	ldi	r25, 0x27	; 39
    4f66:	2b e0       	ldi	r18, 0x0B	; 11
    4f68:	31 e0       	ldi	r19, 0x01	; 1
    4f6a:	ec e8       	ldi	r30, 0x8C	; 140
    4f6c:	f7 e0       	ldi	r31, 0x07	; 7
    4f6e:	b9 01       	movw	r22, r18
    4f70:	45 e5       	ldi	r20, 0x55	; 85
    4f72:	50 e0       	ldi	r21, 0x00	; 0
    4f74:	20 e0       	ldi	r18, 0x00	; 0
    4f76:	30 e0       	ldi	r19, 0x00	; 0
    4f78:	01 e0       	ldi	r16, 0x01	; 1
    4f7a:	7f 01       	movw	r14, r30
    4f7c:	0e 94 28 14 	call	0x2850	; 0x2850 <xTaskCreate>

	vTaskStartScheduler();
    4f80:	0e 94 32 17 	call	0x2e64	; 0x2e64 <vTaskStartScheduler>
    4f84:	ff cf       	rjmp	.-2      	; 0x4f84 <main+0x56>

00004f86 <Task1_Func>:

	}
}

void Task1_Func(void *parameters)
{
    4f86:	df 93       	push	r29
    4f88:	cf 93       	push	r28
    4f8a:	00 d0       	rcall	.+0      	; 0x4f8c <Task1_Func+0x6>
    4f8c:	cd b7       	in	r28, 0x3d	; 61
    4f8e:	de b7       	in	r29, 0x3e	; 62
    4f90:	9a 83       	std	Y+2, r25	; 0x02
    4f92:	89 83       	std	Y+1, r24	; 0x01
	//xLastWakeTime = xTaskGetTickCount();

	while(1)
	{

		PORTC ^= (1u<<3);
    4f94:	a5 e3       	ldi	r26, 0x35	; 53
    4f96:	b0 e0       	ldi	r27, 0x00	; 0
    4f98:	e5 e3       	ldi	r30, 0x35	; 53
    4f9a:	f0 e0       	ldi	r31, 0x00	; 0
    4f9c:	90 81       	ld	r25, Z
    4f9e:	88 e0       	ldi	r24, 0x08	; 8
    4fa0:	89 27       	eor	r24, r25
    4fa2:	8c 93       	st	X, r24
		vTaskDelay(100);
    4fa4:	84 e6       	ldi	r24, 0x64	; 100
    4fa6:	90 e0       	ldi	r25, 0x00	; 0
    4fa8:	0e 94 10 17 	call	0x2e20	; 0x2e20 <vTaskDelay>
    4fac:	f3 cf       	rjmp	.-26     	; 0x4f94 <Task1_Func+0xe>

00004fae <Task2_Func>:

	}
}

void Task2_Func(void *parameters)
{
    4fae:	df 93       	push	r29
    4fb0:	cf 93       	push	r28
    4fb2:	00 d0       	rcall	.+0      	; 0x4fb4 <Task2_Func+0x6>
    4fb4:	cd b7       	in	r28, 0x3d	; 61
    4fb6:	de b7       	in	r29, 0x3e	; 62
    4fb8:	9a 83       	std	Y+2, r25	; 0x02
    4fba:	89 83       	std	Y+1, r24	; 0x01
	while(1)
	{

		PORTC ^= (1u<<5);
    4fbc:	a5 e3       	ldi	r26, 0x35	; 53
    4fbe:	b0 e0       	ldi	r27, 0x00	; 0
    4fc0:	e5 e3       	ldi	r30, 0x35	; 53
    4fc2:	f0 e0       	ldi	r31, 0x00	; 0
    4fc4:	90 81       	ld	r25, Z
    4fc6:	80 e2       	ldi	r24, 0x20	; 32
    4fc8:	89 27       	eor	r24, r25
    4fca:	8c 93       	st	X, r24
		vTaskDelay(30);
    4fcc:	8e e1       	ldi	r24, 0x1E	; 30
    4fce:	90 e0       	ldi	r25, 0x00	; 0
    4fd0:	0e 94 10 17 	call	0x2e20	; 0x2e20 <vTaskDelay>
    4fd4:	f3 cf       	rjmp	.-26     	; 0x4fbc <Task2_Func+0xe>

00004fd6 <__udivmodhi4>:
    4fd6:	aa 1b       	sub	r26, r26
    4fd8:	bb 1b       	sub	r27, r27
    4fda:	51 e1       	ldi	r21, 0x11	; 17
    4fdc:	07 c0       	rjmp	.+14     	; 0x4fec <__udivmodhi4_ep>

00004fde <__udivmodhi4_loop>:
    4fde:	aa 1f       	adc	r26, r26
    4fe0:	bb 1f       	adc	r27, r27
    4fe2:	a6 17       	cp	r26, r22
    4fe4:	b7 07       	cpc	r27, r23
    4fe6:	10 f0       	brcs	.+4      	; 0x4fec <__udivmodhi4_ep>
    4fe8:	a6 1b       	sub	r26, r22
    4fea:	b7 0b       	sbc	r27, r23

00004fec <__udivmodhi4_ep>:
    4fec:	88 1f       	adc	r24, r24
    4fee:	99 1f       	adc	r25, r25
    4ff0:	5a 95       	dec	r21
    4ff2:	a9 f7       	brne	.-22     	; 0x4fde <__udivmodhi4_loop>
    4ff4:	80 95       	com	r24
    4ff6:	90 95       	com	r25
    4ff8:	bc 01       	movw	r22, r24
    4ffa:	cd 01       	movw	r24, r26
    4ffc:	08 95       	ret

00004ffe <memcpy>:
    4ffe:	fb 01       	movw	r30, r22
    5000:	dc 01       	movw	r26, r24
    5002:	02 c0       	rjmp	.+4      	; 0x5008 <memcpy+0xa>
    5004:	01 90       	ld	r0, Z+
    5006:	0d 92       	st	X+, r0
    5008:	41 50       	subi	r20, 0x01	; 1
    500a:	50 40       	sbci	r21, 0x00	; 0
    500c:	d8 f7       	brcc	.-10     	; 0x5004 <memcpy+0x6>
    500e:	08 95       	ret

00005010 <memset>:
    5010:	dc 01       	movw	r26, r24
    5012:	01 c0       	rjmp	.+2      	; 0x5016 <memset+0x6>
    5014:	6d 93       	st	X+, r22
    5016:	41 50       	subi	r20, 0x01	; 1
    5018:	50 40       	sbci	r21, 0x00	; 0
    501a:	e0 f7       	brcc	.-8      	; 0x5014 <memset+0x4>
    501c:	08 95       	ret

0000501e <_exit>:
    501e:	f8 94       	cli

00005020 <__stop_program>:
    5020:	ff cf       	rjmp	.-2      	; 0x5020 <__stop_program>
